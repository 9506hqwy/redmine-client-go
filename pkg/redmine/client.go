// Package redmine provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package redmine

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	ApiKeyHeaderAuthScopes = "ApiKeyHeaderAuth.Scopes"
	ApiKeyQueryAuthScopes  = "ApiKeyQueryAuth.Scopes"
	BasicAuthScopes        = "BasicAuth.Scopes"
)

// AttachmentsDownloadParams defines parameters for AttachmentsDownload.
type AttachmentsDownloadParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// AttachmentsThumbnailParams defines parameters for AttachmentsThumbnail.
type AttachmentsThumbnailParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// AttachmentsThumbnailSizeParams defines parameters for AttachmentsThumbnailSize.
type AttachmentsThumbnailSizeParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// AttachmentsDestroyParams defines parameters for AttachmentsDestroy.
type AttachmentsDestroyParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// AttachmentsShowParams defines parameters for AttachmentsShow.
type AttachmentsShowParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// AttachmentsUpdatePatchJSONBody defines parameters for AttachmentsUpdatePatch.
type AttachmentsUpdatePatchJSONBody struct {
	Attachment *struct {
		// ContentType The content type of the attachment.
		ContentType *string `json:"content_type,omitempty"`

		// Description The description of the attachment.
		Description *string `json:"description,omitempty"`

		// Filename The filename of the attachment.
		Filename *string `json:"filename,omitempty"`
	} `json:"attachment,omitempty"`
}

// AttachmentsUpdatePatchParams defines parameters for AttachmentsUpdatePatch.
type AttachmentsUpdatePatchParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// AttachmentsUpdatePutJSONBody defines parameters for AttachmentsUpdatePut.
type AttachmentsUpdatePutJSONBody struct {
	Attachment *struct {
		// ContentType The content type of the attachment.
		ContentType *string `json:"content_type,omitempty"`

		// Description The description of the attachment.
		Description *string `json:"description,omitempty"`

		// Filename The filename of the attachment.
		Filename *string `json:"filename,omitempty"`
	} `json:"attachment,omitempty"`
}

// AttachmentsUpdatePutParams defines parameters for AttachmentsUpdatePut.
type AttachmentsUpdatePutParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// AttachmentsDownloadAllParams defines parameters for AttachmentsDownloadAll.
type AttachmentsDownloadAllParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// CustomFieldsIndexParams defines parameters for CustomFieldsIndex.
type CustomFieldsIndexParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// EnumerationsIndexDocumentCategoryParams defines parameters for EnumerationsIndexDocumentCategory.
type EnumerationsIndexDocumentCategoryParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// EnumerationsIndexIssuePriorityParams defines parameters for EnumerationsIndexIssuePriority.
type EnumerationsIndexIssuePriorityParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// EnumerationsIndexTimeEntryActivityParams defines parameters for EnumerationsIndexTimeEntryActivity.
type EnumerationsIndexTimeEntryActivityParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// GroupsIndexParams defines parameters for GroupsIndex.
type GroupsIndexParams struct {
	// Pagination Pagination parameters to control the number of items returned in the response.
	// If not specified, it defaults to 25 items per page.
	Pagination *struct {
		// Limit The number of items to be present in the response.
		// If not specified, it defaults to 25.
		Limit *int `json:"limit,omitempty"`

		// Nometa If set to 1, the response will not include pagination information.
		Nometa *int `json:"nometa,omitempty"`

		// Offset The offset of the first object to retrieve
		// If not specified, it defaults to 0.
		Offset *int `json:"offset,omitempty"`
	} `form:"pagination,omitempty" json:"pagination,omitempty"`

	// XRedmineNometa If set to 1, the response will not include metadata information.
	XRedmineNometa *int `json:"X-Redmine-Nometa,omitempty"`

	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// GroupsCreateJSONBody defines parameters for GroupsCreate.
type GroupsCreateJSONBody struct {
	// Group A single group.
	Group *struct {
		// CustomFieldValues The values of the custom fields.
		CustomFieldValues *map[string]interface{} `json:"custom_field_values,omitempty"`
		CustomFields      *[]struct {
			// Id The ID of the custom field.
			Id *int `json:"id,omitempty"`

			// Multiple Whether the custom field can have multiple values.
			Multiple *bool `json:"multiple,omitempty"`

			// Name The name of the custom field.
			Name  *string      `json:"name,omitempty"`
			Value *interface{} `json:"value,omitempty"`
		} `json:"custom_fields,omitempty"`

		// Name The name of the group.
		Name *string `json:"name,omitempty"`

		// TwofaRequired The 2FA required of the group.
		TwofaRequired *bool `json:"twofa_required,omitempty"`

		// UserIds The user id of the group.
		UserIds *[]int `json:"user_ids,omitempty"`
	} `json:"group,omitempty"`
}

// GroupsCreateParams defines parameters for GroupsCreate.
type GroupsCreateParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// GroupsDestroyParams defines parameters for GroupsDestroy.
type GroupsDestroyParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// GroupsShowParams defines parameters for GroupsShow.
type GroupsShowParams struct {
	// Include fetch associated data (optional).
	// Possible values: `users`, `memberships`.
	Include *[]string `form:"include,omitempty" json:"include,omitempty"`

	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// GroupsUpdatePatchJSONBody defines parameters for GroupsUpdatePatch.
type GroupsUpdatePatchJSONBody struct {
	// Group A single group.
	Group *struct {
		// CustomFieldValues The values of the custom fields.
		CustomFieldValues *map[string]interface{} `json:"custom_field_values,omitempty"`
		CustomFields      *[]struct {
			// Id The ID of the custom field.
			Id *int `json:"id,omitempty"`

			// Multiple Whether the custom field can have multiple values.
			Multiple *bool `json:"multiple,omitempty"`

			// Name The name of the custom field.
			Name  *string      `json:"name,omitempty"`
			Value *interface{} `json:"value,omitempty"`
		} `json:"custom_fields,omitempty"`

		// Name The name of the group.
		Name *string `json:"name,omitempty"`

		// TwofaRequired The 2FA required of the group.
		TwofaRequired *bool `json:"twofa_required,omitempty"`

		// UserIds The user id of the group.
		UserIds *[]int `json:"user_ids,omitempty"`
	} `json:"group,omitempty"`
}

// GroupsUpdatePatchParams defines parameters for GroupsUpdatePatch.
type GroupsUpdatePatchParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// GroupsUpdatePutJSONBody defines parameters for GroupsUpdatePut.
type GroupsUpdatePutJSONBody struct {
	// Group A single group.
	Group *struct {
		// CustomFieldValues The values of the custom fields.
		CustomFieldValues *map[string]interface{} `json:"custom_field_values,omitempty"`
		CustomFields      *[]struct {
			// Id The ID of the custom field.
			Id *int `json:"id,omitempty"`

			// Multiple Whether the custom field can have multiple values.
			Multiple *bool `json:"multiple,omitempty"`

			// Name The name of the custom field.
			Name  *string      `json:"name,omitempty"`
			Value *interface{} `json:"value,omitempty"`
		} `json:"custom_fields,omitempty"`

		// Name The name of the group.
		Name *string `json:"name,omitempty"`

		// TwofaRequired The 2FA required of the group.
		TwofaRequired *bool `json:"twofa_required,omitempty"`

		// UserIds The user id of the group.
		UserIds *[]int `json:"user_ids,omitempty"`
	} `json:"group,omitempty"`
}

// GroupsUpdatePutParams defines parameters for GroupsUpdatePut.
type GroupsUpdatePutParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// GroupsAddUsersJSONBody defines parameters for GroupsAddUsers.
type GroupsAddUsersJSONBody struct {
	UserIds *[]int `json:"user_ids,omitempty"`
}

// GroupsAddUsersParams defines parameters for GroupsAddUsers.
type GroupsAddUsersParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// GroupsRemoveUserParams defines parameters for GroupsRemoveUser.
type GroupsRemoveUserParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// IssueCategoriesDestroyParams defines parameters for IssueCategoriesDestroy.
type IssueCategoriesDestroyParams struct {
	// ReassignToId The ID of the issue category.
	ReassignToId *int `form:"reassign_to_id,omitempty" json:"reassign_to_id,omitempty"`

	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// IssueCategoriesShowParams defines parameters for IssueCategoriesShow.
type IssueCategoriesShowParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// IssueCategoriesUpdatePatchJSONBody defines parameters for IssueCategoriesUpdatePatch.
type IssueCategoriesUpdatePatchJSONBody struct {
	// IssueCategory A single issue_category.
	IssueCategory *struct {
		// AssignedToId The ID of the assinged to.
		AssignedToId *int `json:"assigned_to_id,omitempty"`

		// Name The name of the issue category.
		Name *string `json:"name,omitempty"`
	} `json:"issue_category,omitempty"`
}

// IssueCategoriesUpdatePatchParams defines parameters for IssueCategoriesUpdatePatch.
type IssueCategoriesUpdatePatchParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// IssueCategoriesUpdatePutJSONBody defines parameters for IssueCategoriesUpdatePut.
type IssueCategoriesUpdatePutJSONBody struct {
	// IssueCategory A single issue_category.
	IssueCategory *struct {
		// AssignedToId The ID of the assinged to.
		AssignedToId *int `json:"assigned_to_id,omitempty"`

		// Name The name of the issue category.
		Name *string `json:"name,omitempty"`
	} `json:"issue_category,omitempty"`
}

// IssueCategoriesUpdatePutParams defines parameters for IssueCategoriesUpdatePut.
type IssueCategoriesUpdatePutParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// IssueStatusesIndexParams defines parameters for IssueStatusesIndex.
type IssueStatusesIndexParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// IssuesIndexCsvParams_Query defines parameters for IssuesIndexCsv.
type IssuesIndexCsvParams_Query struct {
	// AnySearchable The expression of any searchable of the issue.
	// The expression format is "[operator]\<value>".
	AnySearchable *string `json:"any_searchable,omitempty"`

	// AssignedToId The expression of assigned to id of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	AssignedToId *string `json:"assigned_to_id,omitempty"`

	// AssignedToRole The expression of assigned to role of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	AssignedToRole *string `json:"assigned_to_role,omitempty"`

	// Attachment The expression of attachment of the issue.
	// The expression format is "[operator]\<value>".
	Attachment *string `json:"attachment,omitempty"`

	// AttachmentDescription The expression of attachment description of the issue.
	// The expression format is "[operator]\<value>".
	AttachmentDescription *string `json:"attachment_description,omitempty"`

	// AuthorGroup The expression of author group of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	AuthorGroup *string `json:"author.group,omitempty"`

	// AuthorRole The expression of author role of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	AuthorRole *string `json:"author.role,omitempty"`

	// AuthorId The expression of author id of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	AuthorId *string `json:"author_id,omitempty"`

	// CategoryId The expression of category id of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	CategoryId *string `json:"category_id,omitempty"`

	// ChildId The expression of child id of the issue.
	// The expression format is "[operator]\<value>".
	ChildId *string `json:"child_id,omitempty"`

	// ClosedOn The expression of closed_on of the issue.
	// The expression format is "[operator]\<value>".
	// examples:
	// - last week : `lw`
	// - before "2025/7/12": `<=2025-07-12`
	ClosedOn *string `json:"closed_on,omitempty"`

	// CreatedOn The expression of created_on of the issue.
	// The expression format is "[operator]\<value>".
	// examples:
	// - last week : `lw`
	// - before "2025/7/12": `<=2025-07-12`
	CreatedOn *string `json:"created_on,omitempty"`

	// Description The expression of description of the issue.
	// The expression format is "\<operator>\<value>".
	Description *string `json:"description,omitempty"`

	// DoneRatio The expression of done ratio of the issue.
	// The expression format is "[operator]\<value>".
	DoneRatio *string `json:"done_ratio,omitempty"`

	// DueDate The expression of due date of the issue.
	// The expression format is "[operator]\<value>".
	// examples:
	// - last week : `lw`
	// - before "2025/7/12": `<=2025-07-12`
	DueDate *string `json:"due_date,omitempty"`

	// EstimatedHours The expression of estimated hours of the issue.
	// The expression format is "[operator]\<value>".
	EstimatedHours *string `json:"estimated_hours,omitempty"`

	// FixedVersionDueDate The expression of fixed version due date of the issue.
	// The expression format is "[operator]\<value>".
	// examples:
	// - last week : `lw`
	// - before "2025/7/12": `<=2025-07-12`
	FixedVersionDueDate *string `json:"fixed_version.due_date,omitempty"`

	// FixedVersionStatus The expression of fixed version status of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	FixedVersionStatus *string `json:"fixed_version.status,omitempty"`

	// FixedVersionId The expression of fixed version id of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	FixedVersionId *string `json:"fixed_version_id,omitempty"`

	// IsPrivate The expression of private id of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	IsPrivate *string `json:"is_private,omitempty"`

	// IssueId The expression of issue id of the issue.
	// The expression format is "[operator]\<value>".
	IssueId *string `json:"issue_id,omitempty"`

	// LastUpdatedBy The expression of last updated by of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	LastUpdatedBy *string `json:"last_updated_by,omitempty"`

	// MemberOfGroup The expression of member of group of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	MemberOfGroup *string `json:"member_of_group,omitempty"`

	// Notes The expression of notes of the issue.
	// The expression format is "\<operator>\<value>".
	Notes *string `json:"notes,omitempty"`

	// ParentId The expression of parent id of the issue.
	// The expression format is "[operator]\<value>".
	ParentId *string `json:"parent_id,omitempty"`

	// PriorityId The expression of priority id of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	PriorityId *string `json:"priority_id,omitempty"`

	// ProjectStatus The expression of project status of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	ProjectStatus *string `json:"project.status,omitempty"`

	// ProjectId The expression of project ID or identifier of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	ProjectId *string `json:"project_id,omitempty"`

	// RelationType The expression of relation type of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	RelationType *string `json:"relation_type,omitempty"`

	// SpentTime The expression of spent time of the issue.
	// The expression format is "[operator]\<value>".
	SpentTime *string `json:"spent_time,omitempty"`

	// StartDate The expression of start date of the issue.
	// The expression format is "[operator]\<value>".
	// examples:
	// - last week : `lw`
	// - before "2025/7/12": `<=2025-07-12`
	StartDate *string `json:"start_date,omitempty"`

	// StatusId The expression of status id of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	StatusId *string `json:"status_id,omitempty"`

	// Subject The expression of subject of the issue.
	// The expression format is "\<operator>\<value>".
	Subject *string `json:"subject,omitempty"`

	// SubprojectId The expression of sub project ID or identifier of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	SubprojectId *string `json:"subproject_id,omitempty"`

	// TrackerId The expression of tracker id of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	TrackerId *string `json:"tracker_id,omitempty"`

	// UpdatedBy The expression of updated by of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	UpdatedBy *string `json:"updated_by,omitempty"`

	// UpdatedOn The expression of updated_on of the issue.
	// The expression format is "[operator]\<value>".
	// examples:
	// - last week : `lw`
	// - before "2025/7/12": `<=2025-07-12`
	UpdatedOn *string `json:"updated_on,omitempty"`

	// WatcherId The expression of watcher id of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	WatcherId            *string           `json:"watcher_id,omitempty"`
	AdditionalProperties map[string]string `json:"-"`
}

// IssuesIndexCsvParams defines parameters for IssuesIndexCsv.
type IssuesIndexCsvParams struct {
	// Pagination Pagination parameters to control the number of items returned in the response.
	// If not specified, it defaults to 25 items per page.
	Pagination *struct {
		// Limit The number of items to be present in the response.
		// If not specified, it defaults to 25.
		Limit *int `json:"limit,omitempty"`

		// Nometa If set to 1, the response will not include pagination information.
		Nometa *int `json:"nometa,omitempty"`

		// Offset The offset of the first object to retrieve
		// If not specified, it defaults to 0.
		Offset *int `json:"offset,omitempty"`
	} `form:"pagination,omitempty" json:"pagination,omitempty"`
	Query *IssuesIndexCsvParams_Query `form:"query,omitempty" json:"query,omitempty"`

	// Include fetch associated data (optional).
	// Possible values: `allowed_statuses`, `attachments`, `changesets`, `children`, `journals`, `relations`, `watchers`.
	Include *[]string `form:"include,omitempty" json:"include,omitempty"`

	// XRedmineNometa If set to 1, the response will not include metadata information.
	XRedmineNometa *int `json:"X-Redmine-Nometa,omitempty"`

	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// IssuesIndexParams_Query defines parameters for IssuesIndex.
type IssuesIndexParams_Query struct {
	// AnySearchable The expression of any searchable of the issue.
	// The expression format is "[operator]\<value>".
	AnySearchable *string `json:"any_searchable,omitempty"`

	// AssignedToId The expression of assigned to id of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	AssignedToId *string `json:"assigned_to_id,omitempty"`

	// AssignedToRole The expression of assigned to role of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	AssignedToRole *string `json:"assigned_to_role,omitempty"`

	// Attachment The expression of attachment of the issue.
	// The expression format is "[operator]\<value>".
	Attachment *string `json:"attachment,omitempty"`

	// AttachmentDescription The expression of attachment description of the issue.
	// The expression format is "[operator]\<value>".
	AttachmentDescription *string `json:"attachment_description,omitempty"`

	// AuthorGroup The expression of author group of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	AuthorGroup *string `json:"author.group,omitempty"`

	// AuthorRole The expression of author role of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	AuthorRole *string `json:"author.role,omitempty"`

	// AuthorId The expression of author id of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	AuthorId *string `json:"author_id,omitempty"`

	// CategoryId The expression of category id of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	CategoryId *string `json:"category_id,omitempty"`

	// ChildId The expression of child id of the issue.
	// The expression format is "[operator]\<value>".
	ChildId *string `json:"child_id,omitempty"`

	// ClosedOn The expression of closed_on of the issue.
	// The expression format is "[operator]\<value>".
	// examples:
	// - last week : `lw`
	// - before "2025/7/12": `<=2025-07-12`
	ClosedOn *string `json:"closed_on,omitempty"`

	// CreatedOn The expression of created_on of the issue.
	// The expression format is "[operator]\<value>".
	// examples:
	// - last week : `lw`
	// - before "2025/7/12": `<=2025-07-12`
	CreatedOn *string `json:"created_on,omitempty"`

	// Description The expression of description of the issue.
	// The expression format is "\<operator>\<value>".
	Description *string `json:"description,omitempty"`

	// DoneRatio The expression of done ratio of the issue.
	// The expression format is "[operator]\<value>".
	DoneRatio *string `json:"done_ratio,omitempty"`

	// DueDate The expression of due date of the issue.
	// The expression format is "[operator]\<value>".
	// examples:
	// - last week : `lw`
	// - before "2025/7/12": `<=2025-07-12`
	DueDate *string `json:"due_date,omitempty"`

	// EstimatedHours The expression of estimated hours of the issue.
	// The expression format is "[operator]\<value>".
	EstimatedHours *string `json:"estimated_hours,omitempty"`

	// FixedVersionDueDate The expression of fixed version due date of the issue.
	// The expression format is "[operator]\<value>".
	// examples:
	// - last week : `lw`
	// - before "2025/7/12": `<=2025-07-12`
	FixedVersionDueDate *string `json:"fixed_version.due_date,omitempty"`

	// FixedVersionStatus The expression of fixed version status of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	FixedVersionStatus *string `json:"fixed_version.status,omitempty"`

	// FixedVersionId The expression of fixed version id of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	FixedVersionId *string `json:"fixed_version_id,omitempty"`

	// IsPrivate The expression of private id of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	IsPrivate *string `json:"is_private,omitempty"`

	// IssueId The expression of issue id of the issue.
	// The expression format is "[operator]\<value>".
	IssueId *string `json:"issue_id,omitempty"`

	// LastUpdatedBy The expression of last updated by of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	LastUpdatedBy *string `json:"last_updated_by,omitempty"`

	// MemberOfGroup The expression of member of group of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	MemberOfGroup *string `json:"member_of_group,omitempty"`

	// Notes The expression of notes of the issue.
	// The expression format is "\<operator>\<value>".
	Notes *string `json:"notes,omitempty"`

	// ParentId The expression of parent id of the issue.
	// The expression format is "[operator]\<value>".
	ParentId *string `json:"parent_id,omitempty"`

	// PriorityId The expression of priority id of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	PriorityId *string `json:"priority_id,omitempty"`

	// ProjectStatus The expression of project status of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	ProjectStatus *string `json:"project.status,omitempty"`

	// ProjectId The expression of project ID or identifier of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	ProjectId *string `json:"project_id,omitempty"`

	// RelationType The expression of relation type of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	RelationType *string `json:"relation_type,omitempty"`

	// SpentTime The expression of spent time of the issue.
	// The expression format is "[operator]\<value>".
	SpentTime *string `json:"spent_time,omitempty"`

	// StartDate The expression of start date of the issue.
	// The expression format is "[operator]\<value>".
	// examples:
	// - last week : `lw`
	// - before "2025/7/12": `<=2025-07-12`
	StartDate *string `json:"start_date,omitempty"`

	// StatusId The expression of status id of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	StatusId *string `json:"status_id,omitempty"`

	// Subject The expression of subject of the issue.
	// The expression format is "\<operator>\<value>".
	Subject *string `json:"subject,omitempty"`

	// SubprojectId The expression of sub project ID or identifier of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	SubprojectId *string `json:"subproject_id,omitempty"`

	// TrackerId The expression of tracker id of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	TrackerId *string `json:"tracker_id,omitempty"`

	// UpdatedBy The expression of updated by of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	UpdatedBy *string `json:"updated_by,omitempty"`

	// UpdatedOn The expression of updated_on of the issue.
	// The expression format is "[operator]\<value>".
	// examples:
	// - last week : `lw`
	// - before "2025/7/12": `<=2025-07-12`
	UpdatedOn *string `json:"updated_on,omitempty"`

	// WatcherId The expression of watcher id of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	WatcherId            *string           `json:"watcher_id,omitempty"`
	AdditionalProperties map[string]string `json:"-"`
}

// IssuesIndexParams defines parameters for IssuesIndex.
type IssuesIndexParams struct {
	// Pagination Pagination parameters to control the number of items returned in the response.
	// If not specified, it defaults to 25 items per page.
	Pagination *struct {
		// Limit The number of items to be present in the response.
		// If not specified, it defaults to 25.
		Limit *int `json:"limit,omitempty"`

		// Nometa If set to 1, the response will not include pagination information.
		Nometa *int `json:"nometa,omitempty"`

		// Offset The offset of the first object to retrieve
		// If not specified, it defaults to 0.
		Offset *int `json:"offset,omitempty"`
	} `form:"pagination,omitempty" json:"pagination,omitempty"`
	Query *IssuesIndexParams_Query `form:"query,omitempty" json:"query,omitempty"`

	// Include fetch associated data (optional).
	// Possible values: `allowed_statuses`, `attachments`, `changesets`, `children`, `journals`, `relations`, `watchers`.
	Include *[]string `form:"include,omitempty" json:"include,omitempty"`

	// XRedmineNometa If set to 1, the response will not include metadata information.
	XRedmineNometa *int `json:"X-Redmine-Nometa,omitempty"`

	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// IssuesCreateJSONBody defines parameters for IssuesCreate.
type IssuesCreateJSONBody struct {
	// Issue A single issue.
	Issue *struct {
		// AssignedToId The assigned to id id of the issue.
		AssignedToId *int `json:"assigned_to_id,omitempty"`

		// CategoryId The category id of the issue.
		CategoryId *int `json:"category_id,omitempty"`

		// CustomFieldValues The values of the custom fields.
		CustomFieldValues *map[string]interface{} `json:"custom_field_values,omitempty"`
		CustomFields      *[]struct {
			// Id The ID of the custom field.
			Id *int `json:"id,omitempty"`

			// Multiple Whether the custom field can have multiple values.
			Multiple *bool `json:"multiple,omitempty"`

			// Name The name of the custom field.
			Name  *string      `json:"name,omitempty"`
			Value *interface{} `json:"value,omitempty"`
		} `json:"custom_fields,omitempty"`
		DeletedAttachmentIds *[]int `json:"deleted_attachment_ids,omitempty"`

		// Description The description of the issue.
		Description *string `json:"description,omitempty"`

		// DoneRatio The done ratio of the issue.
		DoneRatio *int `json:"done_ratio,omitempty"`

		// DueDate The due date of the issue.
		DueDate *openapi_types.Date `json:"due_date,omitempty"`

		// EstimatedHours The estimated hours of the issue.
		EstimatedHours *float32 `json:"estimated_hours,omitempty"`

		// FixedVersionId The fixed version id of the issue.
		FixedVersionId *int `json:"fixed_version_id,omitempty"`

		// IsPrivate The private of the issue.
		IsPrivate *bool `json:"is_private,omitempty"`

		// Notes The notes of the issue.
		Notes *string `json:"notes,omitempty"`

		// ParentIssueId The parent ID of the issue.
		ParentIssueId *int `json:"parent_issue_id,omitempty"`

		// PriorityId The priority id of the issue.
		PriorityId *int `json:"priority_id,omitempty"`

		// PrivateNotes The private notes of the issue.
		PrivateNotes *bool `json:"private_notes,omitempty"`

		// ProjectId The project ID or identifier of the issue.
		ProjectId *string `json:"project_id,omitempty"`

		// StartDate The start date of the issue.
		StartDate *openapi_types.Date `json:"start_date,omitempty"`

		// StatusId The status id of the issue.
		StatusId *int `json:"status_id,omitempty"`

		// Subject The subject of the issue.
		Subject *string `json:"subject,omitempty"`

		// TrackerId The tracker id of the issue.
		TrackerId      *int   `json:"tracker_id,omitempty"`
		WatcherUserIds *[]int `json:"watcher_user_ids,omitempty"`
	} `json:"issue,omitempty"`
}

// IssuesCreateParams defines parameters for IssuesCreate.
type IssuesCreateParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// IssuesIndexPdfParams_Query defines parameters for IssuesIndexPdf.
type IssuesIndexPdfParams_Query struct {
	// AnySearchable The expression of any searchable of the issue.
	// The expression format is "[operator]\<value>".
	AnySearchable *string `json:"any_searchable,omitempty"`

	// AssignedToId The expression of assigned to id of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	AssignedToId *string `json:"assigned_to_id,omitempty"`

	// AssignedToRole The expression of assigned to role of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	AssignedToRole *string `json:"assigned_to_role,omitempty"`

	// Attachment The expression of attachment of the issue.
	// The expression format is "[operator]\<value>".
	Attachment *string `json:"attachment,omitempty"`

	// AttachmentDescription The expression of attachment description of the issue.
	// The expression format is "[operator]\<value>".
	AttachmentDescription *string `json:"attachment_description,omitempty"`

	// AuthorGroup The expression of author group of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	AuthorGroup *string `json:"author.group,omitempty"`

	// AuthorRole The expression of author role of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	AuthorRole *string `json:"author.role,omitempty"`

	// AuthorId The expression of author id of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	AuthorId *string `json:"author_id,omitempty"`

	// CategoryId The expression of category id of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	CategoryId *string `json:"category_id,omitempty"`

	// ChildId The expression of child id of the issue.
	// The expression format is "[operator]\<value>".
	ChildId *string `json:"child_id,omitempty"`

	// ClosedOn The expression of closed_on of the issue.
	// The expression format is "[operator]\<value>".
	// examples:
	// - last week : `lw`
	// - before "2025/7/12": `<=2025-07-12`
	ClosedOn *string `json:"closed_on,omitempty"`

	// CreatedOn The expression of created_on of the issue.
	// The expression format is "[operator]\<value>".
	// examples:
	// - last week : `lw`
	// - before "2025/7/12": `<=2025-07-12`
	CreatedOn *string `json:"created_on,omitempty"`

	// Description The expression of description of the issue.
	// The expression format is "\<operator>\<value>".
	Description *string `json:"description,omitempty"`

	// DoneRatio The expression of done ratio of the issue.
	// The expression format is "[operator]\<value>".
	DoneRatio *string `json:"done_ratio,omitempty"`

	// DueDate The expression of due date of the issue.
	// The expression format is "[operator]\<value>".
	// examples:
	// - last week : `lw`
	// - before "2025/7/12": `<=2025-07-12`
	DueDate *string `json:"due_date,omitempty"`

	// EstimatedHours The expression of estimated hours of the issue.
	// The expression format is "[operator]\<value>".
	EstimatedHours *string `json:"estimated_hours,omitempty"`

	// FixedVersionDueDate The expression of fixed version due date of the issue.
	// The expression format is "[operator]\<value>".
	// examples:
	// - last week : `lw`
	// - before "2025/7/12": `<=2025-07-12`
	FixedVersionDueDate *string `json:"fixed_version.due_date,omitempty"`

	// FixedVersionStatus The expression of fixed version status of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	FixedVersionStatus *string `json:"fixed_version.status,omitempty"`

	// FixedVersionId The expression of fixed version id of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	FixedVersionId *string `json:"fixed_version_id,omitempty"`

	// IsPrivate The expression of private id of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	IsPrivate *string `json:"is_private,omitempty"`

	// IssueId The expression of issue id of the issue.
	// The expression format is "[operator]\<value>".
	IssueId *string `json:"issue_id,omitempty"`

	// LastUpdatedBy The expression of last updated by of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	LastUpdatedBy *string `json:"last_updated_by,omitempty"`

	// MemberOfGroup The expression of member of group of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	MemberOfGroup *string `json:"member_of_group,omitempty"`

	// Notes The expression of notes of the issue.
	// The expression format is "\<operator>\<value>".
	Notes *string `json:"notes,omitempty"`

	// ParentId The expression of parent id of the issue.
	// The expression format is "[operator]\<value>".
	ParentId *string `json:"parent_id,omitempty"`

	// PriorityId The expression of priority id of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	PriorityId *string `json:"priority_id,omitempty"`

	// ProjectStatus The expression of project status of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	ProjectStatus *string `json:"project.status,omitempty"`

	// ProjectId The expression of project ID or identifier of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	ProjectId *string `json:"project_id,omitempty"`

	// RelationType The expression of relation type of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	RelationType *string `json:"relation_type,omitempty"`

	// SpentTime The expression of spent time of the issue.
	// The expression format is "[operator]\<value>".
	SpentTime *string `json:"spent_time,omitempty"`

	// StartDate The expression of start date of the issue.
	// The expression format is "[operator]\<value>".
	// examples:
	// - last week : `lw`
	// - before "2025/7/12": `<=2025-07-12`
	StartDate *string `json:"start_date,omitempty"`

	// StatusId The expression of status id of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	StatusId *string `json:"status_id,omitempty"`

	// Subject The expression of subject of the issue.
	// The expression format is "\<operator>\<value>".
	Subject *string `json:"subject,omitempty"`

	// SubprojectId The expression of sub project ID or identifier of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	SubprojectId *string `json:"subproject_id,omitempty"`

	// TrackerId The expression of tracker id of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	TrackerId *string `json:"tracker_id,omitempty"`

	// UpdatedBy The expression of updated by of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	UpdatedBy *string `json:"updated_by,omitempty"`

	// UpdatedOn The expression of updated_on of the issue.
	// The expression format is "[operator]\<value>".
	// examples:
	// - last week : `lw`
	// - before "2025/7/12": `<=2025-07-12`
	UpdatedOn *string `json:"updated_on,omitempty"`

	// WatcherId The expression of watcher id of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	WatcherId            *string           `json:"watcher_id,omitempty"`
	AdditionalProperties map[string]string `json:"-"`
}

// IssuesIndexPdfParams defines parameters for IssuesIndexPdf.
type IssuesIndexPdfParams struct {
	// Pagination Pagination parameters to control the number of items returned in the response.
	// If not specified, it defaults to 25 items per page.
	Pagination *struct {
		// Limit The number of items to be present in the response.
		// If not specified, it defaults to 25.
		Limit *int `json:"limit,omitempty"`

		// Nometa If set to 1, the response will not include pagination information.
		Nometa *int `json:"nometa,omitempty"`

		// Offset The offset of the first object to retrieve
		// If not specified, it defaults to 0.
		Offset *int `json:"offset,omitempty"`
	} `form:"pagination,omitempty" json:"pagination,omitempty"`
	Query *IssuesIndexPdfParams_Query `form:"query,omitempty" json:"query,omitempty"`

	// Include fetch associated data (optional).
	// Possible values: `allowed_statuses`, `attachments`, `changesets`, `children`, `journals`, `relations`, `watchers`.
	Include *[]string `form:"include,omitempty" json:"include,omitempty"`

	// XRedmineNometa If set to 1, the response will not include metadata information.
	XRedmineNometa *int `json:"X-Redmine-Nometa,omitempty"`

	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// GanttsShowPdfParams defines parameters for GanttsShowPdf.
type GanttsShowPdfParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// GanttsShowPngParams defines parameters for GanttsShowPng.
type GanttsShowPngParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// IssuesDestroyParams defines parameters for IssuesDestroy.
type IssuesDestroyParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// IssuesShowParams defines parameters for IssuesShow.
type IssuesShowParams struct {
	// Include fetch associated data (optional).
	// Possible values: `allowed_statuses`, `attachments`, `changesets`, `children`, `journals`, `relations`, `watchers`.
	Include *[]string `form:"include,omitempty" json:"include,omitempty"`

	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// IssuesUpdatePatchJSONBody defines parameters for IssuesUpdatePatch.
type IssuesUpdatePatchJSONBody struct {
	// Issue A single issue.
	Issue *struct {
		// AssignedToId The assigned to id id of the issue.
		AssignedToId *int `json:"assigned_to_id,omitempty"`

		// CategoryId The category id of the issue.
		CategoryId *int `json:"category_id,omitempty"`

		// CustomFieldValues The values of the custom fields.
		CustomFieldValues *map[string]interface{} `json:"custom_field_values,omitempty"`
		CustomFields      *[]struct {
			// Id The ID of the custom field.
			Id *int `json:"id,omitempty"`

			// Multiple Whether the custom field can have multiple values.
			Multiple *bool `json:"multiple,omitempty"`

			// Name The name of the custom field.
			Name  *string      `json:"name,omitempty"`
			Value *interface{} `json:"value,omitempty"`
		} `json:"custom_fields,omitempty"`
		DeletedAttachmentIds *[]int `json:"deleted_attachment_ids,omitempty"`

		// Description The description of the issue.
		Description *string `json:"description,omitempty"`

		// DoneRatio The done ratio of the issue.
		DoneRatio *int `json:"done_ratio,omitempty"`

		// DueDate The due date of the issue.
		DueDate *openapi_types.Date `json:"due_date,omitempty"`

		// EstimatedHours The estimated hours of the issue.
		EstimatedHours *float32 `json:"estimated_hours,omitempty"`

		// FixedVersionId The fixed version id of the issue.
		FixedVersionId *int `json:"fixed_version_id,omitempty"`

		// IsPrivate The private of the issue.
		IsPrivate *bool `json:"is_private,omitempty"`

		// Notes The notes of the issue.
		Notes *string `json:"notes,omitempty"`

		// ParentIssueId The parent ID of the issue.
		ParentIssueId *int `json:"parent_issue_id,omitempty"`

		// PriorityId The priority id of the issue.
		PriorityId *int `json:"priority_id,omitempty"`

		// PrivateNotes The private notes of the issue.
		PrivateNotes *bool `json:"private_notes,omitempty"`

		// ProjectId The project ID or identifier of the issue.
		ProjectId *string `json:"project_id,omitempty"`

		// StartDate The start date of the issue.
		StartDate *openapi_types.Date `json:"start_date,omitempty"`

		// StatusId The status id of the issue.
		StatusId *int `json:"status_id,omitempty"`

		// Subject The subject of the issue.
		Subject *string `json:"subject,omitempty"`

		// TrackerId The tracker id of the issue.
		TrackerId      *int   `json:"tracker_id,omitempty"`
		WatcherUserIds *[]int `json:"watcher_user_ids,omitempty"`
	} `json:"issue,omitempty"`
}

// IssuesUpdatePatchParams defines parameters for IssuesUpdatePatch.
type IssuesUpdatePatchParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// IssuesUpdatePutJSONBody defines parameters for IssuesUpdatePut.
type IssuesUpdatePutJSONBody struct {
	// Issue A single issue.
	Issue *struct {
		// AssignedToId The assigned to id id of the issue.
		AssignedToId *int `json:"assigned_to_id,omitempty"`

		// CategoryId The category id of the issue.
		CategoryId *int `json:"category_id,omitempty"`

		// CustomFieldValues The values of the custom fields.
		CustomFieldValues *map[string]interface{} `json:"custom_field_values,omitempty"`
		CustomFields      *[]struct {
			// Id The ID of the custom field.
			Id *int `json:"id,omitempty"`

			// Multiple Whether the custom field can have multiple values.
			Multiple *bool `json:"multiple,omitempty"`

			// Name The name of the custom field.
			Name  *string      `json:"name,omitempty"`
			Value *interface{} `json:"value,omitempty"`
		} `json:"custom_fields,omitempty"`
		DeletedAttachmentIds *[]int `json:"deleted_attachment_ids,omitempty"`

		// Description The description of the issue.
		Description *string `json:"description,omitempty"`

		// DoneRatio The done ratio of the issue.
		DoneRatio *int `json:"done_ratio,omitempty"`

		// DueDate The due date of the issue.
		DueDate *openapi_types.Date `json:"due_date,omitempty"`

		// EstimatedHours The estimated hours of the issue.
		EstimatedHours *float32 `json:"estimated_hours,omitempty"`

		// FixedVersionId The fixed version id of the issue.
		FixedVersionId *int `json:"fixed_version_id,omitempty"`

		// IsPrivate The private of the issue.
		IsPrivate *bool `json:"is_private,omitempty"`

		// Notes The notes of the issue.
		Notes *string `json:"notes,omitempty"`

		// ParentIssueId The parent ID of the issue.
		ParentIssueId *int `json:"parent_issue_id,omitempty"`

		// PriorityId The priority id of the issue.
		PriorityId *int `json:"priority_id,omitempty"`

		// PrivateNotes The private notes of the issue.
		PrivateNotes *bool `json:"private_notes,omitempty"`

		// ProjectId The project ID or identifier of the issue.
		ProjectId *string `json:"project_id,omitempty"`

		// StartDate The start date of the issue.
		StartDate *openapi_types.Date `json:"start_date,omitempty"`

		// StatusId The status id of the issue.
		StatusId *int `json:"status_id,omitempty"`

		// Subject The subject of the issue.
		Subject *string `json:"subject,omitempty"`

		// TrackerId The tracker id of the issue.
		TrackerId      *int   `json:"tracker_id,omitempty"`
		WatcherUserIds *[]int `json:"watcher_user_ids,omitempty"`
	} `json:"issue,omitempty"`
}

// IssuesUpdatePutParams defines parameters for IssuesUpdatePut.
type IssuesUpdatePutParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// IssuesShowPdfParams defines parameters for IssuesShowPdf.
type IssuesShowPdfParams struct {
	// Include fetch associated data (optional).
	// Possible values: `allowed_statuses`, `attachments`, `changesets`, `children`, `journals`, `relations`, `watchers`.
	Include *[]string `form:"include,omitempty" json:"include,omitempty"`

	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// IssueRelationsIndexParams defines parameters for IssueRelationsIndex.
type IssueRelationsIndexParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// IssueRelationsCreateJSONBody defines parameters for IssueRelationsCreate.
type IssueRelationsCreateJSONBody struct {
	// Relation Represents a new issue relation to be created.
	Relation *struct {
		// IssueToId The ID of the issue to. Values should be separated by a comma ",".
		IssueToId *string `json:"issue_to_id,omitempty"`

		// RelationType The relation type of the relation.
		//  Possible values are:
		//  - `relates`
		//  - `duplicates`
		//  - `duplicated`
		//  - `blocks`
		//  - `blocked`
		//  - `precedes`
		//  - `follows`
		//  - `copied_to`
		//  - `copied_from`
		RelationType *string `json:"relation_type,omitempty"`
	} `json:"relation,omitempty"`
}

// IssueRelationsCreateParams defines parameters for IssueRelationsCreate.
type IssueRelationsCreateParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// TimelogCreateIssueJSONBody defines parameters for TimelogCreateIssue.
type TimelogCreateIssueJSONBody struct {
	// TimeEntry A single time entry.
	TimeEntry *struct {
		// ActivityId The activity ID of the time entry.
		ActivityId *int `json:"activity_id,omitempty"`

		// Comments The comments of the time entry.
		Comments *string `json:"comments,omitempty"`

		// CustomFieldValues The values of the custom fields.
		CustomFieldValues *map[string]interface{} `json:"custom_field_values,omitempty"`
		CustomFields      *[]struct {
			// Id The ID of the custom field.
			Id *int `json:"id,omitempty"`

			// Multiple Whether the custom field can have multiple values.
			Multiple *bool `json:"multiple,omitempty"`

			// Name The name of the custom field.
			Name  *string      `json:"name,omitempty"`
			Value *interface{} `json:"value,omitempty"`
		} `json:"custom_fields,omitempty"`

		// Hours The hours of the time entry.
		Hours *float32 `json:"hours,omitempty"`

		// IssueId The issue ID of the time entry.
		IssueId *int `json:"issue_id,omitempty"`

		// ProjectId The project ID of the time entry.
		ProjectId *int `json:"project_id,omitempty"`

		// SpentOn The spent on of the time entry.
		SpentOn *openapi_types.Date `json:"spent_on,omitempty"`

		// UserId The user ID of the time entry.
		UserId *int `json:"user_id,omitempty"`
	} `json:"time_entry,omitempty"`
}

// TimelogCreateIssueParams defines parameters for TimelogCreateIssue.
type TimelogCreateIssueParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// WatchersCreateIssueJSONBody defines parameters for WatchersCreateIssue.
type WatchersCreateIssueJSONBody struct {
	// ObjectId The ID of the object.
	ObjectId *int `json:"object_id,omitempty"`

	// ObjectType The type of the object.
	ObjectType *string `json:"object_type,omitempty"`

	// Watcher Represents a single watcher.
	Watcher *struct {
		// UserId The ID of the user.
		UserId  *int   `json:"user_id,omitempty"`
		UserIds *[]int `json:"user_ids,omitempty"`
	} `json:"watcher,omitempty"`
}

// WatchersCreateIssueParams defines parameters for WatchersCreateIssue.
type WatchersCreateIssueParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// WatchersDestroyIssueParams defines parameters for WatchersDestroyIssue.
type WatchersDestroyIssueParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// JournalsUpdatePatchJSONBody defines parameters for JournalsUpdatePatch.
type JournalsUpdatePatchJSONBody struct {
	// Journal Represents a single journal entry.
	Journal *struct {
		// Notes The notes for the journal entry.
		Notes *string `json:"notes,omitempty"`

		// PrivateNotes Whether the notes is private.
		PrivateNotes *bool `json:"private_notes,omitempty"`
	} `json:"journal,omitempty"`
}

// JournalsUpdatePatchParams defines parameters for JournalsUpdatePatch.
type JournalsUpdatePatchParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// JournalsUpdatePutJSONBody defines parameters for JournalsUpdatePut.
type JournalsUpdatePutJSONBody struct {
	// Journal Represents a single journal entry.
	Journal *struct {
		// Notes The notes for the journal entry.
		Notes *string `json:"notes,omitempty"`

		// PrivateNotes Whether the notes is private.
		PrivateNotes *bool `json:"private_notes,omitempty"`
	} `json:"journal,omitempty"`
}

// JournalsUpdatePutParams defines parameters for JournalsUpdatePut.
type JournalsUpdatePutParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// MembersDestroyParams defines parameters for MembersDestroy.
type MembersDestroyParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// MembersShowParams defines parameters for MembersShow.
type MembersShowParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// MembersUpdatePatchJSONBody defines parameters for MembersUpdatePatch.
type MembersUpdatePatchJSONBody struct {
	// Membership A single membership.
	Membership *struct {
		RoleIds *[]int `json:"role_ids,omitempty"`

		// UserId The ID of the user.
		UserId  *int   `json:"user_id,omitempty"`
		UserIds *[]int `json:"user_ids,omitempty"`
	} `json:"membership,omitempty"`
}

// MembersUpdatePatchParams defines parameters for MembersUpdatePatch.
type MembersUpdatePatchParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// MembersUpdatePutJSONBody defines parameters for MembersUpdatePut.
type MembersUpdatePutJSONBody struct {
	// Membership A single membership.
	Membership *struct {
		RoleIds *[]int `json:"role_ids,omitempty"`

		// UserId The ID of the user.
		UserId  *int   `json:"user_id,omitempty"`
		UserIds *[]int `json:"user_ids,omitempty"`
	} `json:"membership,omitempty"`
}

// MembersUpdatePutParams defines parameters for MembersUpdatePut.
type MembersUpdatePutParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// MyAccountParams defines parameters for MyAccount.
type MyAccountParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// MyAccountPutJSONBody defines parameters for MyAccountPut.
type MyAccountPutJSONBody struct {
	// Pref The preferences of the user.
	Pref *struct {
		// AutoWatchOn The auto watch setting for the user. Possible values are:
		// - `issue_created`
		// - `issue_contributed_to`
		AutoWatchOn *[]string `json:"auto_watch_on,omitempty"`

		// CommentsSorting The sorting order of comments. Possible values are `asc` and `desc`.
		CommentsSorting *string `json:"comments_sorting,omitempty"`

		// DefaultIssueQuery The ID of the default issue query for the user.
		DefaultIssueQuery *int `json:"default_issue_query,omitempty"`

		// DefaultProjectQuery The ID of the default project query for the user.
		DefaultProjectQuery *int `json:"default_project_query,omitempty"`

		// HideMail Whether the user's email should be hidden.
		HideMail *bool `json:"hide_mail,omitempty"`

		// HistoryDefaultTab The default tab for the user's history. Possible values are:
		// - `notes`
		// - `history`
		// - `properties`
		// - `time_entries`
		// - `changesets`
		// - `last_tab_visited`
		HistoryDefaultTab *string `json:"history_default_tab,omitempty"`

		// NoSelfNotified Whether the user should not be notified of their own actions.
		NoSelfNotified *bool `json:"no_self_notified,omitempty"`

		// NotifyAboutHighPriorityIssues Whether the user should be notified about high priority issues.
		NotifyAboutHighPriorityIssues *bool `json:"notify_about_high_priority_issues,omitempty"`

		// RecentlyUsedProjects The number of recently used projects to display.
		RecentlyUsedProjects *int `json:"recently_used_projects,omitempty"`

		// TextareaFont The font used in text areas. Possible values are:
		// - `monospace`
		// - `proportional`
		TextareaFont *string `json:"textarea_font,omitempty"`

		// TimeZone The time zone of the user.
		TimeZone *string `json:"time_zone,omitempty"`

		// ToolbarLanguageOptions The language options for the toolbar.
		ToolbarLanguageOptions *string `json:"toolbar_language_options,omitempty"`

		// WarnOnLeavingUnsaved Whether to warn the user when leaving a page with unsaved changes. Possible values are:
		// - `0`: Disable
		// - `1`: Enable
		WarnOnLeavingUnsaved *string `json:"warn_on_leaving_unsaved,omitempty"`
	} `json:"pref,omitempty"`

	// User A single user.
	User *struct {
		// Admin The administrative of the user.
		Admin *bool `json:"admin,omitempty"`

		// AuthSourceId The auth source id of the user.
		AuthSourceId *int `json:"auth_source_id,omitempty"`

		// CustomFieldValues The values of the custom fields.
		CustomFieldValues *map[string]interface{} `json:"custom_field_values,omitempty"`
		CustomFields      *[]struct {
			// Id The ID of the custom field.
			Id *int `json:"id,omitempty"`

			// Multiple Whether the custom field can have multiple values.
			Multiple *bool `json:"multiple,omitempty"`

			// Name The name of the custom field.
			Name  *string      `json:"name,omitempty"`
			Value *interface{} `json:"value,omitempty"`
		} `json:"custom_fields,omitempty"`

		// Firstname The firstname of the user.
		Firstname *string `json:"firstname,omitempty"`

		// GeneratePassword The generate password of the user.
		GeneratePassword *bool `json:"generate_password,omitempty"`

		// GroupIds The group id of the user.
		GroupIds *[]int `json:"group_ids,omitempty"`

		// Language The language of the user.
		Language *string `json:"language,omitempty"`

		// Lastname The lastname of the user.
		Lastname *string `json:"lastname,omitempty"`

		// Login The login of the user.
		Login *string `json:"login,omitempty"`

		// Mail The mail address of the user.
		Mail *string `json:"mail,omitempty"`

		// MailNotification The mail notification of the user. Possible values are:
		// - `all`: all events
		// - `selected`: only selected events
		// - `only_my_events`: only events related to the user
		// - `only_assigned`: only events assigned to the user
		// - `only_owner`: only events owned by the user
		// - `none`: no events
		MailNotification *string `json:"mail_notification,omitempty"`

		// MustChangePasswd The must change passwd of the user.
		MustChangePasswd *bool `json:"must_change_passwd,omitempty"`

		// NotifiedProjectIds The notified project ID or identifier of the user.
		NotifiedProjectIds *[]string `json:"notified_project_ids,omitempty"`

		// Password The password of the user.
		Password *string `json:"password,omitempty"`

		// Status The status of the user. Possible values are:
		// - `0`: anonymous
		// - `1`: active
		// - `2`: registered
		// - `3`: locked
		Status *int `json:"status,omitempty"`
	} `json:"user,omitempty"`
}

// MyAccountPutParams defines parameters for MyAccountPut.
type MyAccountPutParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// NewsIndexParams defines parameters for NewsIndex.
type NewsIndexParams struct {
	// Pagination Pagination parameters to control the number of items returned in the response.
	// If not specified, it defaults to 25 items per page.
	Pagination *struct {
		// Limit The number of items to be present in the response.
		// If not specified, it defaults to 25.
		Limit *int `json:"limit,omitempty"`

		// Nometa If set to 1, the response will not include pagination information.
		Nometa *int `json:"nometa,omitempty"`

		// Offset The offset of the first object to retrieve
		// If not specified, it defaults to 0.
		Offset *int `json:"offset,omitempty"`
	} `form:"pagination,omitempty" json:"pagination,omitempty"`

	// XRedmineNometa If set to 1, the response will not include metadata information.
	XRedmineNometa *int `json:"X-Redmine-Nometa,omitempty"`

	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// NewsCreateJSONBody defines parameters for NewsCreate.
type NewsCreateJSONBody struct {
	// News A single news.
	News *struct {
		// Description The description of the news.
		Description *string `json:"description,omitempty"`

		// Summary The summary of the news.
		Summary *string `json:"summary,omitempty"`

		// Title The title of the news.
		Title *string `json:"title,omitempty"`
	} `json:"news,omitempty"`

	// ProjectId The ID or identifier of the project.
	ProjectId *string `json:"project_id,omitempty"`
}

// NewsCreateParams defines parameters for NewsCreate.
type NewsCreateParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// NewsDestroyParams defines parameters for NewsDestroy.
type NewsDestroyParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// NewsShowParams defines parameters for NewsShow.
type NewsShowParams struct {
	// Include fetch associated data (optional).
	// Possible values: `attachments`, `comments`.
	Include *[]string `form:"include,omitempty" json:"include,omitempty"`

	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// NewsUpdatePatchJSONBody defines parameters for NewsUpdatePatch.
type NewsUpdatePatchJSONBody struct {
	// News A single news.
	News *struct {
		// Description The description of the news.
		Description *string `json:"description,omitempty"`

		// Summary The summary of the news.
		Summary *string `json:"summary,omitempty"`

		// Title The title of the news.
		Title *string `json:"title,omitempty"`
	} `json:"news,omitempty"`
}

// NewsUpdatePatchParams defines parameters for NewsUpdatePatch.
type NewsUpdatePatchParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// NewsUpdatePutJSONBody defines parameters for NewsUpdatePut.
type NewsUpdatePutJSONBody struct {
	// News A single news.
	News *struct {
		// Description The description of the news.
		Description *string `json:"description,omitempty"`

		// Summary The summary of the news.
		Summary *string `json:"summary,omitempty"`

		// Title The title of the news.
		Title *string `json:"title,omitempty"`
	} `json:"news,omitempty"`
}

// NewsUpdatePutParams defines parameters for NewsUpdatePut.
type NewsUpdatePutParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// ProjectsIndexCsvParams_Query defines parameters for ProjectsIndexCsv.
type ProjectsIndexCsvParams_Query struct {
	// CreatedOn The expression of created_on of the project.
	// The expression format is "[operator]\<value>".
	// examples:
	// - last week : `lw`
	// - before "2025/7/12": `<=2025-07-12`
	CreatedOn *string `json:"created_on,omitempty"`

	// Description The expression of description of the project.
	// The expression format is "\<operator>\<value>".
	// examples:
	// - contains "test": `~test`
	// - not contains "test": `!~test`
	Description *string `json:"description,omitempty"`

	// Id The expression of identifier of the project.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	Id *string `json:"id,omitempty"`

	// IsPublic The expression of visibility of the project.
	// The expression format is "\<operator>\<values>". Values should be separated by a pipe "|".
	// Possible values are:
	// - `0`: private
	// - `1`: public
	//
	// examples:
	// - public only: `1`
	// - public or private: `0|1`
	IsPublic *string `json:"is_public,omitempty"`

	// Name The expression of name of the project.
	// The expression format is "\<operator>\<value>".
	// examples:
	// - contains "test": `~test`
	// - not contains "test": `!~test`
	Name *string `json:"name,omitempty"`

	// ParentId The expression of parent project id of the project.
	// The expression format is "\<operator>\<values>". Values should be separated by a pipe "|".
	ParentId *string `json:"parent_id,omitempty"`

	// Status The expression of status of the project.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	// Possible values are:
	// - `1`: active
	// - `5`: closed
	//
	// examples:
	// - active or closed: `1|5`
	// - not closed: `!5`
	Status *string `json:"status,omitempty"`

	// UpdatedOn The expression of updated_on of the project.
	// The expression format is "[operator]\<value>".
	// examples:
	// - last week : `lw`
	// - before "2025/7/12": `<=2025-07-12`
	UpdatedOn            *string           `json:"updated_on,omitempty"`
	AdditionalProperties map[string]string `json:"-"`
}

// ProjectsIndexCsvParams defines parameters for ProjectsIndexCsv.
type ProjectsIndexCsvParams struct {
	// Pagination Pagination parameters to control the number of items returned in the response.
	// If not specified, it defaults to 25 items per page.
	Pagination *struct {
		// Limit The number of items to be present in the response.
		// If not specified, it defaults to 25.
		Limit *int `json:"limit,omitempty"`

		// Nometa If set to 1, the response will not include pagination information.
		Nometa *int `json:"nometa,omitempty"`

		// Offset The offset of the first object to retrieve
		// If not specified, it defaults to 0.
		Offset *int `json:"offset,omitempty"`
	} `form:"pagination,omitempty" json:"pagination,omitempty"`
	Query *ProjectsIndexCsvParams_Query `form:"query,omitempty" json:"query,omitempty"`

	// Include fetch associated data (optional).
	// Possible values: `trackers`, `issue_categories`, `enabled_modules`, `time_entry_activities`, `issue_custom_fields`.
	Include *[]string `form:"include,omitempty" json:"include,omitempty"`

	// XRedmineNometa If set to 1, the response will not include metadata information.
	XRedmineNometa *int `json:"X-Redmine-Nometa,omitempty"`

	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// ProjectsIndexParams_Query defines parameters for ProjectsIndex.
type ProjectsIndexParams_Query struct {
	// CreatedOn The expression of created_on of the project.
	// The expression format is "[operator]\<value>".
	// examples:
	// - last week : `lw`
	// - before "2025/7/12": `<=2025-07-12`
	CreatedOn *string `json:"created_on,omitempty"`

	// Description The expression of description of the project.
	// The expression format is "\<operator>\<value>".
	// examples:
	// - contains "test": `~test`
	// - not contains "test": `!~test`
	Description *string `json:"description,omitempty"`

	// Id The expression of identifier of the project.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	Id *string `json:"id,omitempty"`

	// IsPublic The expression of visibility of the project.
	// The expression format is "\<operator>\<values>". Values should be separated by a pipe "|".
	// Possible values are:
	// - `0`: private
	// - `1`: public
	//
	// examples:
	// - public only: `1`
	// - public or private: `0|1`
	IsPublic *string `json:"is_public,omitempty"`

	// Name The expression of name of the project.
	// The expression format is "\<operator>\<value>".
	// examples:
	// - contains "test": `~test`
	// - not contains "test": `!~test`
	Name *string `json:"name,omitempty"`

	// ParentId The expression of parent project id of the project.
	// The expression format is "\<operator>\<values>". Values should be separated by a pipe "|".
	ParentId *string `json:"parent_id,omitempty"`

	// Status The expression of status of the project.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	// Possible values are:
	// - `1`: active
	// - `5`: closed
	//
	// examples:
	// - active or closed: `1|5`
	// - not closed: `!5`
	Status *string `json:"status,omitempty"`

	// UpdatedOn The expression of updated_on of the project.
	// The expression format is "[operator]\<value>".
	// examples:
	// - last week : `lw`
	// - before "2025/7/12": `<=2025-07-12`
	UpdatedOn            *string           `json:"updated_on,omitempty"`
	AdditionalProperties map[string]string `json:"-"`
}

// ProjectsIndexParams defines parameters for ProjectsIndex.
type ProjectsIndexParams struct {
	// Pagination Pagination parameters to control the number of items returned in the response.
	// If not specified, it defaults to 25 items per page.
	Pagination *struct {
		// Limit The number of items to be present in the response.
		// If not specified, it defaults to 25.
		Limit *int `json:"limit,omitempty"`

		// Nometa If set to 1, the response will not include pagination information.
		Nometa *int `json:"nometa,omitempty"`

		// Offset The offset of the first object to retrieve
		// If not specified, it defaults to 0.
		Offset *int `json:"offset,omitempty"`
	} `form:"pagination,omitempty" json:"pagination,omitempty"`
	Query *ProjectsIndexParams_Query `form:"query,omitempty" json:"query,omitempty"`

	// Include fetch associated data (optional).
	// Possible values: `trackers`, `issue_categories`, `enabled_modules`, `time_entry_activities`, `issue_custom_fields`.
	Include *[]string `form:"include,omitempty" json:"include,omitempty"`

	// XRedmineNometa If set to 1, the response will not include metadata information.
	XRedmineNometa *int `json:"X-Redmine-Nometa,omitempty"`

	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// ProjectsCreateJSONBody defines parameters for ProjectsCreate.
type ProjectsCreateJSONBody struct {
	// Project A single project.
	Project *struct {
		// CustomFieldValues The values of the custom fields.
		CustomFieldValues *map[string]interface{} `json:"custom_field_values,omitempty"`
		CustomFields      *[]struct {
			// Id The ID of the custom field.
			Id *int `json:"id,omitempty"`

			// Multiple Whether the custom field can have multiple values.
			Multiple *bool `json:"multiple,omitempty"`

			// Name The name of the custom field.
			Name  *string      `json:"name,omitempty"`
			Value *interface{} `json:"value,omitempty"`
		} `json:"custom_fields,omitempty"`

		// DefaultAssignedToId The ID of the default assignee of the project.
		DefaultAssignedToId *int `json:"default_assigned_to_id,omitempty"`

		// DefaultIssueQueryId The ID of the default issue query of the project
		DefaultIssueQueryId *int `json:"default_issue_query_id,omitempty"`

		// DefaultVersionId The ID of the default version of the project.
		DefaultVersionId *int `json:"default_version_id,omitempty"`

		// Description The description of the project.
		Description *string `json:"description,omitempty"`

		// EnabledModuleNames The names of the enabled modules for the project.
		EnabledModuleNames *[]string `json:"enabled_module_names,omitempty"`

		// Homepage The homepage URL of the project.
		Homepage *string `json:"homepage,omitempty"`

		// Identifier The identifier of the project.
		Identifier *string `json:"identifier,omitempty"`

		// InheritMembers Whether the project inherits members from its parent project. `true` if it does, `false` if it does not.
		InheritMembers *bool `json:"inherit_members,omitempty"`

		// IsPublic The visibility of the project. `true` if the project is public, `false` if it is private.
		IsPublic *bool `json:"is_public,omitempty"`

		// IssueCustomFieldIds The IDs of the issue custom fields associated with the project.
		IssueCustomFieldIds *[]int `json:"issue_custom_field_ids,omitempty"`

		// Name The name of the project.
		Name *string `json:"name,omitempty"`

		// ParentId The ID of the parent project.
		ParentId *int `json:"parent_id,omitempty"`

		// TrackerIds The IDs of the trackers associated with the project.
		TrackerIds *[]int `json:"tracker_ids,omitempty"`
	} `json:"project,omitempty"`
}

// ProjectsCreateParams defines parameters for ProjectsCreate.
type ProjectsCreateParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// ProjectsDestroyParams defines parameters for ProjectsDestroy.
type ProjectsDestroyParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// ProjectsShowParams defines parameters for ProjectsShow.
type ProjectsShowParams struct {
	// Include fetch associated data (optional).
	// Possible values: `trackers`, `issue_categories`, `enabled_modules`, `time_entry_activities`, `issue_custom_fields`.
	Include *[]string `form:"include,omitempty" json:"include,omitempty"`

	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// ProjectsUpdatePatchJSONBody defines parameters for ProjectsUpdatePatch.
type ProjectsUpdatePatchJSONBody struct {
	// Project A single project.
	Project *struct {
		// CustomFieldValues The values of the custom fields.
		CustomFieldValues *map[string]interface{} `json:"custom_field_values,omitempty"`
		CustomFields      *[]struct {
			// Id The ID of the custom field.
			Id *int `json:"id,omitempty"`

			// Multiple Whether the custom field can have multiple values.
			Multiple *bool `json:"multiple,omitempty"`

			// Name The name of the custom field.
			Name  *string      `json:"name,omitempty"`
			Value *interface{} `json:"value,omitempty"`
		} `json:"custom_fields,omitempty"`

		// DefaultAssignedToId The ID of the default assignee of the project.
		DefaultAssignedToId *int `json:"default_assigned_to_id,omitempty"`

		// DefaultIssueQueryId The ID of the default issue query of the project
		DefaultIssueQueryId *int `json:"default_issue_query_id,omitempty"`

		// DefaultVersionId The ID of the default version of the project.
		DefaultVersionId *int `json:"default_version_id,omitempty"`

		// Description The description of the project.
		Description *string `json:"description,omitempty"`

		// EnabledModuleNames The names of the enabled modules for the project.
		EnabledModuleNames *[]string `json:"enabled_module_names,omitempty"`

		// Homepage The homepage URL of the project.
		Homepage *string `json:"homepage,omitempty"`

		// Identifier The identifier of the project.
		Identifier *string `json:"identifier,omitempty"`

		// InheritMembers Whether the project inherits members from its parent project. `true` if it does, `false` if it does not.
		InheritMembers *bool `json:"inherit_members,omitempty"`

		// IsPublic The visibility of the project. `true` if the project is public, `false` if it is private.
		IsPublic *bool `json:"is_public,omitempty"`

		// IssueCustomFieldIds The IDs of the issue custom fields associated with the project.
		IssueCustomFieldIds *[]int `json:"issue_custom_field_ids,omitempty"`

		// Name The name of the project.
		Name *string `json:"name,omitempty"`

		// ParentId The ID of the parent project.
		ParentId *int `json:"parent_id,omitempty"`

		// TrackerIds The IDs of the trackers associated with the project.
		TrackerIds *[]int `json:"tracker_ids,omitempty"`
	} `json:"project,omitempty"`
}

// ProjectsUpdatePatchParams defines parameters for ProjectsUpdatePatch.
type ProjectsUpdatePatchParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// ProjectsUpdatePutJSONBody defines parameters for ProjectsUpdatePut.
type ProjectsUpdatePutJSONBody struct {
	// Project A single project.
	Project *struct {
		// CustomFieldValues The values of the custom fields.
		CustomFieldValues *map[string]interface{} `json:"custom_field_values,omitempty"`
		CustomFields      *[]struct {
			// Id The ID of the custom field.
			Id *int `json:"id,omitempty"`

			// Multiple Whether the custom field can have multiple values.
			Multiple *bool `json:"multiple,omitempty"`

			// Name The name of the custom field.
			Name  *string      `json:"name,omitempty"`
			Value *interface{} `json:"value,omitempty"`
		} `json:"custom_fields,omitempty"`

		// DefaultAssignedToId The ID of the default assignee of the project.
		DefaultAssignedToId *int `json:"default_assigned_to_id,omitempty"`

		// DefaultIssueQueryId The ID of the default issue query of the project
		DefaultIssueQueryId *int `json:"default_issue_query_id,omitempty"`

		// DefaultVersionId The ID of the default version of the project.
		DefaultVersionId *int `json:"default_version_id,omitempty"`

		// Description The description of the project.
		Description *string `json:"description,omitempty"`

		// EnabledModuleNames The names of the enabled modules for the project.
		EnabledModuleNames *[]string `json:"enabled_module_names,omitempty"`

		// Homepage The homepage URL of the project.
		Homepage *string `json:"homepage,omitempty"`

		// Identifier The identifier of the project.
		Identifier *string `json:"identifier,omitempty"`

		// InheritMembers Whether the project inherits members from its parent project. `true` if it does, `false` if it does not.
		InheritMembers *bool `json:"inherit_members,omitempty"`

		// IsPublic The visibility of the project. `true` if the project is public, `false` if it is private.
		IsPublic *bool `json:"is_public,omitempty"`

		// IssueCustomFieldIds The IDs of the issue custom fields associated with the project.
		IssueCustomFieldIds *[]int `json:"issue_custom_field_ids,omitempty"`

		// Name The name of the project.
		Name *string `json:"name,omitempty"`

		// ParentId The ID of the parent project.
		ParentId *int `json:"parent_id,omitempty"`

		// TrackerIds The IDs of the trackers associated with the project.
		TrackerIds *[]int `json:"tracker_ids,omitempty"`
	} `json:"project,omitempty"`
}

// ProjectsUpdatePutParams defines parameters for ProjectsUpdatePut.
type ProjectsUpdatePutParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// ProjectsArchivePostParams defines parameters for ProjectsArchivePost.
type ProjectsArchivePostParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// ProjectsArchivePutParams defines parameters for ProjectsArchivePut.
type ProjectsArchivePutParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// RepositoriesAddRelatedIssueJSONBody defines parameters for RepositoriesAddRelatedIssue.
type RepositoriesAddRelatedIssueJSONBody struct {
	// IssueId The ID of the issue.
	IssueId *int `json:"issue_id,omitempty"`
}

// RepositoriesAddRelatedIssueParams defines parameters for RepositoriesAddRelatedIssue.
type RepositoriesAddRelatedIssueParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// RepositoriesRemoveRelatedIssueParams defines parameters for RepositoriesRemoveRelatedIssue.
type RepositoriesRemoveRelatedIssueParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// ProjectsUnarchivePostParams defines parameters for ProjectsUnarchivePost.
type ProjectsUnarchivePostParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// ProjectsUnarchivePutParams defines parameters for ProjectsUnarchivePut.
type ProjectsUnarchivePutParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// FilesIndexParams defines parameters for FilesIndex.
type FilesIndexParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// FilesCreateJSONBody defines parameters for FilesCreate.
type FilesCreateJSONBody struct {
	// File Represents a new file to be created.
	File *struct {
		// Description The description of the file.
		Description *string `json:"description,omitempty"`

		// Filename The name of the file.
		Filename *string `json:"filename,omitempty"`

		// Token The upload token for the file.
		Token *string `json:"token,omitempty"`

		// VersionId The ID of the version associated with the file.
		VersionId *int `json:"version_id,omitempty"`
	} `json:"file,omitempty"`
}

// FilesCreateParams defines parameters for FilesCreate.
type FilesCreateParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// IssueCategoriesIndexParams defines parameters for IssueCategoriesIndex.
type IssueCategoriesIndexParams struct {
	// Nometa If set to 1, the response will not include metadata information.
	Nometa *int `form:"nometa,omitempty" json:"nometa,omitempty"`

	// XRedmineNometa If set to 1, the response will not include metadata information.
	XRedmineNometa *int `json:"X-Redmine-Nometa,omitempty"`

	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// IssueCategoriesCreateJSONBody defines parameters for IssueCategoriesCreate.
type IssueCategoriesCreateJSONBody struct {
	// IssueCategory A single issue_category.
	IssueCategory *struct {
		// AssignedToId The ID of the assinged to.
		AssignedToId *int `json:"assigned_to_id,omitempty"`

		// Name The name of the issue category.
		Name *string `json:"name,omitempty"`
	} `json:"issue_category,omitempty"`
}

// IssueCategoriesCreateParams defines parameters for IssueCategoriesCreate.
type IssueCategoriesCreateParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// IssuesIndexProjectCsvParams_Query defines parameters for IssuesIndexProjectCsv.
type IssuesIndexProjectCsvParams_Query struct {
	// AnySearchable The expression of any searchable of the issue.
	// The expression format is "[operator]\<value>".
	AnySearchable *string `json:"any_searchable,omitempty"`

	// AssignedToId The expression of assigned to id of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	AssignedToId *string `json:"assigned_to_id,omitempty"`

	// AssignedToRole The expression of assigned to role of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	AssignedToRole *string `json:"assigned_to_role,omitempty"`

	// Attachment The expression of attachment of the issue.
	// The expression format is "[operator]\<value>".
	Attachment *string `json:"attachment,omitempty"`

	// AttachmentDescription The expression of attachment description of the issue.
	// The expression format is "[operator]\<value>".
	AttachmentDescription *string `json:"attachment_description,omitempty"`

	// AuthorGroup The expression of author group of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	AuthorGroup *string `json:"author.group,omitempty"`

	// AuthorRole The expression of author role of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	AuthorRole *string `json:"author.role,omitempty"`

	// AuthorId The expression of author id of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	AuthorId *string `json:"author_id,omitempty"`

	// CategoryId The expression of category id of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	CategoryId *string `json:"category_id,omitempty"`

	// ChildId The expression of child id of the issue.
	// The expression format is "[operator]\<value>".
	ChildId *string `json:"child_id,omitempty"`

	// ClosedOn The expression of closed_on of the issue.
	// The expression format is "[operator]\<value>".
	// examples:
	// - last week : `lw`
	// - before "2025/7/12": `<=2025-07-12`
	ClosedOn *string `json:"closed_on,omitempty"`

	// CreatedOn The expression of created_on of the issue.
	// The expression format is "[operator]\<value>".
	// examples:
	// - last week : `lw`
	// - before "2025/7/12": `<=2025-07-12`
	CreatedOn *string `json:"created_on,omitempty"`

	// Description The expression of description of the issue.
	// The expression format is "\<operator>\<value>".
	Description *string `json:"description,omitempty"`

	// DoneRatio The expression of done ratio of the issue.
	// The expression format is "[operator]\<value>".
	DoneRatio *string `json:"done_ratio,omitempty"`

	// DueDate The expression of due date of the issue.
	// The expression format is "[operator]\<value>".
	// examples:
	// - last week : `lw`
	// - before "2025/7/12": `<=2025-07-12`
	DueDate *string `json:"due_date,omitempty"`

	// EstimatedHours The expression of estimated hours of the issue.
	// The expression format is "[operator]\<value>".
	EstimatedHours *string `json:"estimated_hours,omitempty"`

	// FixedVersionDueDate The expression of fixed version due date of the issue.
	// The expression format is "[operator]\<value>".
	// examples:
	// - last week : `lw`
	// - before "2025/7/12": `<=2025-07-12`
	FixedVersionDueDate *string `json:"fixed_version.due_date,omitempty"`

	// FixedVersionStatus The expression of fixed version status of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	FixedVersionStatus *string `json:"fixed_version.status,omitempty"`

	// FixedVersionId The expression of fixed version id of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	FixedVersionId *string `json:"fixed_version_id,omitempty"`

	// IsPrivate The expression of private id of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	IsPrivate *string `json:"is_private,omitempty"`

	// IssueId The expression of issue id of the issue.
	// The expression format is "[operator]\<value>".
	IssueId *string `json:"issue_id,omitempty"`

	// LastUpdatedBy The expression of last updated by of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	LastUpdatedBy *string `json:"last_updated_by,omitempty"`

	// MemberOfGroup The expression of member of group of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	MemberOfGroup *string `json:"member_of_group,omitempty"`

	// Notes The expression of notes of the issue.
	// The expression format is "\<operator>\<value>".
	Notes *string `json:"notes,omitempty"`

	// ParentId The expression of parent id of the issue.
	// The expression format is "[operator]\<value>".
	ParentId *string `json:"parent_id,omitempty"`

	// PriorityId The expression of priority id of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	PriorityId *string `json:"priority_id,omitempty"`

	// ProjectStatus The expression of project status of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	ProjectStatus *string `json:"project.status,omitempty"`

	// ProjectId The expression of project ID or identifier of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	ProjectId *string `json:"project_id,omitempty"`

	// RelationType The expression of relation type of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	RelationType *string `json:"relation_type,omitempty"`

	// SpentTime The expression of spent time of the issue.
	// The expression format is "[operator]\<value>".
	SpentTime *string `json:"spent_time,omitempty"`

	// StartDate The expression of start date of the issue.
	// The expression format is "[operator]\<value>".
	// examples:
	// - last week : `lw`
	// - before "2025/7/12": `<=2025-07-12`
	StartDate *string `json:"start_date,omitempty"`

	// StatusId The expression of status id of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	StatusId *string `json:"status_id,omitempty"`

	// Subject The expression of subject of the issue.
	// The expression format is "\<operator>\<value>".
	Subject *string `json:"subject,omitempty"`

	// SubprojectId The expression of sub project ID or identifier of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	SubprojectId *string `json:"subproject_id,omitempty"`

	// TrackerId The expression of tracker id of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	TrackerId *string `json:"tracker_id,omitempty"`

	// UpdatedBy The expression of updated by of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	UpdatedBy *string `json:"updated_by,omitempty"`

	// UpdatedOn The expression of updated_on of the issue.
	// The expression format is "[operator]\<value>".
	// examples:
	// - last week : `lw`
	// - before "2025/7/12": `<=2025-07-12`
	UpdatedOn *string `json:"updated_on,omitempty"`

	// WatcherId The expression of watcher id of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	WatcherId            *string           `json:"watcher_id,omitempty"`
	AdditionalProperties map[string]string `json:"-"`
}

// IssuesIndexProjectCsvParams defines parameters for IssuesIndexProjectCsv.
type IssuesIndexProjectCsvParams struct {
	// Pagination Pagination parameters to control the number of items returned in the response.
	// If not specified, it defaults to 25 items per page.
	Pagination *struct {
		// Limit The number of items to be present in the response.
		// If not specified, it defaults to 25.
		Limit *int `json:"limit,omitempty"`

		// Nometa If set to 1, the response will not include pagination information.
		Nometa *int `json:"nometa,omitempty"`

		// Offset The offset of the first object to retrieve
		// If not specified, it defaults to 0.
		Offset *int `json:"offset,omitempty"`
	} `form:"pagination,omitempty" json:"pagination,omitempty"`
	Query *IssuesIndexProjectCsvParams_Query `form:"query,omitempty" json:"query,omitempty"`

	// Include fetch associated data (optional).
	// Possible values: `allowed_statuses`, `attachments`, `changesets`, `children`, `journals`, `relations`, `watchers`.
	Include *[]string `form:"include,omitempty" json:"include,omitempty"`

	// XRedmineNometa If set to 1, the response will not include metadata information.
	XRedmineNometa *int `json:"X-Redmine-Nometa,omitempty"`

	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// IssuesIndexProjectParams_Query defines parameters for IssuesIndexProject.
type IssuesIndexProjectParams_Query struct {
	// AnySearchable The expression of any searchable of the issue.
	// The expression format is "[operator]\<value>".
	AnySearchable *string `json:"any_searchable,omitempty"`

	// AssignedToId The expression of assigned to id of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	AssignedToId *string `json:"assigned_to_id,omitempty"`

	// AssignedToRole The expression of assigned to role of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	AssignedToRole *string `json:"assigned_to_role,omitempty"`

	// Attachment The expression of attachment of the issue.
	// The expression format is "[operator]\<value>".
	Attachment *string `json:"attachment,omitempty"`

	// AttachmentDescription The expression of attachment description of the issue.
	// The expression format is "[operator]\<value>".
	AttachmentDescription *string `json:"attachment_description,omitempty"`

	// AuthorGroup The expression of author group of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	AuthorGroup *string `json:"author.group,omitempty"`

	// AuthorRole The expression of author role of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	AuthorRole *string `json:"author.role,omitempty"`

	// AuthorId The expression of author id of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	AuthorId *string `json:"author_id,omitempty"`

	// CategoryId The expression of category id of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	CategoryId *string `json:"category_id,omitempty"`

	// ChildId The expression of child id of the issue.
	// The expression format is "[operator]\<value>".
	ChildId *string `json:"child_id,omitempty"`

	// ClosedOn The expression of closed_on of the issue.
	// The expression format is "[operator]\<value>".
	// examples:
	// - last week : `lw`
	// - before "2025/7/12": `<=2025-07-12`
	ClosedOn *string `json:"closed_on,omitempty"`

	// CreatedOn The expression of created_on of the issue.
	// The expression format is "[operator]\<value>".
	// examples:
	// - last week : `lw`
	// - before "2025/7/12": `<=2025-07-12`
	CreatedOn *string `json:"created_on,omitempty"`

	// Description The expression of description of the issue.
	// The expression format is "\<operator>\<value>".
	Description *string `json:"description,omitempty"`

	// DoneRatio The expression of done ratio of the issue.
	// The expression format is "[operator]\<value>".
	DoneRatio *string `json:"done_ratio,omitempty"`

	// DueDate The expression of due date of the issue.
	// The expression format is "[operator]\<value>".
	// examples:
	// - last week : `lw`
	// - before "2025/7/12": `<=2025-07-12`
	DueDate *string `json:"due_date,omitempty"`

	// EstimatedHours The expression of estimated hours of the issue.
	// The expression format is "[operator]\<value>".
	EstimatedHours *string `json:"estimated_hours,omitempty"`

	// FixedVersionDueDate The expression of fixed version due date of the issue.
	// The expression format is "[operator]\<value>".
	// examples:
	// - last week : `lw`
	// - before "2025/7/12": `<=2025-07-12`
	FixedVersionDueDate *string `json:"fixed_version.due_date,omitempty"`

	// FixedVersionStatus The expression of fixed version status of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	FixedVersionStatus *string `json:"fixed_version.status,omitempty"`

	// FixedVersionId The expression of fixed version id of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	FixedVersionId *string `json:"fixed_version_id,omitempty"`

	// IsPrivate The expression of private id of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	IsPrivate *string `json:"is_private,omitempty"`

	// IssueId The expression of issue id of the issue.
	// The expression format is "[operator]\<value>".
	IssueId *string `json:"issue_id,omitempty"`

	// LastUpdatedBy The expression of last updated by of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	LastUpdatedBy *string `json:"last_updated_by,omitempty"`

	// MemberOfGroup The expression of member of group of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	MemberOfGroup *string `json:"member_of_group,omitempty"`

	// Notes The expression of notes of the issue.
	// The expression format is "\<operator>\<value>".
	Notes *string `json:"notes,omitempty"`

	// ParentId The expression of parent id of the issue.
	// The expression format is "[operator]\<value>".
	ParentId *string `json:"parent_id,omitempty"`

	// PriorityId The expression of priority id of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	PriorityId *string `json:"priority_id,omitempty"`

	// ProjectStatus The expression of project status of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	ProjectStatus *string `json:"project.status,omitempty"`

	// ProjectId The expression of project ID or identifier of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	ProjectId *string `json:"project_id,omitempty"`

	// RelationType The expression of relation type of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	RelationType *string `json:"relation_type,omitempty"`

	// SpentTime The expression of spent time of the issue.
	// The expression format is "[operator]\<value>".
	SpentTime *string `json:"spent_time,omitempty"`

	// StartDate The expression of start date of the issue.
	// The expression format is "[operator]\<value>".
	// examples:
	// - last week : `lw`
	// - before "2025/7/12": `<=2025-07-12`
	StartDate *string `json:"start_date,omitempty"`

	// StatusId The expression of status id of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	StatusId *string `json:"status_id,omitempty"`

	// Subject The expression of subject of the issue.
	// The expression format is "\<operator>\<value>".
	Subject *string `json:"subject,omitempty"`

	// SubprojectId The expression of sub project ID or identifier of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	SubprojectId *string `json:"subproject_id,omitempty"`

	// TrackerId The expression of tracker id of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	TrackerId *string `json:"tracker_id,omitempty"`

	// UpdatedBy The expression of updated by of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	UpdatedBy *string `json:"updated_by,omitempty"`

	// UpdatedOn The expression of updated_on of the issue.
	// The expression format is "[operator]\<value>".
	// examples:
	// - last week : `lw`
	// - before "2025/7/12": `<=2025-07-12`
	UpdatedOn *string `json:"updated_on,omitempty"`

	// WatcherId The expression of watcher id of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	WatcherId            *string           `json:"watcher_id,omitempty"`
	AdditionalProperties map[string]string `json:"-"`
}

// IssuesIndexProjectParams defines parameters for IssuesIndexProject.
type IssuesIndexProjectParams struct {
	// Pagination Pagination parameters to control the number of items returned in the response.
	// If not specified, it defaults to 25 items per page.
	Pagination *struct {
		// Limit The number of items to be present in the response.
		// If not specified, it defaults to 25.
		Limit *int `json:"limit,omitempty"`

		// Nometa If set to 1, the response will not include pagination information.
		Nometa *int `json:"nometa,omitempty"`

		// Offset The offset of the first object to retrieve
		// If not specified, it defaults to 0.
		Offset *int `json:"offset,omitempty"`
	} `form:"pagination,omitempty" json:"pagination,omitempty"`
	Query *IssuesIndexProjectParams_Query `form:"query,omitempty" json:"query,omitempty"`

	// Include fetch associated data (optional).
	// Possible values: `allowed_statuses`, `attachments`, `changesets`, `children`, `journals`, `relations`, `watchers`.
	Include *[]string `form:"include,omitempty" json:"include,omitempty"`

	// XRedmineNometa If set to 1, the response will not include metadata information.
	XRedmineNometa *int `json:"X-Redmine-Nometa,omitempty"`

	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// IssuesCreateProjectJSONBody defines parameters for IssuesCreateProject.
type IssuesCreateProjectJSONBody struct {
	// Issue A single issue.
	Issue *struct {
		// AssignedToId The assigned to id id of the issue.
		AssignedToId *int `json:"assigned_to_id,omitempty"`

		// CategoryId The category id of the issue.
		CategoryId *int `json:"category_id,omitempty"`

		// CustomFieldValues The values of the custom fields.
		CustomFieldValues *map[string]interface{} `json:"custom_field_values,omitempty"`
		CustomFields      *[]struct {
			// Id The ID of the custom field.
			Id *int `json:"id,omitempty"`

			// Multiple Whether the custom field can have multiple values.
			Multiple *bool `json:"multiple,omitempty"`

			// Name The name of the custom field.
			Name  *string      `json:"name,omitempty"`
			Value *interface{} `json:"value,omitempty"`
		} `json:"custom_fields,omitempty"`
		DeletedAttachmentIds *[]int `json:"deleted_attachment_ids,omitempty"`

		// Description The description of the issue.
		Description *string `json:"description,omitempty"`

		// DoneRatio The done ratio of the issue.
		DoneRatio *int `json:"done_ratio,omitempty"`

		// DueDate The due date of the issue.
		DueDate *openapi_types.Date `json:"due_date,omitempty"`

		// EstimatedHours The estimated hours of the issue.
		EstimatedHours *float32 `json:"estimated_hours,omitempty"`

		// FixedVersionId The fixed version id of the issue.
		FixedVersionId *int `json:"fixed_version_id,omitempty"`

		// IsPrivate The private of the issue.
		IsPrivate *bool `json:"is_private,omitempty"`

		// Notes The notes of the issue.
		Notes *string `json:"notes,omitempty"`

		// ParentIssueId The parent ID of the issue.
		ParentIssueId *int `json:"parent_issue_id,omitempty"`

		// PriorityId The priority id of the issue.
		PriorityId *int `json:"priority_id,omitempty"`

		// PrivateNotes The private notes of the issue.
		PrivateNotes *bool `json:"private_notes,omitempty"`

		// ProjectId The project ID or identifier of the issue.
		ProjectId *string `json:"project_id,omitempty"`

		// StartDate The start date of the issue.
		StartDate *openapi_types.Date `json:"start_date,omitempty"`

		// StatusId The status id of the issue.
		StatusId *int `json:"status_id,omitempty"`

		// Subject The subject of the issue.
		Subject *string `json:"subject,omitempty"`

		// TrackerId The tracker id of the issue.
		TrackerId      *int   `json:"tracker_id,omitempty"`
		WatcherUserIds *[]int `json:"watcher_user_ids,omitempty"`
	} `json:"issue,omitempty"`
}

// IssuesCreateProjectParams defines parameters for IssuesCreateProject.
type IssuesCreateProjectParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// IssuesIndexProjectPdfParams_Query defines parameters for IssuesIndexProjectPdf.
type IssuesIndexProjectPdfParams_Query struct {
	// AnySearchable The expression of any searchable of the issue.
	// The expression format is "[operator]\<value>".
	AnySearchable *string `json:"any_searchable,omitempty"`

	// AssignedToId The expression of assigned to id of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	AssignedToId *string `json:"assigned_to_id,omitempty"`

	// AssignedToRole The expression of assigned to role of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	AssignedToRole *string `json:"assigned_to_role,omitempty"`

	// Attachment The expression of attachment of the issue.
	// The expression format is "[operator]\<value>".
	Attachment *string `json:"attachment,omitempty"`

	// AttachmentDescription The expression of attachment description of the issue.
	// The expression format is "[operator]\<value>".
	AttachmentDescription *string `json:"attachment_description,omitempty"`

	// AuthorGroup The expression of author group of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	AuthorGroup *string `json:"author.group,omitempty"`

	// AuthorRole The expression of author role of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	AuthorRole *string `json:"author.role,omitempty"`

	// AuthorId The expression of author id of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	AuthorId *string `json:"author_id,omitempty"`

	// CategoryId The expression of category id of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	CategoryId *string `json:"category_id,omitempty"`

	// ChildId The expression of child id of the issue.
	// The expression format is "[operator]\<value>".
	ChildId *string `json:"child_id,omitempty"`

	// ClosedOn The expression of closed_on of the issue.
	// The expression format is "[operator]\<value>".
	// examples:
	// - last week : `lw`
	// - before "2025/7/12": `<=2025-07-12`
	ClosedOn *string `json:"closed_on,omitempty"`

	// CreatedOn The expression of created_on of the issue.
	// The expression format is "[operator]\<value>".
	// examples:
	// - last week : `lw`
	// - before "2025/7/12": `<=2025-07-12`
	CreatedOn *string `json:"created_on,omitempty"`

	// Description The expression of description of the issue.
	// The expression format is "\<operator>\<value>".
	Description *string `json:"description,omitempty"`

	// DoneRatio The expression of done ratio of the issue.
	// The expression format is "[operator]\<value>".
	DoneRatio *string `json:"done_ratio,omitempty"`

	// DueDate The expression of due date of the issue.
	// The expression format is "[operator]\<value>".
	// examples:
	// - last week : `lw`
	// - before "2025/7/12": `<=2025-07-12`
	DueDate *string `json:"due_date,omitempty"`

	// EstimatedHours The expression of estimated hours of the issue.
	// The expression format is "[operator]\<value>".
	EstimatedHours *string `json:"estimated_hours,omitempty"`

	// FixedVersionDueDate The expression of fixed version due date of the issue.
	// The expression format is "[operator]\<value>".
	// examples:
	// - last week : `lw`
	// - before "2025/7/12": `<=2025-07-12`
	FixedVersionDueDate *string `json:"fixed_version.due_date,omitempty"`

	// FixedVersionStatus The expression of fixed version status of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	FixedVersionStatus *string `json:"fixed_version.status,omitempty"`

	// FixedVersionId The expression of fixed version id of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	FixedVersionId *string `json:"fixed_version_id,omitempty"`

	// IsPrivate The expression of private id of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	IsPrivate *string `json:"is_private,omitempty"`

	// IssueId The expression of issue id of the issue.
	// The expression format is "[operator]\<value>".
	IssueId *string `json:"issue_id,omitempty"`

	// LastUpdatedBy The expression of last updated by of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	LastUpdatedBy *string `json:"last_updated_by,omitempty"`

	// MemberOfGroup The expression of member of group of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	MemberOfGroup *string `json:"member_of_group,omitempty"`

	// Notes The expression of notes of the issue.
	// The expression format is "\<operator>\<value>".
	Notes *string `json:"notes,omitempty"`

	// ParentId The expression of parent id of the issue.
	// The expression format is "[operator]\<value>".
	ParentId *string `json:"parent_id,omitempty"`

	// PriorityId The expression of priority id of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	PriorityId *string `json:"priority_id,omitempty"`

	// ProjectStatus The expression of project status of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	ProjectStatus *string `json:"project.status,omitempty"`

	// ProjectId The expression of project ID or identifier of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	ProjectId *string `json:"project_id,omitempty"`

	// RelationType The expression of relation type of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	RelationType *string `json:"relation_type,omitempty"`

	// SpentTime The expression of spent time of the issue.
	// The expression format is "[operator]\<value>".
	SpentTime *string `json:"spent_time,omitempty"`

	// StartDate The expression of start date of the issue.
	// The expression format is "[operator]\<value>".
	// examples:
	// - last week : `lw`
	// - before "2025/7/12": `<=2025-07-12`
	StartDate *string `json:"start_date,omitempty"`

	// StatusId The expression of status id of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	StatusId *string `json:"status_id,omitempty"`

	// Subject The expression of subject of the issue.
	// The expression format is "\<operator>\<value>".
	Subject *string `json:"subject,omitempty"`

	// SubprojectId The expression of sub project ID or identifier of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	SubprojectId *string `json:"subproject_id,omitempty"`

	// TrackerId The expression of tracker id of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	TrackerId *string `json:"tracker_id,omitempty"`

	// UpdatedBy The expression of updated by of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	UpdatedBy *string `json:"updated_by,omitempty"`

	// UpdatedOn The expression of updated_on of the issue.
	// The expression format is "[operator]\<value>".
	// examples:
	// - last week : `lw`
	// - before "2025/7/12": `<=2025-07-12`
	UpdatedOn *string `json:"updated_on,omitempty"`

	// WatcherId The expression of watcher id of the issue.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	WatcherId            *string           `json:"watcher_id,omitempty"`
	AdditionalProperties map[string]string `json:"-"`
}

// IssuesIndexProjectPdfParams defines parameters for IssuesIndexProjectPdf.
type IssuesIndexProjectPdfParams struct {
	// Pagination Pagination parameters to control the number of items returned in the response.
	// If not specified, it defaults to 25 items per page.
	Pagination *struct {
		// Limit The number of items to be present in the response.
		// If not specified, it defaults to 25.
		Limit *int `json:"limit,omitempty"`

		// Nometa If set to 1, the response will not include pagination information.
		Nometa *int `json:"nometa,omitempty"`

		// Offset The offset of the first object to retrieve
		// If not specified, it defaults to 0.
		Offset *int `json:"offset,omitempty"`
	} `form:"pagination,omitempty" json:"pagination,omitempty"`
	Query *IssuesIndexProjectPdfParams_Query `form:"query,omitempty" json:"query,omitempty"`

	// Include fetch associated data (optional).
	// Possible values: `allowed_statuses`, `attachments`, `changesets`, `children`, `journals`, `relations`, `watchers`.
	Include *[]string `form:"include,omitempty" json:"include,omitempty"`

	// XRedmineNometa If set to 1, the response will not include metadata information.
	XRedmineNometa *int `json:"X-Redmine-Nometa,omitempty"`

	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// GanttsShowProjectPdfParams defines parameters for GanttsShowProjectPdf.
type GanttsShowProjectPdfParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// GanttsShowProjectPngParams defines parameters for GanttsShowProjectPng.
type GanttsShowProjectPngParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// MembersIndexParams defines parameters for MembersIndex.
type MembersIndexParams struct {
	// Pagination Pagination parameters to control the number of items returned in the response.
	// If not specified, it defaults to 25 items per page.
	Pagination *struct {
		// Limit The number of items to be present in the response.
		// If not specified, it defaults to 25.
		Limit *int `json:"limit,omitempty"`

		// Nometa If set to 1, the response will not include pagination information.
		Nometa *int `json:"nometa,omitempty"`

		// Offset The offset of the first object to retrieve
		// If not specified, it defaults to 0.
		Offset *int `json:"offset,omitempty"`
	} `form:"pagination,omitempty" json:"pagination,omitempty"`

	// XRedmineNometa If set to 1, the response will not include metadata information.
	XRedmineNometa *int `json:"X-Redmine-Nometa,omitempty"`

	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// MembersCreateJSONBody defines parameters for MembersCreate.
type MembersCreateJSONBody struct {
	// Membership A single membership.
	Membership *struct {
		RoleIds *[]int `json:"role_ids,omitempty"`

		// UserId The ID of the user.
		UserId  *int   `json:"user_id,omitempty"`
		UserIds *[]int `json:"user_ids,omitempty"`
	} `json:"membership,omitempty"`
}

// MembersCreateParams defines parameters for MembersCreate.
type MembersCreateParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// NewsIndexProjectParams defines parameters for NewsIndexProject.
type NewsIndexProjectParams struct {
	// Pagination Pagination parameters to control the number of items returned in the response.
	// If not specified, it defaults to 25 items per page.
	Pagination *struct {
		// Limit The number of items to be present in the response.
		// If not specified, it defaults to 25.
		Limit *int `json:"limit,omitempty"`

		// Nometa If set to 1, the response will not include pagination information.
		Nometa *int `json:"nometa,omitempty"`

		// Offset The offset of the first object to retrieve
		// If not specified, it defaults to 0.
		Offset *int `json:"offset,omitempty"`
	} `form:"pagination,omitempty" json:"pagination,omitempty"`

	// XRedmineNometa If set to 1, the response will not include metadata information.
	XRedmineNometa *int `json:"X-Redmine-Nometa,omitempty"`

	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// NewsCreateProjectJSONBody defines parameters for NewsCreateProject.
type NewsCreateProjectJSONBody struct {
	// News A single news.
	News *struct {
		// Description The description of the news.
		Description *string `json:"description,omitempty"`

		// Summary The summary of the news.
		Summary *string `json:"summary,omitempty"`

		// Title The title of the news.
		Title *string `json:"title,omitempty"`
	} `json:"news,omitempty"`
}

// NewsCreateProjectParams defines parameters for NewsCreateProject.
type NewsCreateProjectParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// SearchIndexProjectParams defines parameters for SearchIndexProject.
type SearchIndexProjectParams struct {
	// Pagination Pagination parameters to control the number of items returned in the response.
	// If not specified, it defaults to 25 items per page.
	Pagination *struct {
		// Limit The number of items to be present in the response.
		// If not specified, it defaults to 25.
		Limit *int `json:"limit,omitempty"`

		// Nometa If set to 1, the response will not include pagination information.
		Nometa *int `json:"nometa,omitempty"`

		// Offset The offset of the first object to retrieve
		// If not specified, it defaults to 0.
		Offset *int `json:"offset,omitempty"`
	} `form:"pagination,omitempty" json:"pagination,omitempty"`

	// Q Query string. Multiple values can be specified, separated by a space (" ").
	Q     string `form:"q" json:"q"`
	Query *struct {
		// AllWords matched all query strings or not.
		AllWords *bool `json:"all_words,omitempty"`

		// Attachments Filterd by description and attachment.
		// - `0`: Seach only in description
		// - `1`: Search by description and attachment
		// - `only`: Search only in attachment
		Attachments *string `json:"attachments,omitempty"`

		// Changesets Include changesets or not.
		Changesets *bool `json:"changesets,omitempty"`

		// Documents Include documents or not.
		Documents *bool `json:"documents,omitempty"`

		// Issues Include issues or not.
		Issues *bool `json:"issues,omitempty"`

		// Messages Include messages or not.
		Messages *bool `json:"messages,omitempty"`

		// News Include news or not.
		News *bool `json:"news,omitempty"`

		// OpenIssues Filterd by open issues.
		OpenIssues *bool `json:"open_issues,omitempty"`

		// Projects Include projects or not.
		Projects *bool `json:"projects,omitempty"`

		// Scope Search scope condition.
		// Possible values are:
		// - `all`: Search all projects
		// - `my_project`: Search assigned projects
		// - `bookmarks`: Search bookmarked projects
		// - `subprojects`: Include subproject when project specified
		Scope *string `json:"scope,omitempty"`

		// TitlesOnly matched only title or not.
		TitlesOnly *bool `json:"titles_only,omitempty"`

		// WikiPages Include documents or not.
		WikiPages *bool `json:"wiki_pages,omitempty"`
	} `form:"query,omitempty" json:"query,omitempty"`

	// XRedmineNometa If set to 1, the response will not include metadata information.
	XRedmineNometa *int `json:"X-Redmine-Nometa,omitempty"`

	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// TimelogIndexProjectCsvParams_Query defines parameters for TimelogIndexProjectCsv.
type TimelogIndexProjectCsvParams_Query struct {
	// ActivityId The expression of activity id of the time entry.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	ActivityId *string `json:"activity_id,omitempty"`

	// AuthorId The expression of author id of the time entry.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	AuthorId *string `json:"author_id,omitempty"`

	// Hours The expression of hours of the time entry.
	// The expression format is "\<operator>\<value>".
	Hours *string `json:"hours,omitempty"`

	// IssueCategoryId The expression of issue status id of the time entry.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	IssueCategoryId *string `json:"issue.category_id,omitempty"`

	// IssueComments The expression of comments of the time entry.
	// The expression format is "\<operator>\<value>".
	// examples:
	// - contains "test": `~test`
	// - not contains "test": `!~test`
	IssueComments *string `json:"issue.comments,omitempty"`

	// IssueFixedVersionId The expression of issue fixed version id of the time entry.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	IssueFixedVersionId *string `json:"issue.fixed_version_id,omitempty"`

	// IssueParentId The expression of issue parent id of the time entry.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	IssueParentId *string `json:"issue.parent_id,omitempty"`

	// IssueStatusId The expression of issue status id of the time entry.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	IssueStatusId *string `json:"issue.status_id,omitempty"`

	// IssueSubject The expression of issue subject of the time entry.
	// The expression format is "\<operator>\<value>".
	// examples:
	// - contains "test": `~test`
	// - not contains "test": `!~test`
	IssueSubject *string `json:"issue.subject,omitempty"`

	// IssueTrackerId The expression of issue tracker id of the time entry.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	IssueTrackerId *string `json:"issue.tracker_id,omitempty"`

	// IssueId The expression of issue id of the time entry.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	IssueId *string `json:"issue_id,omitempty"`

	// ProjectStatus The expression of project status of the time entry.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	ProjectStatus *string `json:"project.status,omitempty"`

	// ProjectId The expression of project ID or identifier of the time entry.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	ProjectId *string `json:"project_id,omitempty"`

	// SpentOn The expression of spent_on of the time entry.
	// The expression format is "[operator]\<value>".
	// examples:
	// - last week : `lw`
	// - before "2025/7/12": `<=2025-07-12`
	SpentOn *string `json:"spent_on,omitempty"`

	// SubprojectId The expression of sub project ID or identifier of the time entry.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	SubprojectId *string `json:"subproject_id,omitempty"`

	// UserGroup The expression of user group of the time entry.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	UserGroup *string `json:"user.group,omitempty"`

	// UserRole The expression of user role of the time entry.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	UserRole *string `json:"user.role,omitempty"`

	// UserId The expression of user id of the time entry.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	UserId               *string           `json:"user_id,omitempty"`
	AdditionalProperties map[string]string `json:"-"`
}

// TimelogIndexProjectCsvParams defines parameters for TimelogIndexProjectCsv.
type TimelogIndexProjectCsvParams struct {
	Query *TimelogIndexProjectCsvParams_Query `form:"query,omitempty" json:"query,omitempty"`

	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// TimelogIndexProjectParams_Query defines parameters for TimelogIndexProject.
type TimelogIndexProjectParams_Query struct {
	// ActivityId The expression of activity id of the time entry.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	ActivityId *string `json:"activity_id,omitempty"`

	// AuthorId The expression of author id of the time entry.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	AuthorId *string `json:"author_id,omitempty"`

	// Hours The expression of hours of the time entry.
	// The expression format is "\<operator>\<value>".
	Hours *string `json:"hours,omitempty"`

	// IssueCategoryId The expression of issue status id of the time entry.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	IssueCategoryId *string `json:"issue.category_id,omitempty"`

	// IssueComments The expression of comments of the time entry.
	// The expression format is "\<operator>\<value>".
	// examples:
	// - contains "test": `~test`
	// - not contains "test": `!~test`
	IssueComments *string `json:"issue.comments,omitempty"`

	// IssueFixedVersionId The expression of issue fixed version id of the time entry.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	IssueFixedVersionId *string `json:"issue.fixed_version_id,omitempty"`

	// IssueParentId The expression of issue parent id of the time entry.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	IssueParentId *string `json:"issue.parent_id,omitempty"`

	// IssueStatusId The expression of issue status id of the time entry.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	IssueStatusId *string `json:"issue.status_id,omitempty"`

	// IssueSubject The expression of issue subject of the time entry.
	// The expression format is "\<operator>\<value>".
	// examples:
	// - contains "test": `~test`
	// - not contains "test": `!~test`
	IssueSubject *string `json:"issue.subject,omitempty"`

	// IssueTrackerId The expression of issue tracker id of the time entry.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	IssueTrackerId *string `json:"issue.tracker_id,omitempty"`

	// IssueId The expression of issue id of the time entry.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	IssueId *string `json:"issue_id,omitempty"`

	// ProjectStatus The expression of project status of the time entry.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	ProjectStatus *string `json:"project.status,omitempty"`

	// ProjectId The expression of project ID or identifier of the time entry.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	ProjectId *string `json:"project_id,omitempty"`

	// SpentOn The expression of spent_on of the time entry.
	// The expression format is "[operator]\<value>".
	// examples:
	// - last week : `lw`
	// - before "2025/7/12": `<=2025-07-12`
	SpentOn *string `json:"spent_on,omitempty"`

	// SubprojectId The expression of sub project ID or identifier of the time entry.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	SubprojectId *string `json:"subproject_id,omitempty"`

	// UserGroup The expression of user group of the time entry.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	UserGroup *string `json:"user.group,omitempty"`

	// UserRole The expression of user role of the time entry.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	UserRole *string `json:"user.role,omitempty"`

	// UserId The expression of user id of the time entry.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	UserId               *string           `json:"user_id,omitempty"`
	AdditionalProperties map[string]string `json:"-"`
}

// TimelogIndexProjectParams defines parameters for TimelogIndexProject.
type TimelogIndexProjectParams struct {
	// Pagination Pagination parameters to control the number of items returned in the response.
	// If not specified, it defaults to 25 items per page.
	Pagination *struct {
		// Limit The number of items to be present in the response.
		// If not specified, it defaults to 25.
		Limit *int `json:"limit,omitempty"`

		// Nometa If set to 1, the response will not include pagination information.
		Nometa *int `json:"nometa,omitempty"`

		// Offset The offset of the first object to retrieve
		// If not specified, it defaults to 0.
		Offset *int `json:"offset,omitempty"`
	} `form:"pagination,omitempty" json:"pagination,omitempty"`
	Query *TimelogIndexProjectParams_Query `form:"query,omitempty" json:"query,omitempty"`

	// XRedmineNometa If set to 1, the response will not include metadata information.
	XRedmineNometa *int `json:"X-Redmine-Nometa,omitempty"`

	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// TimelogCreateProjectJSONBody defines parameters for TimelogCreateProject.
type TimelogCreateProjectJSONBody struct {
	// TimeEntry A single time entry.
	TimeEntry *struct {
		// ActivityId The activity ID of the time entry.
		ActivityId *int `json:"activity_id,omitempty"`

		// Comments The comments of the time entry.
		Comments *string `json:"comments,omitempty"`

		// CustomFieldValues The values of the custom fields.
		CustomFieldValues *map[string]interface{} `json:"custom_field_values,omitempty"`
		CustomFields      *[]struct {
			// Id The ID of the custom field.
			Id *int `json:"id,omitempty"`

			// Multiple Whether the custom field can have multiple values.
			Multiple *bool `json:"multiple,omitempty"`

			// Name The name of the custom field.
			Name  *string      `json:"name,omitempty"`
			Value *interface{} `json:"value,omitempty"`
		} `json:"custom_fields,omitempty"`

		// Hours The hours of the time entry.
		Hours *float32 `json:"hours,omitempty"`

		// IssueId The issue ID of the time entry.
		IssueId *int `json:"issue_id,omitempty"`

		// ProjectId The project ID of the time entry.
		ProjectId *int `json:"project_id,omitempty"`

		// SpentOn The spent on of the time entry.
		SpentOn *openapi_types.Date `json:"spent_on,omitempty"`

		// UserId The user ID of the time entry.
		UserId *int `json:"user_id,omitempty"`
	} `json:"time_entry,omitempty"`
}

// TimelogCreateProjectParams defines parameters for TimelogCreateProject.
type TimelogCreateProjectParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// VersionsIndexParams defines parameters for VersionsIndex.
type VersionsIndexParams struct {
	// Nometa If set to 1, the response will not include metadata information.
	Nometa *int `form:"nometa,omitempty" json:"nometa,omitempty"`

	// XRedmineNometa If set to 1, the response will not include metadata information.
	XRedmineNometa *int `json:"X-Redmine-Nometa,omitempty"`

	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// VersionsCreateJSONBody defines parameters for VersionsCreate.
type VersionsCreateJSONBody struct {
	// Version A single version.
	Version *struct {
		// CustomFieldValues The values of the custom fields.
		CustomFieldValues *map[string]interface{} `json:"custom_field_values,omitempty"`
		CustomFields      *[]struct {
			// Id The ID of the custom field.
			Id *int `json:"id,omitempty"`

			// Multiple Whether the custom field can have multiple values.
			Multiple *bool `json:"multiple,omitempty"`

			// Name The name of the custom field.
			Name  *string      `json:"name,omitempty"`
			Value *interface{} `json:"value,omitempty"`
		} `json:"custom_fields,omitempty"`

		// DefaultProjectVersion The default project version of the version.
		DefaultProjectVersion *bool `json:"default_project_version,omitempty"`

		// Description The description of the version.
		Description *string `json:"description,omitempty"`

		// DueDate The due date of the version.
		DueDate *openapi_types.Date `json:"due_date,omitempty"`

		// EffectiveDate The effective date of the version.
		EffectiveDate *openapi_types.Date `json:"effective_date,omitempty"`

		// Name The name of the version.
		Name *string `json:"name,omitempty"`

		// Sharing The sharing of the version. Possible values are:
		// - `none`
		// - `descendants`
		// - `hierarchy`
		// - `tree`
		// - `system`
		Sharing *string `json:"sharing,omitempty"`

		// Status The status of the version. Possible values are:
		// - `open`
		// - `locked`
		// - `closed`
		Status *string `json:"status,omitempty"`

		// WikiPageTitle The wiki page title of the version.
		WikiPageTitle *string `json:"wiki_page_title,omitempty"`
	} `json:"version,omitempty"`
}

// VersionsCreateParams defines parameters for VersionsCreate.
type VersionsCreateParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// WikiShowRootParams defines parameters for WikiShowRoot.
type WikiShowRootParams struct {
	// Include fetch associated data (optional).
	// Possible values: `attachments`.
	Include *[]string `form:"include,omitempty" json:"include,omitempty"`

	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// WikiIndexParams defines parameters for WikiIndex.
type WikiIndexParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// WikiDestroyParams defines parameters for WikiDestroy.
type WikiDestroyParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// WikiShowParams defines parameters for WikiShow.
type WikiShowParams struct {
	// Include fetch associated data (optional).
	// Possible values: `attachments`.
	Include *[]string `form:"include,omitempty" json:"include,omitempty"`

	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// WikiUpdatePatchJSONBody defines parameters for WikiUpdatePatch.
type WikiUpdatePatchJSONBody struct {
	// WikiPage A single wiki.
	WikiPage *struct {
		// Comments The comment of the wiki.
		Comments *string `json:"comments,omitempty"`

		// ParentTitle The parent title of the wiki.
		ParentTitle *string `json:"parent_title,omitempty"`

		// Text The text of the wiki.
		Text *string `json:"text,omitempty"`

		// Version The version of the wiki.
		Version *int `json:"version,omitempty"`
	} `json:"wiki_page,omitempty"`
}

// WikiUpdatePatchParams defines parameters for WikiUpdatePatch.
type WikiUpdatePatchParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// WikiUpdatePutJSONBody defines parameters for WikiUpdatePut.
type WikiUpdatePutJSONBody struct {
	// WikiPage A single wiki.
	WikiPage *struct {
		// Comments The comment of the wiki.
		Comments *string `json:"comments,omitempty"`

		// ParentTitle The parent title of the wiki.
		ParentTitle *string `json:"parent_title,omitempty"`

		// Text The text of the wiki.
		Text *string `json:"text,omitempty"`

		// Version The version of the wiki.
		Version *int `json:"version,omitempty"`
	} `json:"wiki_page,omitempty"`
}

// WikiUpdatePutParams defines parameters for WikiUpdatePut.
type WikiUpdatePutParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// WikiShowPdfParams defines parameters for WikiShowPdf.
type WikiShowPdfParams struct {
	// Include fetch associated data (optional).
	// Possible values: `attachments`.
	Include *[]string `form:"include,omitempty" json:"include,omitempty"`

	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// WikiShowTxtParams defines parameters for WikiShowTxt.
type WikiShowTxtParams struct {
	// Include fetch associated data (optional).
	// Possible values: `attachments`.
	Include *[]string `form:"include,omitempty" json:"include,omitempty"`

	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// WikiShowVersionParams defines parameters for WikiShowVersion.
type WikiShowVersionParams struct {
	// Include fetch associated data (optional).
	// Possible values: `attachments`.
	Include *[]string `form:"include,omitempty" json:"include,omitempty"`

	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// WikiShowVersionPdfParams defines parameters for WikiShowVersionPdf.
type WikiShowVersionPdfParams struct {
	// Include fetch associated data (optional).
	// Possible values: `attachments`.
	Include *[]string `form:"include,omitempty" json:"include,omitempty"`

	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// WikiShowVersionTxtParams defines parameters for WikiShowVersionTxt.
type WikiShowVersionTxtParams struct {
	// Include fetch associated data (optional).
	// Possible values: `attachments`.
	Include *[]string `form:"include,omitempty" json:"include,omitempty"`

	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// QueriesIndexParams defines parameters for QueriesIndex.
type QueriesIndexParams struct {
	// Pagination Pagination parameters to control the number of items returned in the response.
	// If not specified, it defaults to 25 items per page.
	Pagination *struct {
		// Limit The number of items to be present in the response.
		// If not specified, it defaults to 25.
		Limit *int `json:"limit,omitempty"`

		// Nometa If set to 1, the response will not include pagination information.
		Nometa *int `json:"nometa,omitempty"`

		// Offset The offset of the first object to retrieve
		// If not specified, it defaults to 0.
		Offset *int `json:"offset,omitempty"`
	} `form:"pagination,omitempty" json:"pagination,omitempty"`

	// XRedmineNometa If set to 1, the response will not include metadata information.
	XRedmineNometa *int `json:"X-Redmine-Nometa,omitempty"`

	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// IssueRelationsDestroyParams defines parameters for IssueRelationsDestroy.
type IssueRelationsDestroyParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// IssueRelationsShowParams defines parameters for IssueRelationsShow.
type IssueRelationsShowParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// RolesIndexParams defines parameters for RolesIndex.
type RolesIndexParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// RolesShowParams defines parameters for RolesShow.
type RolesShowParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// SearchIndexParams defines parameters for SearchIndex.
type SearchIndexParams struct {
	// Pagination Pagination parameters to control the number of items returned in the response.
	// If not specified, it defaults to 25 items per page.
	Pagination *struct {
		// Limit The number of items to be present in the response.
		// If not specified, it defaults to 25.
		Limit *int `json:"limit,omitempty"`

		// Nometa If set to 1, the response will not include pagination information.
		Nometa *int `json:"nometa,omitempty"`

		// Offset The offset of the first object to retrieve
		// If not specified, it defaults to 0.
		Offset *int `json:"offset,omitempty"`
	} `form:"pagination,omitempty" json:"pagination,omitempty"`

	// Q Query string. Multiple values can be specified, separated by a space (" ").
	Q     string `form:"q" json:"q"`
	Query *struct {
		// AllWords matched all query strings or not.
		AllWords *bool `json:"all_words,omitempty"`

		// Attachments Filterd by description and attachment.
		// - `0`: Seach only in description
		// - `1`: Search by description and attachment
		// - `only`: Search only in attachment
		Attachments *string `json:"attachments,omitempty"`

		// Changesets Include changesets or not.
		Changesets *bool `json:"changesets,omitempty"`

		// Documents Include documents or not.
		Documents *bool `json:"documents,omitempty"`

		// Issues Include issues or not.
		Issues *bool `json:"issues,omitempty"`

		// Messages Include messages or not.
		Messages *bool `json:"messages,omitempty"`

		// News Include news or not.
		News *bool `json:"news,omitempty"`

		// OpenIssues Filterd by open issues.
		OpenIssues *bool `json:"open_issues,omitempty"`

		// Projects Include projects or not.
		Projects *bool `json:"projects,omitempty"`

		// Scope Search scope condition.
		// Possible values are:
		// - `all`: Search all projects
		// - `my_project`: Search assigned projects
		// - `bookmarks`: Search bookmarked projects
		// - `subprojects`: Include subproject when project specified
		Scope *string `json:"scope,omitempty"`

		// TitlesOnly matched only title or not.
		TitlesOnly *bool `json:"titles_only,omitempty"`

		// WikiPages Include documents or not.
		WikiPages *bool `json:"wiki_pages,omitempty"`
	} `form:"query,omitempty" json:"query,omitempty"`

	// XRedmineNometa If set to 1, the response will not include metadata information.
	XRedmineNometa *int `json:"X-Redmine-Nometa,omitempty"`

	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// TimelogIndexCsvParams_Query defines parameters for TimelogIndexCsv.
type TimelogIndexCsvParams_Query struct {
	// ActivityId The expression of activity id of the time entry.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	ActivityId *string `json:"activity_id,omitempty"`

	// AuthorId The expression of author id of the time entry.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	AuthorId *string `json:"author_id,omitempty"`

	// Hours The expression of hours of the time entry.
	// The expression format is "\<operator>\<value>".
	Hours *string `json:"hours,omitempty"`

	// IssueCategoryId The expression of issue status id of the time entry.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	IssueCategoryId *string `json:"issue.category_id,omitempty"`

	// IssueComments The expression of comments of the time entry.
	// The expression format is "\<operator>\<value>".
	// examples:
	// - contains "test": `~test`
	// - not contains "test": `!~test`
	IssueComments *string `json:"issue.comments,omitempty"`

	// IssueFixedVersionId The expression of issue fixed version id of the time entry.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	IssueFixedVersionId *string `json:"issue.fixed_version_id,omitempty"`

	// IssueParentId The expression of issue parent id of the time entry.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	IssueParentId *string `json:"issue.parent_id,omitempty"`

	// IssueStatusId The expression of issue status id of the time entry.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	IssueStatusId *string `json:"issue.status_id,omitempty"`

	// IssueSubject The expression of issue subject of the time entry.
	// The expression format is "\<operator>\<value>".
	// examples:
	// - contains "test": `~test`
	// - not contains "test": `!~test`
	IssueSubject *string `json:"issue.subject,omitempty"`

	// IssueTrackerId The expression of issue tracker id of the time entry.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	IssueTrackerId *string `json:"issue.tracker_id,omitempty"`

	// IssueId The expression of issue id of the time entry.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	IssueId *string `json:"issue_id,omitempty"`

	// ProjectStatus The expression of project status of the time entry.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	ProjectStatus *string `json:"project.status,omitempty"`

	// ProjectId The expression of project ID or identifier of the time entry.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	ProjectId *string `json:"project_id,omitempty"`

	// SpentOn The expression of spent_on of the time entry.
	// The expression format is "[operator]\<value>".
	// examples:
	// - last week : `lw`
	// - before "2025/7/12": `<=2025-07-12`
	SpentOn *string `json:"spent_on,omitempty"`

	// SubprojectId The expression of sub project ID or identifier of the time entry.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	SubprojectId *string `json:"subproject_id,omitempty"`

	// UserGroup The expression of user group of the time entry.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	UserGroup *string `json:"user.group,omitempty"`

	// UserRole The expression of user role of the time entry.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	UserRole *string `json:"user.role,omitempty"`

	// UserId The expression of user id of the time entry.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	UserId               *string           `json:"user_id,omitempty"`
	AdditionalProperties map[string]string `json:"-"`
}

// TimelogIndexCsvParams defines parameters for TimelogIndexCsv.
type TimelogIndexCsvParams struct {
	Query *TimelogIndexCsvParams_Query `form:"query,omitempty" json:"query,omitempty"`

	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// TimelogIndexParams_Query defines parameters for TimelogIndex.
type TimelogIndexParams_Query struct {
	// ActivityId The expression of activity id of the time entry.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	ActivityId *string `json:"activity_id,omitempty"`

	// AuthorId The expression of author id of the time entry.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	AuthorId *string `json:"author_id,omitempty"`

	// Hours The expression of hours of the time entry.
	// The expression format is "\<operator>\<value>".
	Hours *string `json:"hours,omitempty"`

	// IssueCategoryId The expression of issue status id of the time entry.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	IssueCategoryId *string `json:"issue.category_id,omitempty"`

	// IssueComments The expression of comments of the time entry.
	// The expression format is "\<operator>\<value>".
	// examples:
	// - contains "test": `~test`
	// - not contains "test": `!~test`
	IssueComments *string `json:"issue.comments,omitempty"`

	// IssueFixedVersionId The expression of issue fixed version id of the time entry.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	IssueFixedVersionId *string `json:"issue.fixed_version_id,omitempty"`

	// IssueParentId The expression of issue parent id of the time entry.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	IssueParentId *string `json:"issue.parent_id,omitempty"`

	// IssueStatusId The expression of issue status id of the time entry.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	IssueStatusId *string `json:"issue.status_id,omitempty"`

	// IssueSubject The expression of issue subject of the time entry.
	// The expression format is "\<operator>\<value>".
	// examples:
	// - contains "test": `~test`
	// - not contains "test": `!~test`
	IssueSubject *string `json:"issue.subject,omitempty"`

	// IssueTrackerId The expression of issue tracker id of the time entry.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	IssueTrackerId *string `json:"issue.tracker_id,omitempty"`

	// IssueId The expression of issue id of the time entry.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	IssueId *string `json:"issue_id,omitempty"`

	// ProjectStatus The expression of project status of the time entry.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	ProjectStatus *string `json:"project.status,omitempty"`

	// ProjectId The expression of project ID or identifier of the time entry.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	ProjectId *string `json:"project_id,omitempty"`

	// SpentOn The expression of spent_on of the time entry.
	// The expression format is "[operator]\<value>".
	// examples:
	// - last week : `lw`
	// - before "2025/7/12": `<=2025-07-12`
	SpentOn *string `json:"spent_on,omitempty"`

	// SubprojectId The expression of sub project ID or identifier of the time entry.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	SubprojectId *string `json:"subproject_id,omitempty"`

	// UserGroup The expression of user group of the time entry.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	UserGroup *string `json:"user.group,omitempty"`

	// UserRole The expression of user role of the time entry.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	UserRole *string `json:"user.role,omitempty"`

	// UserId The expression of user id of the time entry.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	UserId               *string           `json:"user_id,omitempty"`
	AdditionalProperties map[string]string `json:"-"`
}

// TimelogIndexParams defines parameters for TimelogIndex.
type TimelogIndexParams struct {
	// Pagination Pagination parameters to control the number of items returned in the response.
	// If not specified, it defaults to 25 items per page.
	Pagination *struct {
		// Limit The number of items to be present in the response.
		// If not specified, it defaults to 25.
		Limit *int `json:"limit,omitempty"`

		// Nometa If set to 1, the response will not include pagination information.
		Nometa *int `json:"nometa,omitempty"`

		// Offset The offset of the first object to retrieve
		// If not specified, it defaults to 0.
		Offset *int `json:"offset,omitempty"`
	} `form:"pagination,omitempty" json:"pagination,omitempty"`
	Query *TimelogIndexParams_Query `form:"query,omitempty" json:"query,omitempty"`

	// XRedmineNometa If set to 1, the response will not include metadata information.
	XRedmineNometa *int `json:"X-Redmine-Nometa,omitempty"`

	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// TimelogCreateJSONBody defines parameters for TimelogCreate.
type TimelogCreateJSONBody struct {
	// TimeEntry A single time entry.
	TimeEntry *struct {
		// ActivityId The activity ID of the time entry.
		ActivityId *int `json:"activity_id,omitempty"`

		// Comments The comments of the time entry.
		Comments *string `json:"comments,omitempty"`

		// CustomFieldValues The values of the custom fields.
		CustomFieldValues *map[string]interface{} `json:"custom_field_values,omitempty"`
		CustomFields      *[]struct {
			// Id The ID of the custom field.
			Id *int `json:"id,omitempty"`

			// Multiple Whether the custom field can have multiple values.
			Multiple *bool `json:"multiple,omitempty"`

			// Name The name of the custom field.
			Name  *string      `json:"name,omitempty"`
			Value *interface{} `json:"value,omitempty"`
		} `json:"custom_fields,omitempty"`

		// Hours The hours of the time entry.
		Hours *float32 `json:"hours,omitempty"`

		// IssueId The issue ID of the time entry.
		IssueId *int `json:"issue_id,omitempty"`

		// ProjectId The project ID of the time entry.
		ProjectId *int `json:"project_id,omitempty"`

		// SpentOn The spent on of the time entry.
		SpentOn *openapi_types.Date `json:"spent_on,omitempty"`

		// UserId The user ID of the time entry.
		UserId *int `json:"user_id,omitempty"`
	} `json:"time_entry,omitempty"`
}

// TimelogCreateParams defines parameters for TimelogCreate.
type TimelogCreateParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// TimelogDestroyParams defines parameters for TimelogDestroy.
type TimelogDestroyParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// TimelogShowParams defines parameters for TimelogShow.
type TimelogShowParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// TimelogUpdatePatchJSONBody defines parameters for TimelogUpdatePatch.
type TimelogUpdatePatchJSONBody struct {
	// TimeEntry A single time entry.
	TimeEntry *struct {
		// ActivityId The activity ID of the time entry.
		ActivityId *int `json:"activity_id,omitempty"`

		// Comments The comments of the time entry.
		Comments *string `json:"comments,omitempty"`

		// CustomFieldValues The values of the custom fields.
		CustomFieldValues *map[string]interface{} `json:"custom_field_values,omitempty"`
		CustomFields      *[]struct {
			// Id The ID of the custom field.
			Id *int `json:"id,omitempty"`

			// Multiple Whether the custom field can have multiple values.
			Multiple *bool `json:"multiple,omitempty"`

			// Name The name of the custom field.
			Name  *string      `json:"name,omitempty"`
			Value *interface{} `json:"value,omitempty"`
		} `json:"custom_fields,omitempty"`

		// Hours The hours of the time entry.
		Hours *float32 `json:"hours,omitempty"`

		// IssueId The issue ID of the time entry.
		IssueId *int `json:"issue_id,omitempty"`

		// ProjectId The project ID of the time entry.
		ProjectId *int `json:"project_id,omitempty"`

		// SpentOn The spent on of the time entry.
		SpentOn *openapi_types.Date `json:"spent_on,omitempty"`

		// UserId The user ID of the time entry.
		UserId *int `json:"user_id,omitempty"`
	} `json:"time_entry,omitempty"`
}

// TimelogUpdatePatchParams defines parameters for TimelogUpdatePatch.
type TimelogUpdatePatchParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// TimelogUpdatePutJSONBody defines parameters for TimelogUpdatePut.
type TimelogUpdatePutJSONBody struct {
	// TimeEntry A single time entry.
	TimeEntry *struct {
		// ActivityId The activity ID of the time entry.
		ActivityId *int `json:"activity_id,omitempty"`

		// Comments The comments of the time entry.
		Comments *string `json:"comments,omitempty"`

		// CustomFieldValues The values of the custom fields.
		CustomFieldValues *map[string]interface{} `json:"custom_field_values,omitempty"`
		CustomFields      *[]struct {
			// Id The ID of the custom field.
			Id *int `json:"id,omitempty"`

			// Multiple Whether the custom field can have multiple values.
			Multiple *bool `json:"multiple,omitempty"`

			// Name The name of the custom field.
			Name  *string      `json:"name,omitempty"`
			Value *interface{} `json:"value,omitempty"`
		} `json:"custom_fields,omitempty"`

		// Hours The hours of the time entry.
		Hours *float32 `json:"hours,omitempty"`

		// IssueId The issue ID of the time entry.
		IssueId *int `json:"issue_id,omitempty"`

		// ProjectId The project ID of the time entry.
		ProjectId *int `json:"project_id,omitempty"`

		// SpentOn The spent on of the time entry.
		SpentOn *openapi_types.Date `json:"spent_on,omitempty"`

		// UserId The user ID of the time entry.
		UserId *int `json:"user_id,omitempty"`
	} `json:"time_entry,omitempty"`
}

// TimelogUpdatePutParams defines parameters for TimelogUpdatePut.
type TimelogUpdatePutParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// TrackersIndexParams defines parameters for TrackersIndex.
type TrackersIndexParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// AttachmentsUploadParams defines parameters for AttachmentsUpload.
type AttachmentsUploadParams struct {
	// Filename The filename of the attachment.
	Filename *string `form:"filename,omitempty" json:"filename,omitempty"`

	// ContentType The content type of the attachment.
	ContentType *string `form:"content_type,omitempty" json:"content_type,omitempty"`

	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// UsersIndexCsvParams_Query defines parameters for UsersIndexCsv.
type UsersIndexCsvParams_Query struct {
	// Admin The expression of administrative of the user.
	// The expression format is "\<operator>\<values>". Values should be separated by a pipe "|".
	// Possible values are:
	// - `0`: no
	// - `1`: yes
	//
	// examples:
	// - administrator: `1`
	// - non administrator: `0`
	Admin *string `json:"admin,omitempty"`

	// AuthSourceId The expression of auth source id of the user.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	AuthSourceId *string `json:"auth_source_id,omitempty"`

	// CreatedOn The expression of created_on of the user.
	// The expression format is "[operator]\<value>".
	// examples:
	// - last week : `lw`
	// - before "2025/7/12": `<=2025-07-12`
	CreatedOn *string `json:"created_on,omitempty"`

	// Firstname The expression of firstname of the user.
	// The expression format is "\<operator>\<value>".
	Firstname *string `json:"firstname,omitempty"`

	// IsMemberOfGroup The expression of group id of the user.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	IsMemberOfGroup *string `json:"is_member_of_group,omitempty"`

	// LastLoginOn The expression of last_login_on of the user.
	// The expression format is "[operator]\<value>".
	// examples:
	// - last week : `lw`
	// - before "2025/7/12": `<=2025-07-12`
	LastLoginOn *string `json:"last_login_on,omitempty"`

	// Lastname The expression of lastname of the user.
	// The expression format is "\<operator>\<value>".
	Lastname *string `json:"lastname,omitempty"`

	// Login The expression of login of the user.
	// The expression format is "\<operator>\<value>".
	Login *string `json:"login,omitempty"`

	// Mail The expression of mail of the user.
	// The expression format is "\<operator>\<value>".
	Mail *string `json:"mail,omitempty"`

	// Name The expression of name of the user.
	// The expression format is "\<operator>\<value>".
	// examples:
	// - contains "test": `~test`
	// - not contains "test": `!~test`
	Name *string `json:"name,omitempty"`

	// Status The expression of status of the user.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	// Possible values are:
	// - `1`: active
	// - `2`: registered
	// - `3`: locked
	//
	// examples:
	// - active or locked: `1|3`
	// - not locked: `!3`
	Status *string `json:"status,omitempty"`

	// TwofaScheme The expression of 2FA scheme id of the user.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	TwofaScheme          *string           `json:"twofa_scheme,omitempty"`
	AdditionalProperties map[string]string `json:"-"`
}

// UsersIndexCsvParams defines parameters for UsersIndexCsv.
type UsersIndexCsvParams struct {
	// Pagination Pagination parameters to control the number of items returned in the response.
	// If not specified, it defaults to 25 items per page.
	Pagination *struct {
		// Limit The number of items to be present in the response.
		// If not specified, it defaults to 25.
		Limit *int `json:"limit,omitempty"`

		// Nometa If set to 1, the response will not include pagination information.
		Nometa *int `json:"nometa,omitempty"`

		// Offset The offset of the first object to retrieve
		// If not specified, it defaults to 0.
		Offset *int `json:"offset,omitempty"`
	} `form:"pagination,omitempty" json:"pagination,omitempty"`
	Query *UsersIndexCsvParams_Query `form:"query,omitempty" json:"query,omitempty"`

	// Include fetch associated data (optional).
	// Possible values: `auth_source`, `memberships`, `groups`.
	Include *[]string `form:"include,omitempty" json:"include,omitempty"`

	// XRedmineNometa If set to 1, the response will not include metadata information.
	XRedmineNometa *int `json:"X-Redmine-Nometa,omitempty"`

	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// UsersIndexParams_Query defines parameters for UsersIndex.
type UsersIndexParams_Query struct {
	// Admin The expression of administrative of the user.
	// The expression format is "\<operator>\<values>". Values should be separated by a pipe "|".
	// Possible values are:
	// - `0`: no
	// - `1`: yes
	//
	// examples:
	// - administrator: `1`
	// - non administrator: `0`
	Admin *string `json:"admin,omitempty"`

	// AuthSourceId The expression of auth source id of the user.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	AuthSourceId *string `json:"auth_source_id,omitempty"`

	// CreatedOn The expression of created_on of the user.
	// The expression format is "[operator]\<value>".
	// examples:
	// - last week : `lw`
	// - before "2025/7/12": `<=2025-07-12`
	CreatedOn *string `json:"created_on,omitempty"`

	// Firstname The expression of firstname of the user.
	// The expression format is "\<operator>\<value>".
	Firstname *string `json:"firstname,omitempty"`

	// IsMemberOfGroup The expression of group id of the user.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	IsMemberOfGroup *string `json:"is_member_of_group,omitempty"`

	// LastLoginOn The expression of last_login_on of the user.
	// The expression format is "[operator]\<value>".
	// examples:
	// - last week : `lw`
	// - before "2025/7/12": `<=2025-07-12`
	LastLoginOn *string `json:"last_login_on,omitempty"`

	// Lastname The expression of lastname of the user.
	// The expression format is "\<operator>\<value>".
	Lastname *string `json:"lastname,omitempty"`

	// Login The expression of login of the user.
	// The expression format is "\<operator>\<value>".
	Login *string `json:"login,omitempty"`

	// Mail The expression of mail of the user.
	// The expression format is "\<operator>\<value>".
	Mail *string `json:"mail,omitempty"`

	// Name The expression of name of the user.
	// The expression format is "\<operator>\<value>".
	// examples:
	// - contains "test": `~test`
	// - not contains "test": `!~test`
	Name *string `json:"name,omitempty"`

	// Status The expression of status of the user.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	// Possible values are:
	// - `1`: active
	// - `2`: registered
	// - `3`: locked
	//
	// examples:
	// - active or locked: `1|3`
	// - not locked: `!3`
	Status *string `json:"status,omitempty"`

	// TwofaScheme The expression of 2FA scheme id of the user.
	// The expression format is "[operator]\<values>". Values should be separated by a pipe "|".
	TwofaScheme          *string           `json:"twofa_scheme,omitempty"`
	AdditionalProperties map[string]string `json:"-"`
}

// UsersIndexParams defines parameters for UsersIndex.
type UsersIndexParams struct {
	// Pagination Pagination parameters to control the number of items returned in the response.
	// If not specified, it defaults to 25 items per page.
	Pagination *struct {
		// Limit The number of items to be present in the response.
		// If not specified, it defaults to 25.
		Limit *int `json:"limit,omitempty"`

		// Nometa If set to 1, the response will not include pagination information.
		Nometa *int `json:"nometa,omitempty"`

		// Offset The offset of the first object to retrieve
		// If not specified, it defaults to 0.
		Offset *int `json:"offset,omitempty"`
	} `form:"pagination,omitempty" json:"pagination,omitempty"`
	Query *UsersIndexParams_Query `form:"query,omitempty" json:"query,omitempty"`

	// Include fetch associated data (optional).
	// Possible values: `auth_source`, `memberships`, `groups`.
	Include *[]string `form:"include,omitempty" json:"include,omitempty"`

	// XRedmineNometa If set to 1, the response will not include metadata information.
	XRedmineNometa *int `json:"X-Redmine-Nometa,omitempty"`

	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// UsersCreateJSONBody defines parameters for UsersCreate.
type UsersCreateJSONBody struct {
	// Pref The preferences of the user.
	Pref *struct {
		// AutoWatchOn The auto watch setting for the user. Possible values are:
		// - `issue_created`
		// - `issue_contributed_to`
		AutoWatchOn *[]string `json:"auto_watch_on,omitempty"`

		// CommentsSorting The sorting order of comments. Possible values are `asc` and `desc`.
		CommentsSorting *string `json:"comments_sorting,omitempty"`

		// DefaultIssueQuery The ID of the default issue query for the user.
		DefaultIssueQuery *int `json:"default_issue_query,omitempty"`

		// DefaultProjectQuery The ID of the default project query for the user.
		DefaultProjectQuery *int `json:"default_project_query,omitempty"`

		// HideMail Whether the user's email should be hidden.
		HideMail *bool `json:"hide_mail,omitempty"`

		// HistoryDefaultTab The default tab for the user's history. Possible values are:
		// - `notes`
		// - `history`
		// - `properties`
		// - `time_entries`
		// - `changesets`
		// - `last_tab_visited`
		HistoryDefaultTab *string `json:"history_default_tab,omitempty"`

		// NoSelfNotified Whether the user should not be notified of their own actions.
		NoSelfNotified *bool `json:"no_self_notified,omitempty"`

		// NotifyAboutHighPriorityIssues Whether the user should be notified about high priority issues.
		NotifyAboutHighPriorityIssues *bool `json:"notify_about_high_priority_issues,omitempty"`

		// RecentlyUsedProjects The number of recently used projects to display.
		RecentlyUsedProjects *int `json:"recently_used_projects,omitempty"`

		// TextareaFont The font used in text areas. Possible values are:
		// - `monospace`
		// - `proportional`
		TextareaFont *string `json:"textarea_font,omitempty"`

		// TimeZone The time zone of the user.
		TimeZone *string `json:"time_zone,omitempty"`

		// ToolbarLanguageOptions The language options for the toolbar.
		ToolbarLanguageOptions *string `json:"toolbar_language_options,omitempty"`

		// WarnOnLeavingUnsaved Whether to warn the user when leaving a page with unsaved changes. Possible values are:
		// - `0`: Disable
		// - `1`: Enable
		WarnOnLeavingUnsaved *string `json:"warn_on_leaving_unsaved,omitempty"`
	} `json:"pref,omitempty"`

	// SendInformation If set to true, an email will be sent to the user with their login information.
	SendInformation *bool `json:"send_information,omitempty"`

	// User A single user.
	User *struct {
		// Admin The administrative of the user.
		Admin *bool `json:"admin,omitempty"`

		// AuthSourceId The auth source id of the user.
		AuthSourceId *int `json:"auth_source_id,omitempty"`

		// CustomFieldValues The values of the custom fields.
		CustomFieldValues *map[string]interface{} `json:"custom_field_values,omitempty"`
		CustomFields      *[]struct {
			// Id The ID of the custom field.
			Id *int `json:"id,omitempty"`

			// Multiple Whether the custom field can have multiple values.
			Multiple *bool `json:"multiple,omitempty"`

			// Name The name of the custom field.
			Name  *string      `json:"name,omitempty"`
			Value *interface{} `json:"value,omitempty"`
		} `json:"custom_fields,omitempty"`

		// Firstname The firstname of the user.
		Firstname *string `json:"firstname,omitempty"`

		// GeneratePassword The generate password of the user.
		GeneratePassword *bool `json:"generate_password,omitempty"`

		// GroupIds The group id of the user.
		GroupIds *[]int `json:"group_ids,omitempty"`

		// Language The language of the user.
		Language *string `json:"language,omitempty"`

		// Lastname The lastname of the user.
		Lastname *string `json:"lastname,omitempty"`

		// Login The login of the user.
		Login *string `json:"login,omitempty"`

		// Mail The mail address of the user.
		Mail *string `json:"mail,omitempty"`

		// MailNotification The mail notification of the user. Possible values are:
		// - `all`: all events
		// - `selected`: only selected events
		// - `only_my_events`: only events related to the user
		// - `only_assigned`: only events assigned to the user
		// - `only_owner`: only events owned by the user
		// - `none`: no events
		MailNotification *string `json:"mail_notification,omitempty"`

		// MustChangePasswd The must change passwd of the user.
		MustChangePasswd *bool `json:"must_change_passwd,omitempty"`

		// NotifiedProjectIds The notified project ID or identifier of the user.
		NotifiedProjectIds *[]string `json:"notified_project_ids,omitempty"`

		// Password The password of the user.
		Password *string `json:"password,omitempty"`

		// Status The status of the user. Possible values are:
		// - `0`: anonymous
		// - `1`: active
		// - `2`: registered
		// - `3`: locked
		Status *int `json:"status,omitempty"`
	} `json:"user,omitempty"`
}

// UsersCreateParams defines parameters for UsersCreate.
type UsersCreateParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// UsersDestroyParams defines parameters for UsersDestroy.
type UsersDestroyParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// UsersShowParams defines parameters for UsersShow.
type UsersShowParams struct {
	// Include fetch associated data (optional).
	// Possible values: `auth_source`, `memberships`, `groups`.
	Include *[]string `form:"include,omitempty" json:"include,omitempty"`

	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// UsersUpdatePatchJSONBody defines parameters for UsersUpdatePatch.
type UsersUpdatePatchJSONBody struct {
	// Pref The preferences of the user.
	Pref *struct {
		// AutoWatchOn The auto watch setting for the user. Possible values are:
		// - `issue_created`
		// - `issue_contributed_to`
		AutoWatchOn *[]string `json:"auto_watch_on,omitempty"`

		// CommentsSorting The sorting order of comments. Possible values are `asc` and `desc`.
		CommentsSorting *string `json:"comments_sorting,omitempty"`

		// DefaultIssueQuery The ID of the default issue query for the user.
		DefaultIssueQuery *int `json:"default_issue_query,omitempty"`

		// DefaultProjectQuery The ID of the default project query for the user.
		DefaultProjectQuery *int `json:"default_project_query,omitempty"`

		// HideMail Whether the user's email should be hidden.
		HideMail *bool `json:"hide_mail,omitempty"`

		// HistoryDefaultTab The default tab for the user's history. Possible values are:
		// - `notes`
		// - `history`
		// - `properties`
		// - `time_entries`
		// - `changesets`
		// - `last_tab_visited`
		HistoryDefaultTab *string `json:"history_default_tab,omitempty"`

		// NoSelfNotified Whether the user should not be notified of their own actions.
		NoSelfNotified *bool `json:"no_self_notified,omitempty"`

		// NotifyAboutHighPriorityIssues Whether the user should be notified about high priority issues.
		NotifyAboutHighPriorityIssues *bool `json:"notify_about_high_priority_issues,omitempty"`

		// RecentlyUsedProjects The number of recently used projects to display.
		RecentlyUsedProjects *int `json:"recently_used_projects,omitempty"`

		// TextareaFont The font used in text areas. Possible values are:
		// - `monospace`
		// - `proportional`
		TextareaFont *string `json:"textarea_font,omitempty"`

		// TimeZone The time zone of the user.
		TimeZone *string `json:"time_zone,omitempty"`

		// ToolbarLanguageOptions The language options for the toolbar.
		ToolbarLanguageOptions *string `json:"toolbar_language_options,omitempty"`

		// WarnOnLeavingUnsaved Whether to warn the user when leaving a page with unsaved changes. Possible values are:
		// - `0`: Disable
		// - `1`: Enable
		WarnOnLeavingUnsaved *string `json:"warn_on_leaving_unsaved,omitempty"`
	} `json:"pref,omitempty"`

	// SendInformation If set to true, an email will be sent to the user with their login information.
	SendInformation *bool `json:"send_information,omitempty"`

	// User A single user.
	User *struct {
		// Admin The administrative of the user.
		Admin *bool `json:"admin,omitempty"`

		// AuthSourceId The auth source id of the user.
		AuthSourceId *int `json:"auth_source_id,omitempty"`

		// CustomFieldValues The values of the custom fields.
		CustomFieldValues *map[string]interface{} `json:"custom_field_values,omitempty"`
		CustomFields      *[]struct {
			// Id The ID of the custom field.
			Id *int `json:"id,omitempty"`

			// Multiple Whether the custom field can have multiple values.
			Multiple *bool `json:"multiple,omitempty"`

			// Name The name of the custom field.
			Name  *string      `json:"name,omitempty"`
			Value *interface{} `json:"value,omitempty"`
		} `json:"custom_fields,omitempty"`

		// Firstname The firstname of the user.
		Firstname *string `json:"firstname,omitempty"`

		// GeneratePassword The generate password of the user.
		GeneratePassword *bool `json:"generate_password,omitempty"`

		// GroupIds The group id of the user.
		GroupIds *[]int `json:"group_ids,omitempty"`

		// Language The language of the user.
		Language *string `json:"language,omitempty"`

		// Lastname The lastname of the user.
		Lastname *string `json:"lastname,omitempty"`

		// Login The login of the user.
		Login *string `json:"login,omitempty"`

		// Mail The mail address of the user.
		Mail *string `json:"mail,omitempty"`

		// MailNotification The mail notification of the user. Possible values are:
		// - `all`: all events
		// - `selected`: only selected events
		// - `only_my_events`: only events related to the user
		// - `only_assigned`: only events assigned to the user
		// - `only_owner`: only events owned by the user
		// - `none`: no events
		MailNotification *string `json:"mail_notification,omitempty"`

		// MustChangePasswd The must change passwd of the user.
		MustChangePasswd *bool `json:"must_change_passwd,omitempty"`

		// NotifiedProjectIds The notified project ID or identifier of the user.
		NotifiedProjectIds *[]string `json:"notified_project_ids,omitempty"`

		// Password The password of the user.
		Password *string `json:"password,omitempty"`

		// Status The status of the user. Possible values are:
		// - `0`: anonymous
		// - `1`: active
		// - `2`: registered
		// - `3`: locked
		Status *int `json:"status,omitempty"`
	} `json:"user,omitempty"`
}

// UsersUpdatePatchParams defines parameters for UsersUpdatePatch.
type UsersUpdatePatchParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// UsersUpdatePutJSONBody defines parameters for UsersUpdatePut.
type UsersUpdatePutJSONBody struct {
	// Pref The preferences of the user.
	Pref *struct {
		// AutoWatchOn The auto watch setting for the user. Possible values are:
		// - `issue_created`
		// - `issue_contributed_to`
		AutoWatchOn *[]string `json:"auto_watch_on,omitempty"`

		// CommentsSorting The sorting order of comments. Possible values are `asc` and `desc`.
		CommentsSorting *string `json:"comments_sorting,omitempty"`

		// DefaultIssueQuery The ID of the default issue query for the user.
		DefaultIssueQuery *int `json:"default_issue_query,omitempty"`

		// DefaultProjectQuery The ID of the default project query for the user.
		DefaultProjectQuery *int `json:"default_project_query,omitempty"`

		// HideMail Whether the user's email should be hidden.
		HideMail *bool `json:"hide_mail,omitempty"`

		// HistoryDefaultTab The default tab for the user's history. Possible values are:
		// - `notes`
		// - `history`
		// - `properties`
		// - `time_entries`
		// - `changesets`
		// - `last_tab_visited`
		HistoryDefaultTab *string `json:"history_default_tab,omitempty"`

		// NoSelfNotified Whether the user should not be notified of their own actions.
		NoSelfNotified *bool `json:"no_self_notified,omitempty"`

		// NotifyAboutHighPriorityIssues Whether the user should be notified about high priority issues.
		NotifyAboutHighPriorityIssues *bool `json:"notify_about_high_priority_issues,omitempty"`

		// RecentlyUsedProjects The number of recently used projects to display.
		RecentlyUsedProjects *int `json:"recently_used_projects,omitempty"`

		// TextareaFont The font used in text areas. Possible values are:
		// - `monospace`
		// - `proportional`
		TextareaFont *string `json:"textarea_font,omitempty"`

		// TimeZone The time zone of the user.
		TimeZone *string `json:"time_zone,omitempty"`

		// ToolbarLanguageOptions The language options for the toolbar.
		ToolbarLanguageOptions *string `json:"toolbar_language_options,omitempty"`

		// WarnOnLeavingUnsaved Whether to warn the user when leaving a page with unsaved changes. Possible values are:
		// - `0`: Disable
		// - `1`: Enable
		WarnOnLeavingUnsaved *string `json:"warn_on_leaving_unsaved,omitempty"`
	} `json:"pref,omitempty"`

	// SendInformation If set to true, an email will be sent to the user with their login information.
	SendInformation *bool `json:"send_information,omitempty"`

	// User A single user.
	User *struct {
		// Admin The administrative of the user.
		Admin *bool `json:"admin,omitempty"`

		// AuthSourceId The auth source id of the user.
		AuthSourceId *int `json:"auth_source_id,omitempty"`

		// CustomFieldValues The values of the custom fields.
		CustomFieldValues *map[string]interface{} `json:"custom_field_values,omitempty"`
		CustomFields      *[]struct {
			// Id The ID of the custom field.
			Id *int `json:"id,omitempty"`

			// Multiple Whether the custom field can have multiple values.
			Multiple *bool `json:"multiple,omitempty"`

			// Name The name of the custom field.
			Name  *string      `json:"name,omitempty"`
			Value *interface{} `json:"value,omitempty"`
		} `json:"custom_fields,omitempty"`

		// Firstname The firstname of the user.
		Firstname *string `json:"firstname,omitempty"`

		// GeneratePassword The generate password of the user.
		GeneratePassword *bool `json:"generate_password,omitempty"`

		// GroupIds The group id of the user.
		GroupIds *[]int `json:"group_ids,omitempty"`

		// Language The language of the user.
		Language *string `json:"language,omitempty"`

		// Lastname The lastname of the user.
		Lastname *string `json:"lastname,omitempty"`

		// Login The login of the user.
		Login *string `json:"login,omitempty"`

		// Mail The mail address of the user.
		Mail *string `json:"mail,omitempty"`

		// MailNotification The mail notification of the user. Possible values are:
		// - `all`: all events
		// - `selected`: only selected events
		// - `only_my_events`: only events related to the user
		// - `only_assigned`: only events assigned to the user
		// - `only_owner`: only events owned by the user
		// - `none`: no events
		MailNotification *string `json:"mail_notification,omitempty"`

		// MustChangePasswd The must change passwd of the user.
		MustChangePasswd *bool `json:"must_change_passwd,omitempty"`

		// NotifiedProjectIds The notified project ID or identifier of the user.
		NotifiedProjectIds *[]string `json:"notified_project_ids,omitempty"`

		// Password The password of the user.
		Password *string `json:"password,omitempty"`

		// Status The status of the user. Possible values are:
		// - `0`: anonymous
		// - `1`: active
		// - `2`: registered
		// - `3`: locked
		Status *int `json:"status,omitempty"`
	} `json:"user,omitempty"`
}

// UsersUpdatePutParams defines parameters for UsersUpdatePut.
type UsersUpdatePutParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// VersionsDestroyParams defines parameters for VersionsDestroy.
type VersionsDestroyParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// VersionsShowParams defines parameters for VersionsShow.
type VersionsShowParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// VersionsUpdatePatchJSONBody defines parameters for VersionsUpdatePatch.
type VersionsUpdatePatchJSONBody struct {
	// Version A single version.
	Version *struct {
		// CustomFieldValues The values of the custom fields.
		CustomFieldValues *map[string]interface{} `json:"custom_field_values,omitempty"`
		CustomFields      *[]struct {
			// Id The ID of the custom field.
			Id *int `json:"id,omitempty"`

			// Multiple Whether the custom field can have multiple values.
			Multiple *bool `json:"multiple,omitempty"`

			// Name The name of the custom field.
			Name  *string      `json:"name,omitempty"`
			Value *interface{} `json:"value,omitempty"`
		} `json:"custom_fields,omitempty"`

		// DefaultProjectVersion The default project version of the version.
		DefaultProjectVersion *bool `json:"default_project_version,omitempty"`

		// Description The description of the version.
		Description *string `json:"description,omitempty"`

		// DueDate The due date of the version.
		DueDate *openapi_types.Date `json:"due_date,omitempty"`

		// EffectiveDate The effective date of the version.
		EffectiveDate *openapi_types.Date `json:"effective_date,omitempty"`

		// Name The name of the version.
		Name *string `json:"name,omitempty"`

		// Sharing The sharing of the version. Possible values are:
		// - `none`
		// - `descendants`
		// - `hierarchy`
		// - `tree`
		// - `system`
		Sharing *string `json:"sharing,omitempty"`

		// Status The status of the version. Possible values are:
		// - `open`
		// - `locked`
		// - `closed`
		Status *string `json:"status,omitempty"`

		// WikiPageTitle The wiki page title of the version.
		WikiPageTitle *string `json:"wiki_page_title,omitempty"`
	} `json:"version,omitempty"`
}

// VersionsUpdatePatchParams defines parameters for VersionsUpdatePatch.
type VersionsUpdatePatchParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// VersionsUpdatePutJSONBody defines parameters for VersionsUpdatePut.
type VersionsUpdatePutJSONBody struct {
	// Version A single version.
	Version *struct {
		// CustomFieldValues The values of the custom fields.
		CustomFieldValues *map[string]interface{} `json:"custom_field_values,omitempty"`
		CustomFields      *[]struct {
			// Id The ID of the custom field.
			Id *int `json:"id,omitempty"`

			// Multiple Whether the custom field can have multiple values.
			Multiple *bool `json:"multiple,omitempty"`

			// Name The name of the custom field.
			Name  *string      `json:"name,omitempty"`
			Value *interface{} `json:"value,omitempty"`
		} `json:"custom_fields,omitempty"`

		// DefaultProjectVersion The default project version of the version.
		DefaultProjectVersion *bool `json:"default_project_version,omitempty"`

		// Description The description of the version.
		Description *string `json:"description,omitempty"`

		// DueDate The due date of the version.
		DueDate *openapi_types.Date `json:"due_date,omitempty"`

		// EffectiveDate The effective date of the version.
		EffectiveDate *openapi_types.Date `json:"effective_date,omitempty"`

		// Name The name of the version.
		Name *string `json:"name,omitempty"`

		// Sharing The sharing of the version. Possible values are:
		// - `none`
		// - `descendants`
		// - `hierarchy`
		// - `tree`
		// - `system`
		Sharing *string `json:"sharing,omitempty"`

		// Status The status of the version. Possible values are:
		// - `open`
		// - `locked`
		// - `closed`
		Status *string `json:"status,omitempty"`

		// WikiPageTitle The wiki page title of the version.
		WikiPageTitle *string `json:"wiki_page_title,omitempty"`
	} `json:"version,omitempty"`
}

// VersionsUpdatePutParams defines parameters for VersionsUpdatePut.
type VersionsUpdatePutParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// VersionsShowTxtParams defines parameters for VersionsShowTxt.
type VersionsShowTxtParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// WatchersDestroyParams defines parameters for WatchersDestroy.
type WatchersDestroyParams struct {
	// ObjectType The type of the object to be watched.
	ObjectType string `form:"object_type" json:"object_type"`

	// ObjectId The ID of the object.
	ObjectId int `form:"object_id" json:"object_id"`

	// UserId The ID of the user.
	UserId int `form:"user_id" json:"user_id"`

	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// WatchersCreateJSONBody defines parameters for WatchersCreate.
type WatchersCreateJSONBody struct {
	// ObjectId The ID of the object.
	ObjectId *int `json:"object_id,omitempty"`

	// ObjectType The type of the object.
	ObjectType *string `json:"object_type,omitempty"`

	// Watcher Represents a single watcher.
	Watcher *struct {
		// UserId The ID of the user.
		UserId  *int   `json:"user_id,omitempty"`
		UserIds *[]int `json:"user_ids,omitempty"`
	} `json:"watcher,omitempty"`
}

// WatchersCreateParams defines parameters for WatchersCreate.
type WatchersCreateParams struct {
	// XRedmineSwitchUser This only works when using the API with an administrator account,
	// this header will be ignored when using the API with a regular user account.
	XRedmineSwitchUser *string `json:"X-Redmine-Switch-User,omitempty"`
}

// AttachmentsUpdatePatchJSONRequestBody defines body for AttachmentsUpdatePatch for application/json ContentType.
type AttachmentsUpdatePatchJSONRequestBody AttachmentsUpdatePatchJSONBody

// AttachmentsUpdatePutJSONRequestBody defines body for AttachmentsUpdatePut for application/json ContentType.
type AttachmentsUpdatePutJSONRequestBody AttachmentsUpdatePutJSONBody

// GroupsCreateJSONRequestBody defines body for GroupsCreate for application/json ContentType.
type GroupsCreateJSONRequestBody GroupsCreateJSONBody

// GroupsUpdatePatchJSONRequestBody defines body for GroupsUpdatePatch for application/json ContentType.
type GroupsUpdatePatchJSONRequestBody GroupsUpdatePatchJSONBody

// GroupsUpdatePutJSONRequestBody defines body for GroupsUpdatePut for application/json ContentType.
type GroupsUpdatePutJSONRequestBody GroupsUpdatePutJSONBody

// GroupsAddUsersJSONRequestBody defines body for GroupsAddUsers for application/json ContentType.
type GroupsAddUsersJSONRequestBody GroupsAddUsersJSONBody

// IssueCategoriesUpdatePatchJSONRequestBody defines body for IssueCategoriesUpdatePatch for application/json ContentType.
type IssueCategoriesUpdatePatchJSONRequestBody IssueCategoriesUpdatePatchJSONBody

// IssueCategoriesUpdatePutJSONRequestBody defines body for IssueCategoriesUpdatePut for application/json ContentType.
type IssueCategoriesUpdatePutJSONRequestBody IssueCategoriesUpdatePutJSONBody

// IssuesCreateJSONRequestBody defines body for IssuesCreate for application/json ContentType.
type IssuesCreateJSONRequestBody IssuesCreateJSONBody

// IssuesUpdatePatchJSONRequestBody defines body for IssuesUpdatePatch for application/json ContentType.
type IssuesUpdatePatchJSONRequestBody IssuesUpdatePatchJSONBody

// IssuesUpdatePutJSONRequestBody defines body for IssuesUpdatePut for application/json ContentType.
type IssuesUpdatePutJSONRequestBody IssuesUpdatePutJSONBody

// IssueRelationsCreateJSONRequestBody defines body for IssueRelationsCreate for application/json ContentType.
type IssueRelationsCreateJSONRequestBody IssueRelationsCreateJSONBody

// TimelogCreateIssueJSONRequestBody defines body for TimelogCreateIssue for application/json ContentType.
type TimelogCreateIssueJSONRequestBody TimelogCreateIssueJSONBody

// WatchersCreateIssueJSONRequestBody defines body for WatchersCreateIssue for application/json ContentType.
type WatchersCreateIssueJSONRequestBody WatchersCreateIssueJSONBody

// JournalsUpdatePatchJSONRequestBody defines body for JournalsUpdatePatch for application/json ContentType.
type JournalsUpdatePatchJSONRequestBody JournalsUpdatePatchJSONBody

// JournalsUpdatePutJSONRequestBody defines body for JournalsUpdatePut for application/json ContentType.
type JournalsUpdatePutJSONRequestBody JournalsUpdatePutJSONBody

// MembersUpdatePatchJSONRequestBody defines body for MembersUpdatePatch for application/json ContentType.
type MembersUpdatePatchJSONRequestBody MembersUpdatePatchJSONBody

// MembersUpdatePutJSONRequestBody defines body for MembersUpdatePut for application/json ContentType.
type MembersUpdatePutJSONRequestBody MembersUpdatePutJSONBody

// MyAccountPutJSONRequestBody defines body for MyAccountPut for application/json ContentType.
type MyAccountPutJSONRequestBody MyAccountPutJSONBody

// NewsCreateJSONRequestBody defines body for NewsCreate for application/json ContentType.
type NewsCreateJSONRequestBody NewsCreateJSONBody

// NewsUpdatePatchJSONRequestBody defines body for NewsUpdatePatch for application/json ContentType.
type NewsUpdatePatchJSONRequestBody NewsUpdatePatchJSONBody

// NewsUpdatePutJSONRequestBody defines body for NewsUpdatePut for application/json ContentType.
type NewsUpdatePutJSONRequestBody NewsUpdatePutJSONBody

// ProjectsCreateJSONRequestBody defines body for ProjectsCreate for application/json ContentType.
type ProjectsCreateJSONRequestBody ProjectsCreateJSONBody

// ProjectsUpdatePatchJSONRequestBody defines body for ProjectsUpdatePatch for application/json ContentType.
type ProjectsUpdatePatchJSONRequestBody ProjectsUpdatePatchJSONBody

// ProjectsUpdatePutJSONRequestBody defines body for ProjectsUpdatePut for application/json ContentType.
type ProjectsUpdatePutJSONRequestBody ProjectsUpdatePutJSONBody

// RepositoriesAddRelatedIssueJSONRequestBody defines body for RepositoriesAddRelatedIssue for application/json ContentType.
type RepositoriesAddRelatedIssueJSONRequestBody RepositoriesAddRelatedIssueJSONBody

// FilesCreateJSONRequestBody defines body for FilesCreate for application/json ContentType.
type FilesCreateJSONRequestBody FilesCreateJSONBody

// IssueCategoriesCreateJSONRequestBody defines body for IssueCategoriesCreate for application/json ContentType.
type IssueCategoriesCreateJSONRequestBody IssueCategoriesCreateJSONBody

// IssuesCreateProjectJSONRequestBody defines body for IssuesCreateProject for application/json ContentType.
type IssuesCreateProjectJSONRequestBody IssuesCreateProjectJSONBody

// MembersCreateJSONRequestBody defines body for MembersCreate for application/json ContentType.
type MembersCreateJSONRequestBody MembersCreateJSONBody

// NewsCreateProjectJSONRequestBody defines body for NewsCreateProject for application/json ContentType.
type NewsCreateProjectJSONRequestBody NewsCreateProjectJSONBody

// TimelogCreateProjectJSONRequestBody defines body for TimelogCreateProject for application/json ContentType.
type TimelogCreateProjectJSONRequestBody TimelogCreateProjectJSONBody

// VersionsCreateJSONRequestBody defines body for VersionsCreate for application/json ContentType.
type VersionsCreateJSONRequestBody VersionsCreateJSONBody

// WikiUpdatePatchJSONRequestBody defines body for WikiUpdatePatch for application/json ContentType.
type WikiUpdatePatchJSONRequestBody WikiUpdatePatchJSONBody

// WikiUpdatePutJSONRequestBody defines body for WikiUpdatePut for application/json ContentType.
type WikiUpdatePutJSONRequestBody WikiUpdatePutJSONBody

// TimelogCreateJSONRequestBody defines body for TimelogCreate for application/json ContentType.
type TimelogCreateJSONRequestBody TimelogCreateJSONBody

// TimelogUpdatePatchJSONRequestBody defines body for TimelogUpdatePatch for application/json ContentType.
type TimelogUpdatePatchJSONRequestBody TimelogUpdatePatchJSONBody

// TimelogUpdatePutJSONRequestBody defines body for TimelogUpdatePut for application/json ContentType.
type TimelogUpdatePutJSONRequestBody TimelogUpdatePutJSONBody

// UsersCreateJSONRequestBody defines body for UsersCreate for application/json ContentType.
type UsersCreateJSONRequestBody UsersCreateJSONBody

// UsersUpdatePatchJSONRequestBody defines body for UsersUpdatePatch for application/json ContentType.
type UsersUpdatePatchJSONRequestBody UsersUpdatePatchJSONBody

// UsersUpdatePutJSONRequestBody defines body for UsersUpdatePut for application/json ContentType.
type UsersUpdatePutJSONRequestBody UsersUpdatePutJSONBody

// VersionsUpdatePatchJSONRequestBody defines body for VersionsUpdatePatch for application/json ContentType.
type VersionsUpdatePatchJSONRequestBody VersionsUpdatePatchJSONBody

// VersionsUpdatePutJSONRequestBody defines body for VersionsUpdatePut for application/json ContentType.
type VersionsUpdatePutJSONRequestBody VersionsUpdatePutJSONBody

// WatchersCreateJSONRequestBody defines body for WatchersCreate for application/json ContentType.
type WatchersCreateJSONRequestBody WatchersCreateJSONBody

// Getter for additional properties for IssuesIndexCsvParams_Query. Returns the specified
// element and whether it was found
func (a IssuesIndexCsvParams_Query) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for IssuesIndexCsvParams_Query
func (a *IssuesIndexCsvParams_Query) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for IssuesIndexCsvParams_Query to handle AdditionalProperties
func (a *IssuesIndexCsvParams_Query) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["any_searchable"]; found {
		err = json.Unmarshal(raw, &a.AnySearchable)
		if err != nil {
			return fmt.Errorf("error reading 'any_searchable': %w", err)
		}
		delete(object, "any_searchable")
	}

	if raw, found := object["assigned_to_id"]; found {
		err = json.Unmarshal(raw, &a.AssignedToId)
		if err != nil {
			return fmt.Errorf("error reading 'assigned_to_id': %w", err)
		}
		delete(object, "assigned_to_id")
	}

	if raw, found := object["assigned_to_role"]; found {
		err = json.Unmarshal(raw, &a.AssignedToRole)
		if err != nil {
			return fmt.Errorf("error reading 'assigned_to_role': %w", err)
		}
		delete(object, "assigned_to_role")
	}

	if raw, found := object["attachment"]; found {
		err = json.Unmarshal(raw, &a.Attachment)
		if err != nil {
			return fmt.Errorf("error reading 'attachment': %w", err)
		}
		delete(object, "attachment")
	}

	if raw, found := object["attachment_description"]; found {
		err = json.Unmarshal(raw, &a.AttachmentDescription)
		if err != nil {
			return fmt.Errorf("error reading 'attachment_description': %w", err)
		}
		delete(object, "attachment_description")
	}

	if raw, found := object["author.group"]; found {
		err = json.Unmarshal(raw, &a.AuthorGroup)
		if err != nil {
			return fmt.Errorf("error reading 'author.group': %w", err)
		}
		delete(object, "author.group")
	}

	if raw, found := object["author.role"]; found {
		err = json.Unmarshal(raw, &a.AuthorRole)
		if err != nil {
			return fmt.Errorf("error reading 'author.role': %w", err)
		}
		delete(object, "author.role")
	}

	if raw, found := object["author_id"]; found {
		err = json.Unmarshal(raw, &a.AuthorId)
		if err != nil {
			return fmt.Errorf("error reading 'author_id': %w", err)
		}
		delete(object, "author_id")
	}

	if raw, found := object["category_id"]; found {
		err = json.Unmarshal(raw, &a.CategoryId)
		if err != nil {
			return fmt.Errorf("error reading 'category_id': %w", err)
		}
		delete(object, "category_id")
	}

	if raw, found := object["child_id"]; found {
		err = json.Unmarshal(raw, &a.ChildId)
		if err != nil {
			return fmt.Errorf("error reading 'child_id': %w", err)
		}
		delete(object, "child_id")
	}

	if raw, found := object["closed_on"]; found {
		err = json.Unmarshal(raw, &a.ClosedOn)
		if err != nil {
			return fmt.Errorf("error reading 'closed_on': %w", err)
		}
		delete(object, "closed_on")
	}

	if raw, found := object["created_on"]; found {
		err = json.Unmarshal(raw, &a.CreatedOn)
		if err != nil {
			return fmt.Errorf("error reading 'created_on': %w", err)
		}
		delete(object, "created_on")
	}

	if raw, found := object["description"]; found {
		err = json.Unmarshal(raw, &a.Description)
		if err != nil {
			return fmt.Errorf("error reading 'description': %w", err)
		}
		delete(object, "description")
	}

	if raw, found := object["done_ratio"]; found {
		err = json.Unmarshal(raw, &a.DoneRatio)
		if err != nil {
			return fmt.Errorf("error reading 'done_ratio': %w", err)
		}
		delete(object, "done_ratio")
	}

	if raw, found := object["due_date"]; found {
		err = json.Unmarshal(raw, &a.DueDate)
		if err != nil {
			return fmt.Errorf("error reading 'due_date': %w", err)
		}
		delete(object, "due_date")
	}

	if raw, found := object["estimated_hours"]; found {
		err = json.Unmarshal(raw, &a.EstimatedHours)
		if err != nil {
			return fmt.Errorf("error reading 'estimated_hours': %w", err)
		}
		delete(object, "estimated_hours")
	}

	if raw, found := object["fixed_version.due_date"]; found {
		err = json.Unmarshal(raw, &a.FixedVersionDueDate)
		if err != nil {
			return fmt.Errorf("error reading 'fixed_version.due_date': %w", err)
		}
		delete(object, "fixed_version.due_date")
	}

	if raw, found := object["fixed_version.status"]; found {
		err = json.Unmarshal(raw, &a.FixedVersionStatus)
		if err != nil {
			return fmt.Errorf("error reading 'fixed_version.status': %w", err)
		}
		delete(object, "fixed_version.status")
	}

	if raw, found := object["fixed_version_id"]; found {
		err = json.Unmarshal(raw, &a.FixedVersionId)
		if err != nil {
			return fmt.Errorf("error reading 'fixed_version_id': %w", err)
		}
		delete(object, "fixed_version_id")
	}

	if raw, found := object["is_private"]; found {
		err = json.Unmarshal(raw, &a.IsPrivate)
		if err != nil {
			return fmt.Errorf("error reading 'is_private': %w", err)
		}
		delete(object, "is_private")
	}

	if raw, found := object["issue_id"]; found {
		err = json.Unmarshal(raw, &a.IssueId)
		if err != nil {
			return fmt.Errorf("error reading 'issue_id': %w", err)
		}
		delete(object, "issue_id")
	}

	if raw, found := object["last_updated_by"]; found {
		err = json.Unmarshal(raw, &a.LastUpdatedBy)
		if err != nil {
			return fmt.Errorf("error reading 'last_updated_by': %w", err)
		}
		delete(object, "last_updated_by")
	}

	if raw, found := object["member_of_group"]; found {
		err = json.Unmarshal(raw, &a.MemberOfGroup)
		if err != nil {
			return fmt.Errorf("error reading 'member_of_group': %w", err)
		}
		delete(object, "member_of_group")
	}

	if raw, found := object["notes"]; found {
		err = json.Unmarshal(raw, &a.Notes)
		if err != nil {
			return fmt.Errorf("error reading 'notes': %w", err)
		}
		delete(object, "notes")
	}

	if raw, found := object["parent_id"]; found {
		err = json.Unmarshal(raw, &a.ParentId)
		if err != nil {
			return fmt.Errorf("error reading 'parent_id': %w", err)
		}
		delete(object, "parent_id")
	}

	if raw, found := object["priority_id"]; found {
		err = json.Unmarshal(raw, &a.PriorityId)
		if err != nil {
			return fmt.Errorf("error reading 'priority_id': %w", err)
		}
		delete(object, "priority_id")
	}

	if raw, found := object["project.status"]; found {
		err = json.Unmarshal(raw, &a.ProjectStatus)
		if err != nil {
			return fmt.Errorf("error reading 'project.status': %w", err)
		}
		delete(object, "project.status")
	}

	if raw, found := object["project_id"]; found {
		err = json.Unmarshal(raw, &a.ProjectId)
		if err != nil {
			return fmt.Errorf("error reading 'project_id': %w", err)
		}
		delete(object, "project_id")
	}

	if raw, found := object["relation_type"]; found {
		err = json.Unmarshal(raw, &a.RelationType)
		if err != nil {
			return fmt.Errorf("error reading 'relation_type': %w", err)
		}
		delete(object, "relation_type")
	}

	if raw, found := object["spent_time"]; found {
		err = json.Unmarshal(raw, &a.SpentTime)
		if err != nil {
			return fmt.Errorf("error reading 'spent_time': %w", err)
		}
		delete(object, "spent_time")
	}

	if raw, found := object["start_date"]; found {
		err = json.Unmarshal(raw, &a.StartDate)
		if err != nil {
			return fmt.Errorf("error reading 'start_date': %w", err)
		}
		delete(object, "start_date")
	}

	if raw, found := object["status_id"]; found {
		err = json.Unmarshal(raw, &a.StatusId)
		if err != nil {
			return fmt.Errorf("error reading 'status_id': %w", err)
		}
		delete(object, "status_id")
	}

	if raw, found := object["subject"]; found {
		err = json.Unmarshal(raw, &a.Subject)
		if err != nil {
			return fmt.Errorf("error reading 'subject': %w", err)
		}
		delete(object, "subject")
	}

	if raw, found := object["subproject_id"]; found {
		err = json.Unmarshal(raw, &a.SubprojectId)
		if err != nil {
			return fmt.Errorf("error reading 'subproject_id': %w", err)
		}
		delete(object, "subproject_id")
	}

	if raw, found := object["tracker_id"]; found {
		err = json.Unmarshal(raw, &a.TrackerId)
		if err != nil {
			return fmt.Errorf("error reading 'tracker_id': %w", err)
		}
		delete(object, "tracker_id")
	}

	if raw, found := object["updated_by"]; found {
		err = json.Unmarshal(raw, &a.UpdatedBy)
		if err != nil {
			return fmt.Errorf("error reading 'updated_by': %w", err)
		}
		delete(object, "updated_by")
	}

	if raw, found := object["updated_on"]; found {
		err = json.Unmarshal(raw, &a.UpdatedOn)
		if err != nil {
			return fmt.Errorf("error reading 'updated_on': %w", err)
		}
		delete(object, "updated_on")
	}

	if raw, found := object["watcher_id"]; found {
		err = json.Unmarshal(raw, &a.WatcherId)
		if err != nil {
			return fmt.Errorf("error reading 'watcher_id': %w", err)
		}
		delete(object, "watcher_id")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for IssuesIndexCsvParams_Query to handle AdditionalProperties
func (a IssuesIndexCsvParams_Query) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.AnySearchable != nil {
		object["any_searchable"], err = json.Marshal(a.AnySearchable)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'any_searchable': %w", err)
		}
	}

	if a.AssignedToId != nil {
		object["assigned_to_id"], err = json.Marshal(a.AssignedToId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'assigned_to_id': %w", err)
		}
	}

	if a.AssignedToRole != nil {
		object["assigned_to_role"], err = json.Marshal(a.AssignedToRole)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'assigned_to_role': %w", err)
		}
	}

	if a.Attachment != nil {
		object["attachment"], err = json.Marshal(a.Attachment)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'attachment': %w", err)
		}
	}

	if a.AttachmentDescription != nil {
		object["attachment_description"], err = json.Marshal(a.AttachmentDescription)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'attachment_description': %w", err)
		}
	}

	if a.AuthorGroup != nil {
		object["author.group"], err = json.Marshal(a.AuthorGroup)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'author.group': %w", err)
		}
	}

	if a.AuthorRole != nil {
		object["author.role"], err = json.Marshal(a.AuthorRole)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'author.role': %w", err)
		}
	}

	if a.AuthorId != nil {
		object["author_id"], err = json.Marshal(a.AuthorId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'author_id': %w", err)
		}
	}

	if a.CategoryId != nil {
		object["category_id"], err = json.Marshal(a.CategoryId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'category_id': %w", err)
		}
	}

	if a.ChildId != nil {
		object["child_id"], err = json.Marshal(a.ChildId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'child_id': %w", err)
		}
	}

	if a.ClosedOn != nil {
		object["closed_on"], err = json.Marshal(a.ClosedOn)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'closed_on': %w", err)
		}
	}

	if a.CreatedOn != nil {
		object["created_on"], err = json.Marshal(a.CreatedOn)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'created_on': %w", err)
		}
	}

	if a.Description != nil {
		object["description"], err = json.Marshal(a.Description)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'description': %w", err)
		}
	}

	if a.DoneRatio != nil {
		object["done_ratio"], err = json.Marshal(a.DoneRatio)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'done_ratio': %w", err)
		}
	}

	if a.DueDate != nil {
		object["due_date"], err = json.Marshal(a.DueDate)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'due_date': %w", err)
		}
	}

	if a.EstimatedHours != nil {
		object["estimated_hours"], err = json.Marshal(a.EstimatedHours)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'estimated_hours': %w", err)
		}
	}

	if a.FixedVersionDueDate != nil {
		object["fixed_version.due_date"], err = json.Marshal(a.FixedVersionDueDate)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'fixed_version.due_date': %w", err)
		}
	}

	if a.FixedVersionStatus != nil {
		object["fixed_version.status"], err = json.Marshal(a.FixedVersionStatus)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'fixed_version.status': %w", err)
		}
	}

	if a.FixedVersionId != nil {
		object["fixed_version_id"], err = json.Marshal(a.FixedVersionId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'fixed_version_id': %w", err)
		}
	}

	if a.IsPrivate != nil {
		object["is_private"], err = json.Marshal(a.IsPrivate)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'is_private': %w", err)
		}
	}

	if a.IssueId != nil {
		object["issue_id"], err = json.Marshal(a.IssueId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'issue_id': %w", err)
		}
	}

	if a.LastUpdatedBy != nil {
		object["last_updated_by"], err = json.Marshal(a.LastUpdatedBy)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'last_updated_by': %w", err)
		}
	}

	if a.MemberOfGroup != nil {
		object["member_of_group"], err = json.Marshal(a.MemberOfGroup)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'member_of_group': %w", err)
		}
	}

	if a.Notes != nil {
		object["notes"], err = json.Marshal(a.Notes)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'notes': %w", err)
		}
	}

	if a.ParentId != nil {
		object["parent_id"], err = json.Marshal(a.ParentId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'parent_id': %w", err)
		}
	}

	if a.PriorityId != nil {
		object["priority_id"], err = json.Marshal(a.PriorityId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'priority_id': %w", err)
		}
	}

	if a.ProjectStatus != nil {
		object["project.status"], err = json.Marshal(a.ProjectStatus)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'project.status': %w", err)
		}
	}

	if a.ProjectId != nil {
		object["project_id"], err = json.Marshal(a.ProjectId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'project_id': %w", err)
		}
	}

	if a.RelationType != nil {
		object["relation_type"], err = json.Marshal(a.RelationType)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'relation_type': %w", err)
		}
	}

	if a.SpentTime != nil {
		object["spent_time"], err = json.Marshal(a.SpentTime)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'spent_time': %w", err)
		}
	}

	if a.StartDate != nil {
		object["start_date"], err = json.Marshal(a.StartDate)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'start_date': %w", err)
		}
	}

	if a.StatusId != nil {
		object["status_id"], err = json.Marshal(a.StatusId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'status_id': %w", err)
		}
	}

	if a.Subject != nil {
		object["subject"], err = json.Marshal(a.Subject)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'subject': %w", err)
		}
	}

	if a.SubprojectId != nil {
		object["subproject_id"], err = json.Marshal(a.SubprojectId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'subproject_id': %w", err)
		}
	}

	if a.TrackerId != nil {
		object["tracker_id"], err = json.Marshal(a.TrackerId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'tracker_id': %w", err)
		}
	}

	if a.UpdatedBy != nil {
		object["updated_by"], err = json.Marshal(a.UpdatedBy)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'updated_by': %w", err)
		}
	}

	if a.UpdatedOn != nil {
		object["updated_on"], err = json.Marshal(a.UpdatedOn)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'updated_on': %w", err)
		}
	}

	if a.WatcherId != nil {
		object["watcher_id"], err = json.Marshal(a.WatcherId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'watcher_id': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for IssuesIndexParams_Query. Returns the specified
// element and whether it was found
func (a IssuesIndexParams_Query) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for IssuesIndexParams_Query
func (a *IssuesIndexParams_Query) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for IssuesIndexParams_Query to handle AdditionalProperties
func (a *IssuesIndexParams_Query) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["any_searchable"]; found {
		err = json.Unmarshal(raw, &a.AnySearchable)
		if err != nil {
			return fmt.Errorf("error reading 'any_searchable': %w", err)
		}
		delete(object, "any_searchable")
	}

	if raw, found := object["assigned_to_id"]; found {
		err = json.Unmarshal(raw, &a.AssignedToId)
		if err != nil {
			return fmt.Errorf("error reading 'assigned_to_id': %w", err)
		}
		delete(object, "assigned_to_id")
	}

	if raw, found := object["assigned_to_role"]; found {
		err = json.Unmarshal(raw, &a.AssignedToRole)
		if err != nil {
			return fmt.Errorf("error reading 'assigned_to_role': %w", err)
		}
		delete(object, "assigned_to_role")
	}

	if raw, found := object["attachment"]; found {
		err = json.Unmarshal(raw, &a.Attachment)
		if err != nil {
			return fmt.Errorf("error reading 'attachment': %w", err)
		}
		delete(object, "attachment")
	}

	if raw, found := object["attachment_description"]; found {
		err = json.Unmarshal(raw, &a.AttachmentDescription)
		if err != nil {
			return fmt.Errorf("error reading 'attachment_description': %w", err)
		}
		delete(object, "attachment_description")
	}

	if raw, found := object["author.group"]; found {
		err = json.Unmarshal(raw, &a.AuthorGroup)
		if err != nil {
			return fmt.Errorf("error reading 'author.group': %w", err)
		}
		delete(object, "author.group")
	}

	if raw, found := object["author.role"]; found {
		err = json.Unmarshal(raw, &a.AuthorRole)
		if err != nil {
			return fmt.Errorf("error reading 'author.role': %w", err)
		}
		delete(object, "author.role")
	}

	if raw, found := object["author_id"]; found {
		err = json.Unmarshal(raw, &a.AuthorId)
		if err != nil {
			return fmt.Errorf("error reading 'author_id': %w", err)
		}
		delete(object, "author_id")
	}

	if raw, found := object["category_id"]; found {
		err = json.Unmarshal(raw, &a.CategoryId)
		if err != nil {
			return fmt.Errorf("error reading 'category_id': %w", err)
		}
		delete(object, "category_id")
	}

	if raw, found := object["child_id"]; found {
		err = json.Unmarshal(raw, &a.ChildId)
		if err != nil {
			return fmt.Errorf("error reading 'child_id': %w", err)
		}
		delete(object, "child_id")
	}

	if raw, found := object["closed_on"]; found {
		err = json.Unmarshal(raw, &a.ClosedOn)
		if err != nil {
			return fmt.Errorf("error reading 'closed_on': %w", err)
		}
		delete(object, "closed_on")
	}

	if raw, found := object["created_on"]; found {
		err = json.Unmarshal(raw, &a.CreatedOn)
		if err != nil {
			return fmt.Errorf("error reading 'created_on': %w", err)
		}
		delete(object, "created_on")
	}

	if raw, found := object["description"]; found {
		err = json.Unmarshal(raw, &a.Description)
		if err != nil {
			return fmt.Errorf("error reading 'description': %w", err)
		}
		delete(object, "description")
	}

	if raw, found := object["done_ratio"]; found {
		err = json.Unmarshal(raw, &a.DoneRatio)
		if err != nil {
			return fmt.Errorf("error reading 'done_ratio': %w", err)
		}
		delete(object, "done_ratio")
	}

	if raw, found := object["due_date"]; found {
		err = json.Unmarshal(raw, &a.DueDate)
		if err != nil {
			return fmt.Errorf("error reading 'due_date': %w", err)
		}
		delete(object, "due_date")
	}

	if raw, found := object["estimated_hours"]; found {
		err = json.Unmarshal(raw, &a.EstimatedHours)
		if err != nil {
			return fmt.Errorf("error reading 'estimated_hours': %w", err)
		}
		delete(object, "estimated_hours")
	}

	if raw, found := object["fixed_version.due_date"]; found {
		err = json.Unmarshal(raw, &a.FixedVersionDueDate)
		if err != nil {
			return fmt.Errorf("error reading 'fixed_version.due_date': %w", err)
		}
		delete(object, "fixed_version.due_date")
	}

	if raw, found := object["fixed_version.status"]; found {
		err = json.Unmarshal(raw, &a.FixedVersionStatus)
		if err != nil {
			return fmt.Errorf("error reading 'fixed_version.status': %w", err)
		}
		delete(object, "fixed_version.status")
	}

	if raw, found := object["fixed_version_id"]; found {
		err = json.Unmarshal(raw, &a.FixedVersionId)
		if err != nil {
			return fmt.Errorf("error reading 'fixed_version_id': %w", err)
		}
		delete(object, "fixed_version_id")
	}

	if raw, found := object["is_private"]; found {
		err = json.Unmarshal(raw, &a.IsPrivate)
		if err != nil {
			return fmt.Errorf("error reading 'is_private': %w", err)
		}
		delete(object, "is_private")
	}

	if raw, found := object["issue_id"]; found {
		err = json.Unmarshal(raw, &a.IssueId)
		if err != nil {
			return fmt.Errorf("error reading 'issue_id': %w", err)
		}
		delete(object, "issue_id")
	}

	if raw, found := object["last_updated_by"]; found {
		err = json.Unmarshal(raw, &a.LastUpdatedBy)
		if err != nil {
			return fmt.Errorf("error reading 'last_updated_by': %w", err)
		}
		delete(object, "last_updated_by")
	}

	if raw, found := object["member_of_group"]; found {
		err = json.Unmarshal(raw, &a.MemberOfGroup)
		if err != nil {
			return fmt.Errorf("error reading 'member_of_group': %w", err)
		}
		delete(object, "member_of_group")
	}

	if raw, found := object["notes"]; found {
		err = json.Unmarshal(raw, &a.Notes)
		if err != nil {
			return fmt.Errorf("error reading 'notes': %w", err)
		}
		delete(object, "notes")
	}

	if raw, found := object["parent_id"]; found {
		err = json.Unmarshal(raw, &a.ParentId)
		if err != nil {
			return fmt.Errorf("error reading 'parent_id': %w", err)
		}
		delete(object, "parent_id")
	}

	if raw, found := object["priority_id"]; found {
		err = json.Unmarshal(raw, &a.PriorityId)
		if err != nil {
			return fmt.Errorf("error reading 'priority_id': %w", err)
		}
		delete(object, "priority_id")
	}

	if raw, found := object["project.status"]; found {
		err = json.Unmarshal(raw, &a.ProjectStatus)
		if err != nil {
			return fmt.Errorf("error reading 'project.status': %w", err)
		}
		delete(object, "project.status")
	}

	if raw, found := object["project_id"]; found {
		err = json.Unmarshal(raw, &a.ProjectId)
		if err != nil {
			return fmt.Errorf("error reading 'project_id': %w", err)
		}
		delete(object, "project_id")
	}

	if raw, found := object["relation_type"]; found {
		err = json.Unmarshal(raw, &a.RelationType)
		if err != nil {
			return fmt.Errorf("error reading 'relation_type': %w", err)
		}
		delete(object, "relation_type")
	}

	if raw, found := object["spent_time"]; found {
		err = json.Unmarshal(raw, &a.SpentTime)
		if err != nil {
			return fmt.Errorf("error reading 'spent_time': %w", err)
		}
		delete(object, "spent_time")
	}

	if raw, found := object["start_date"]; found {
		err = json.Unmarshal(raw, &a.StartDate)
		if err != nil {
			return fmt.Errorf("error reading 'start_date': %w", err)
		}
		delete(object, "start_date")
	}

	if raw, found := object["status_id"]; found {
		err = json.Unmarshal(raw, &a.StatusId)
		if err != nil {
			return fmt.Errorf("error reading 'status_id': %w", err)
		}
		delete(object, "status_id")
	}

	if raw, found := object["subject"]; found {
		err = json.Unmarshal(raw, &a.Subject)
		if err != nil {
			return fmt.Errorf("error reading 'subject': %w", err)
		}
		delete(object, "subject")
	}

	if raw, found := object["subproject_id"]; found {
		err = json.Unmarshal(raw, &a.SubprojectId)
		if err != nil {
			return fmt.Errorf("error reading 'subproject_id': %w", err)
		}
		delete(object, "subproject_id")
	}

	if raw, found := object["tracker_id"]; found {
		err = json.Unmarshal(raw, &a.TrackerId)
		if err != nil {
			return fmt.Errorf("error reading 'tracker_id': %w", err)
		}
		delete(object, "tracker_id")
	}

	if raw, found := object["updated_by"]; found {
		err = json.Unmarshal(raw, &a.UpdatedBy)
		if err != nil {
			return fmt.Errorf("error reading 'updated_by': %w", err)
		}
		delete(object, "updated_by")
	}

	if raw, found := object["updated_on"]; found {
		err = json.Unmarshal(raw, &a.UpdatedOn)
		if err != nil {
			return fmt.Errorf("error reading 'updated_on': %w", err)
		}
		delete(object, "updated_on")
	}

	if raw, found := object["watcher_id"]; found {
		err = json.Unmarshal(raw, &a.WatcherId)
		if err != nil {
			return fmt.Errorf("error reading 'watcher_id': %w", err)
		}
		delete(object, "watcher_id")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for IssuesIndexParams_Query to handle AdditionalProperties
func (a IssuesIndexParams_Query) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.AnySearchable != nil {
		object["any_searchable"], err = json.Marshal(a.AnySearchable)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'any_searchable': %w", err)
		}
	}

	if a.AssignedToId != nil {
		object["assigned_to_id"], err = json.Marshal(a.AssignedToId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'assigned_to_id': %w", err)
		}
	}

	if a.AssignedToRole != nil {
		object["assigned_to_role"], err = json.Marshal(a.AssignedToRole)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'assigned_to_role': %w", err)
		}
	}

	if a.Attachment != nil {
		object["attachment"], err = json.Marshal(a.Attachment)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'attachment': %w", err)
		}
	}

	if a.AttachmentDescription != nil {
		object["attachment_description"], err = json.Marshal(a.AttachmentDescription)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'attachment_description': %w", err)
		}
	}

	if a.AuthorGroup != nil {
		object["author.group"], err = json.Marshal(a.AuthorGroup)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'author.group': %w", err)
		}
	}

	if a.AuthorRole != nil {
		object["author.role"], err = json.Marshal(a.AuthorRole)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'author.role': %w", err)
		}
	}

	if a.AuthorId != nil {
		object["author_id"], err = json.Marshal(a.AuthorId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'author_id': %w", err)
		}
	}

	if a.CategoryId != nil {
		object["category_id"], err = json.Marshal(a.CategoryId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'category_id': %w", err)
		}
	}

	if a.ChildId != nil {
		object["child_id"], err = json.Marshal(a.ChildId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'child_id': %w", err)
		}
	}

	if a.ClosedOn != nil {
		object["closed_on"], err = json.Marshal(a.ClosedOn)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'closed_on': %w", err)
		}
	}

	if a.CreatedOn != nil {
		object["created_on"], err = json.Marshal(a.CreatedOn)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'created_on': %w", err)
		}
	}

	if a.Description != nil {
		object["description"], err = json.Marshal(a.Description)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'description': %w", err)
		}
	}

	if a.DoneRatio != nil {
		object["done_ratio"], err = json.Marshal(a.DoneRatio)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'done_ratio': %w", err)
		}
	}

	if a.DueDate != nil {
		object["due_date"], err = json.Marshal(a.DueDate)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'due_date': %w", err)
		}
	}

	if a.EstimatedHours != nil {
		object["estimated_hours"], err = json.Marshal(a.EstimatedHours)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'estimated_hours': %w", err)
		}
	}

	if a.FixedVersionDueDate != nil {
		object["fixed_version.due_date"], err = json.Marshal(a.FixedVersionDueDate)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'fixed_version.due_date': %w", err)
		}
	}

	if a.FixedVersionStatus != nil {
		object["fixed_version.status"], err = json.Marshal(a.FixedVersionStatus)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'fixed_version.status': %w", err)
		}
	}

	if a.FixedVersionId != nil {
		object["fixed_version_id"], err = json.Marshal(a.FixedVersionId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'fixed_version_id': %w", err)
		}
	}

	if a.IsPrivate != nil {
		object["is_private"], err = json.Marshal(a.IsPrivate)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'is_private': %w", err)
		}
	}

	if a.IssueId != nil {
		object["issue_id"], err = json.Marshal(a.IssueId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'issue_id': %w", err)
		}
	}

	if a.LastUpdatedBy != nil {
		object["last_updated_by"], err = json.Marshal(a.LastUpdatedBy)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'last_updated_by': %w", err)
		}
	}

	if a.MemberOfGroup != nil {
		object["member_of_group"], err = json.Marshal(a.MemberOfGroup)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'member_of_group': %w", err)
		}
	}

	if a.Notes != nil {
		object["notes"], err = json.Marshal(a.Notes)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'notes': %w", err)
		}
	}

	if a.ParentId != nil {
		object["parent_id"], err = json.Marshal(a.ParentId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'parent_id': %w", err)
		}
	}

	if a.PriorityId != nil {
		object["priority_id"], err = json.Marshal(a.PriorityId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'priority_id': %w", err)
		}
	}

	if a.ProjectStatus != nil {
		object["project.status"], err = json.Marshal(a.ProjectStatus)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'project.status': %w", err)
		}
	}

	if a.ProjectId != nil {
		object["project_id"], err = json.Marshal(a.ProjectId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'project_id': %w", err)
		}
	}

	if a.RelationType != nil {
		object["relation_type"], err = json.Marshal(a.RelationType)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'relation_type': %w", err)
		}
	}

	if a.SpentTime != nil {
		object["spent_time"], err = json.Marshal(a.SpentTime)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'spent_time': %w", err)
		}
	}

	if a.StartDate != nil {
		object["start_date"], err = json.Marshal(a.StartDate)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'start_date': %w", err)
		}
	}

	if a.StatusId != nil {
		object["status_id"], err = json.Marshal(a.StatusId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'status_id': %w", err)
		}
	}

	if a.Subject != nil {
		object["subject"], err = json.Marshal(a.Subject)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'subject': %w", err)
		}
	}

	if a.SubprojectId != nil {
		object["subproject_id"], err = json.Marshal(a.SubprojectId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'subproject_id': %w", err)
		}
	}

	if a.TrackerId != nil {
		object["tracker_id"], err = json.Marshal(a.TrackerId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'tracker_id': %w", err)
		}
	}

	if a.UpdatedBy != nil {
		object["updated_by"], err = json.Marshal(a.UpdatedBy)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'updated_by': %w", err)
		}
	}

	if a.UpdatedOn != nil {
		object["updated_on"], err = json.Marshal(a.UpdatedOn)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'updated_on': %w", err)
		}
	}

	if a.WatcherId != nil {
		object["watcher_id"], err = json.Marshal(a.WatcherId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'watcher_id': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for IssuesIndexPdfParams_Query. Returns the specified
// element and whether it was found
func (a IssuesIndexPdfParams_Query) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for IssuesIndexPdfParams_Query
func (a *IssuesIndexPdfParams_Query) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for IssuesIndexPdfParams_Query to handle AdditionalProperties
func (a *IssuesIndexPdfParams_Query) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["any_searchable"]; found {
		err = json.Unmarshal(raw, &a.AnySearchable)
		if err != nil {
			return fmt.Errorf("error reading 'any_searchable': %w", err)
		}
		delete(object, "any_searchable")
	}

	if raw, found := object["assigned_to_id"]; found {
		err = json.Unmarshal(raw, &a.AssignedToId)
		if err != nil {
			return fmt.Errorf("error reading 'assigned_to_id': %w", err)
		}
		delete(object, "assigned_to_id")
	}

	if raw, found := object["assigned_to_role"]; found {
		err = json.Unmarshal(raw, &a.AssignedToRole)
		if err != nil {
			return fmt.Errorf("error reading 'assigned_to_role': %w", err)
		}
		delete(object, "assigned_to_role")
	}

	if raw, found := object["attachment"]; found {
		err = json.Unmarshal(raw, &a.Attachment)
		if err != nil {
			return fmt.Errorf("error reading 'attachment': %w", err)
		}
		delete(object, "attachment")
	}

	if raw, found := object["attachment_description"]; found {
		err = json.Unmarshal(raw, &a.AttachmentDescription)
		if err != nil {
			return fmt.Errorf("error reading 'attachment_description': %w", err)
		}
		delete(object, "attachment_description")
	}

	if raw, found := object["author.group"]; found {
		err = json.Unmarshal(raw, &a.AuthorGroup)
		if err != nil {
			return fmt.Errorf("error reading 'author.group': %w", err)
		}
		delete(object, "author.group")
	}

	if raw, found := object["author.role"]; found {
		err = json.Unmarshal(raw, &a.AuthorRole)
		if err != nil {
			return fmt.Errorf("error reading 'author.role': %w", err)
		}
		delete(object, "author.role")
	}

	if raw, found := object["author_id"]; found {
		err = json.Unmarshal(raw, &a.AuthorId)
		if err != nil {
			return fmt.Errorf("error reading 'author_id': %w", err)
		}
		delete(object, "author_id")
	}

	if raw, found := object["category_id"]; found {
		err = json.Unmarshal(raw, &a.CategoryId)
		if err != nil {
			return fmt.Errorf("error reading 'category_id': %w", err)
		}
		delete(object, "category_id")
	}

	if raw, found := object["child_id"]; found {
		err = json.Unmarshal(raw, &a.ChildId)
		if err != nil {
			return fmt.Errorf("error reading 'child_id': %w", err)
		}
		delete(object, "child_id")
	}

	if raw, found := object["closed_on"]; found {
		err = json.Unmarshal(raw, &a.ClosedOn)
		if err != nil {
			return fmt.Errorf("error reading 'closed_on': %w", err)
		}
		delete(object, "closed_on")
	}

	if raw, found := object["created_on"]; found {
		err = json.Unmarshal(raw, &a.CreatedOn)
		if err != nil {
			return fmt.Errorf("error reading 'created_on': %w", err)
		}
		delete(object, "created_on")
	}

	if raw, found := object["description"]; found {
		err = json.Unmarshal(raw, &a.Description)
		if err != nil {
			return fmt.Errorf("error reading 'description': %w", err)
		}
		delete(object, "description")
	}

	if raw, found := object["done_ratio"]; found {
		err = json.Unmarshal(raw, &a.DoneRatio)
		if err != nil {
			return fmt.Errorf("error reading 'done_ratio': %w", err)
		}
		delete(object, "done_ratio")
	}

	if raw, found := object["due_date"]; found {
		err = json.Unmarshal(raw, &a.DueDate)
		if err != nil {
			return fmt.Errorf("error reading 'due_date': %w", err)
		}
		delete(object, "due_date")
	}

	if raw, found := object["estimated_hours"]; found {
		err = json.Unmarshal(raw, &a.EstimatedHours)
		if err != nil {
			return fmt.Errorf("error reading 'estimated_hours': %w", err)
		}
		delete(object, "estimated_hours")
	}

	if raw, found := object["fixed_version.due_date"]; found {
		err = json.Unmarshal(raw, &a.FixedVersionDueDate)
		if err != nil {
			return fmt.Errorf("error reading 'fixed_version.due_date': %w", err)
		}
		delete(object, "fixed_version.due_date")
	}

	if raw, found := object["fixed_version.status"]; found {
		err = json.Unmarshal(raw, &a.FixedVersionStatus)
		if err != nil {
			return fmt.Errorf("error reading 'fixed_version.status': %w", err)
		}
		delete(object, "fixed_version.status")
	}

	if raw, found := object["fixed_version_id"]; found {
		err = json.Unmarshal(raw, &a.FixedVersionId)
		if err != nil {
			return fmt.Errorf("error reading 'fixed_version_id': %w", err)
		}
		delete(object, "fixed_version_id")
	}

	if raw, found := object["is_private"]; found {
		err = json.Unmarshal(raw, &a.IsPrivate)
		if err != nil {
			return fmt.Errorf("error reading 'is_private': %w", err)
		}
		delete(object, "is_private")
	}

	if raw, found := object["issue_id"]; found {
		err = json.Unmarshal(raw, &a.IssueId)
		if err != nil {
			return fmt.Errorf("error reading 'issue_id': %w", err)
		}
		delete(object, "issue_id")
	}

	if raw, found := object["last_updated_by"]; found {
		err = json.Unmarshal(raw, &a.LastUpdatedBy)
		if err != nil {
			return fmt.Errorf("error reading 'last_updated_by': %w", err)
		}
		delete(object, "last_updated_by")
	}

	if raw, found := object["member_of_group"]; found {
		err = json.Unmarshal(raw, &a.MemberOfGroup)
		if err != nil {
			return fmt.Errorf("error reading 'member_of_group': %w", err)
		}
		delete(object, "member_of_group")
	}

	if raw, found := object["notes"]; found {
		err = json.Unmarshal(raw, &a.Notes)
		if err != nil {
			return fmt.Errorf("error reading 'notes': %w", err)
		}
		delete(object, "notes")
	}

	if raw, found := object["parent_id"]; found {
		err = json.Unmarshal(raw, &a.ParentId)
		if err != nil {
			return fmt.Errorf("error reading 'parent_id': %w", err)
		}
		delete(object, "parent_id")
	}

	if raw, found := object["priority_id"]; found {
		err = json.Unmarshal(raw, &a.PriorityId)
		if err != nil {
			return fmt.Errorf("error reading 'priority_id': %w", err)
		}
		delete(object, "priority_id")
	}

	if raw, found := object["project.status"]; found {
		err = json.Unmarshal(raw, &a.ProjectStatus)
		if err != nil {
			return fmt.Errorf("error reading 'project.status': %w", err)
		}
		delete(object, "project.status")
	}

	if raw, found := object["project_id"]; found {
		err = json.Unmarshal(raw, &a.ProjectId)
		if err != nil {
			return fmt.Errorf("error reading 'project_id': %w", err)
		}
		delete(object, "project_id")
	}

	if raw, found := object["relation_type"]; found {
		err = json.Unmarshal(raw, &a.RelationType)
		if err != nil {
			return fmt.Errorf("error reading 'relation_type': %w", err)
		}
		delete(object, "relation_type")
	}

	if raw, found := object["spent_time"]; found {
		err = json.Unmarshal(raw, &a.SpentTime)
		if err != nil {
			return fmt.Errorf("error reading 'spent_time': %w", err)
		}
		delete(object, "spent_time")
	}

	if raw, found := object["start_date"]; found {
		err = json.Unmarshal(raw, &a.StartDate)
		if err != nil {
			return fmt.Errorf("error reading 'start_date': %w", err)
		}
		delete(object, "start_date")
	}

	if raw, found := object["status_id"]; found {
		err = json.Unmarshal(raw, &a.StatusId)
		if err != nil {
			return fmt.Errorf("error reading 'status_id': %w", err)
		}
		delete(object, "status_id")
	}

	if raw, found := object["subject"]; found {
		err = json.Unmarshal(raw, &a.Subject)
		if err != nil {
			return fmt.Errorf("error reading 'subject': %w", err)
		}
		delete(object, "subject")
	}

	if raw, found := object["subproject_id"]; found {
		err = json.Unmarshal(raw, &a.SubprojectId)
		if err != nil {
			return fmt.Errorf("error reading 'subproject_id': %w", err)
		}
		delete(object, "subproject_id")
	}

	if raw, found := object["tracker_id"]; found {
		err = json.Unmarshal(raw, &a.TrackerId)
		if err != nil {
			return fmt.Errorf("error reading 'tracker_id': %w", err)
		}
		delete(object, "tracker_id")
	}

	if raw, found := object["updated_by"]; found {
		err = json.Unmarshal(raw, &a.UpdatedBy)
		if err != nil {
			return fmt.Errorf("error reading 'updated_by': %w", err)
		}
		delete(object, "updated_by")
	}

	if raw, found := object["updated_on"]; found {
		err = json.Unmarshal(raw, &a.UpdatedOn)
		if err != nil {
			return fmt.Errorf("error reading 'updated_on': %w", err)
		}
		delete(object, "updated_on")
	}

	if raw, found := object["watcher_id"]; found {
		err = json.Unmarshal(raw, &a.WatcherId)
		if err != nil {
			return fmt.Errorf("error reading 'watcher_id': %w", err)
		}
		delete(object, "watcher_id")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for IssuesIndexPdfParams_Query to handle AdditionalProperties
func (a IssuesIndexPdfParams_Query) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.AnySearchable != nil {
		object["any_searchable"], err = json.Marshal(a.AnySearchable)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'any_searchable': %w", err)
		}
	}

	if a.AssignedToId != nil {
		object["assigned_to_id"], err = json.Marshal(a.AssignedToId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'assigned_to_id': %w", err)
		}
	}

	if a.AssignedToRole != nil {
		object["assigned_to_role"], err = json.Marshal(a.AssignedToRole)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'assigned_to_role': %w", err)
		}
	}

	if a.Attachment != nil {
		object["attachment"], err = json.Marshal(a.Attachment)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'attachment': %w", err)
		}
	}

	if a.AttachmentDescription != nil {
		object["attachment_description"], err = json.Marshal(a.AttachmentDescription)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'attachment_description': %w", err)
		}
	}

	if a.AuthorGroup != nil {
		object["author.group"], err = json.Marshal(a.AuthorGroup)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'author.group': %w", err)
		}
	}

	if a.AuthorRole != nil {
		object["author.role"], err = json.Marshal(a.AuthorRole)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'author.role': %w", err)
		}
	}

	if a.AuthorId != nil {
		object["author_id"], err = json.Marshal(a.AuthorId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'author_id': %w", err)
		}
	}

	if a.CategoryId != nil {
		object["category_id"], err = json.Marshal(a.CategoryId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'category_id': %w", err)
		}
	}

	if a.ChildId != nil {
		object["child_id"], err = json.Marshal(a.ChildId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'child_id': %w", err)
		}
	}

	if a.ClosedOn != nil {
		object["closed_on"], err = json.Marshal(a.ClosedOn)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'closed_on': %w", err)
		}
	}

	if a.CreatedOn != nil {
		object["created_on"], err = json.Marshal(a.CreatedOn)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'created_on': %w", err)
		}
	}

	if a.Description != nil {
		object["description"], err = json.Marshal(a.Description)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'description': %w", err)
		}
	}

	if a.DoneRatio != nil {
		object["done_ratio"], err = json.Marshal(a.DoneRatio)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'done_ratio': %w", err)
		}
	}

	if a.DueDate != nil {
		object["due_date"], err = json.Marshal(a.DueDate)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'due_date': %w", err)
		}
	}

	if a.EstimatedHours != nil {
		object["estimated_hours"], err = json.Marshal(a.EstimatedHours)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'estimated_hours': %w", err)
		}
	}

	if a.FixedVersionDueDate != nil {
		object["fixed_version.due_date"], err = json.Marshal(a.FixedVersionDueDate)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'fixed_version.due_date': %w", err)
		}
	}

	if a.FixedVersionStatus != nil {
		object["fixed_version.status"], err = json.Marshal(a.FixedVersionStatus)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'fixed_version.status': %w", err)
		}
	}

	if a.FixedVersionId != nil {
		object["fixed_version_id"], err = json.Marshal(a.FixedVersionId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'fixed_version_id': %w", err)
		}
	}

	if a.IsPrivate != nil {
		object["is_private"], err = json.Marshal(a.IsPrivate)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'is_private': %w", err)
		}
	}

	if a.IssueId != nil {
		object["issue_id"], err = json.Marshal(a.IssueId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'issue_id': %w", err)
		}
	}

	if a.LastUpdatedBy != nil {
		object["last_updated_by"], err = json.Marshal(a.LastUpdatedBy)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'last_updated_by': %w", err)
		}
	}

	if a.MemberOfGroup != nil {
		object["member_of_group"], err = json.Marshal(a.MemberOfGroup)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'member_of_group': %w", err)
		}
	}

	if a.Notes != nil {
		object["notes"], err = json.Marshal(a.Notes)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'notes': %w", err)
		}
	}

	if a.ParentId != nil {
		object["parent_id"], err = json.Marshal(a.ParentId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'parent_id': %w", err)
		}
	}

	if a.PriorityId != nil {
		object["priority_id"], err = json.Marshal(a.PriorityId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'priority_id': %w", err)
		}
	}

	if a.ProjectStatus != nil {
		object["project.status"], err = json.Marshal(a.ProjectStatus)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'project.status': %w", err)
		}
	}

	if a.ProjectId != nil {
		object["project_id"], err = json.Marshal(a.ProjectId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'project_id': %w", err)
		}
	}

	if a.RelationType != nil {
		object["relation_type"], err = json.Marshal(a.RelationType)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'relation_type': %w", err)
		}
	}

	if a.SpentTime != nil {
		object["spent_time"], err = json.Marshal(a.SpentTime)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'spent_time': %w", err)
		}
	}

	if a.StartDate != nil {
		object["start_date"], err = json.Marshal(a.StartDate)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'start_date': %w", err)
		}
	}

	if a.StatusId != nil {
		object["status_id"], err = json.Marshal(a.StatusId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'status_id': %w", err)
		}
	}

	if a.Subject != nil {
		object["subject"], err = json.Marshal(a.Subject)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'subject': %w", err)
		}
	}

	if a.SubprojectId != nil {
		object["subproject_id"], err = json.Marshal(a.SubprojectId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'subproject_id': %w", err)
		}
	}

	if a.TrackerId != nil {
		object["tracker_id"], err = json.Marshal(a.TrackerId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'tracker_id': %w", err)
		}
	}

	if a.UpdatedBy != nil {
		object["updated_by"], err = json.Marshal(a.UpdatedBy)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'updated_by': %w", err)
		}
	}

	if a.UpdatedOn != nil {
		object["updated_on"], err = json.Marshal(a.UpdatedOn)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'updated_on': %w", err)
		}
	}

	if a.WatcherId != nil {
		object["watcher_id"], err = json.Marshal(a.WatcherId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'watcher_id': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ProjectsIndexCsvParams_Query. Returns the specified
// element and whether it was found
func (a ProjectsIndexCsvParams_Query) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ProjectsIndexCsvParams_Query
func (a *ProjectsIndexCsvParams_Query) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ProjectsIndexCsvParams_Query to handle AdditionalProperties
func (a *ProjectsIndexCsvParams_Query) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["created_on"]; found {
		err = json.Unmarshal(raw, &a.CreatedOn)
		if err != nil {
			return fmt.Errorf("error reading 'created_on': %w", err)
		}
		delete(object, "created_on")
	}

	if raw, found := object["description"]; found {
		err = json.Unmarshal(raw, &a.Description)
		if err != nil {
			return fmt.Errorf("error reading 'description': %w", err)
		}
		delete(object, "description")
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if raw, found := object["is_public"]; found {
		err = json.Unmarshal(raw, &a.IsPublic)
		if err != nil {
			return fmt.Errorf("error reading 'is_public': %w", err)
		}
		delete(object, "is_public")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["parent_id"]; found {
		err = json.Unmarshal(raw, &a.ParentId)
		if err != nil {
			return fmt.Errorf("error reading 'parent_id': %w", err)
		}
		delete(object, "parent_id")
	}

	if raw, found := object["status"]; found {
		err = json.Unmarshal(raw, &a.Status)
		if err != nil {
			return fmt.Errorf("error reading 'status': %w", err)
		}
		delete(object, "status")
	}

	if raw, found := object["updated_on"]; found {
		err = json.Unmarshal(raw, &a.UpdatedOn)
		if err != nil {
			return fmt.Errorf("error reading 'updated_on': %w", err)
		}
		delete(object, "updated_on")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ProjectsIndexCsvParams_Query to handle AdditionalProperties
func (a ProjectsIndexCsvParams_Query) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.CreatedOn != nil {
		object["created_on"], err = json.Marshal(a.CreatedOn)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'created_on': %w", err)
		}
	}

	if a.Description != nil {
		object["description"], err = json.Marshal(a.Description)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'description': %w", err)
		}
	}

	if a.Id != nil {
		object["id"], err = json.Marshal(a.Id)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'id': %w", err)
		}
	}

	if a.IsPublic != nil {
		object["is_public"], err = json.Marshal(a.IsPublic)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'is_public': %w", err)
		}
	}

	if a.Name != nil {
		object["name"], err = json.Marshal(a.Name)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'name': %w", err)
		}
	}

	if a.ParentId != nil {
		object["parent_id"], err = json.Marshal(a.ParentId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'parent_id': %w", err)
		}
	}

	if a.Status != nil {
		object["status"], err = json.Marshal(a.Status)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'status': %w", err)
		}
	}

	if a.UpdatedOn != nil {
		object["updated_on"], err = json.Marshal(a.UpdatedOn)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'updated_on': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ProjectsIndexParams_Query. Returns the specified
// element and whether it was found
func (a ProjectsIndexParams_Query) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ProjectsIndexParams_Query
func (a *ProjectsIndexParams_Query) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ProjectsIndexParams_Query to handle AdditionalProperties
func (a *ProjectsIndexParams_Query) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["created_on"]; found {
		err = json.Unmarshal(raw, &a.CreatedOn)
		if err != nil {
			return fmt.Errorf("error reading 'created_on': %w", err)
		}
		delete(object, "created_on")
	}

	if raw, found := object["description"]; found {
		err = json.Unmarshal(raw, &a.Description)
		if err != nil {
			return fmt.Errorf("error reading 'description': %w", err)
		}
		delete(object, "description")
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if raw, found := object["is_public"]; found {
		err = json.Unmarshal(raw, &a.IsPublic)
		if err != nil {
			return fmt.Errorf("error reading 'is_public': %w", err)
		}
		delete(object, "is_public")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["parent_id"]; found {
		err = json.Unmarshal(raw, &a.ParentId)
		if err != nil {
			return fmt.Errorf("error reading 'parent_id': %w", err)
		}
		delete(object, "parent_id")
	}

	if raw, found := object["status"]; found {
		err = json.Unmarshal(raw, &a.Status)
		if err != nil {
			return fmt.Errorf("error reading 'status': %w", err)
		}
		delete(object, "status")
	}

	if raw, found := object["updated_on"]; found {
		err = json.Unmarshal(raw, &a.UpdatedOn)
		if err != nil {
			return fmt.Errorf("error reading 'updated_on': %w", err)
		}
		delete(object, "updated_on")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ProjectsIndexParams_Query to handle AdditionalProperties
func (a ProjectsIndexParams_Query) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.CreatedOn != nil {
		object["created_on"], err = json.Marshal(a.CreatedOn)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'created_on': %w", err)
		}
	}

	if a.Description != nil {
		object["description"], err = json.Marshal(a.Description)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'description': %w", err)
		}
	}

	if a.Id != nil {
		object["id"], err = json.Marshal(a.Id)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'id': %w", err)
		}
	}

	if a.IsPublic != nil {
		object["is_public"], err = json.Marshal(a.IsPublic)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'is_public': %w", err)
		}
	}

	if a.Name != nil {
		object["name"], err = json.Marshal(a.Name)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'name': %w", err)
		}
	}

	if a.ParentId != nil {
		object["parent_id"], err = json.Marshal(a.ParentId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'parent_id': %w", err)
		}
	}

	if a.Status != nil {
		object["status"], err = json.Marshal(a.Status)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'status': %w", err)
		}
	}

	if a.UpdatedOn != nil {
		object["updated_on"], err = json.Marshal(a.UpdatedOn)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'updated_on': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for IssuesIndexProjectCsvParams_Query. Returns the specified
// element and whether it was found
func (a IssuesIndexProjectCsvParams_Query) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for IssuesIndexProjectCsvParams_Query
func (a *IssuesIndexProjectCsvParams_Query) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for IssuesIndexProjectCsvParams_Query to handle AdditionalProperties
func (a *IssuesIndexProjectCsvParams_Query) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["any_searchable"]; found {
		err = json.Unmarshal(raw, &a.AnySearchable)
		if err != nil {
			return fmt.Errorf("error reading 'any_searchable': %w", err)
		}
		delete(object, "any_searchable")
	}

	if raw, found := object["assigned_to_id"]; found {
		err = json.Unmarshal(raw, &a.AssignedToId)
		if err != nil {
			return fmt.Errorf("error reading 'assigned_to_id': %w", err)
		}
		delete(object, "assigned_to_id")
	}

	if raw, found := object["assigned_to_role"]; found {
		err = json.Unmarshal(raw, &a.AssignedToRole)
		if err != nil {
			return fmt.Errorf("error reading 'assigned_to_role': %w", err)
		}
		delete(object, "assigned_to_role")
	}

	if raw, found := object["attachment"]; found {
		err = json.Unmarshal(raw, &a.Attachment)
		if err != nil {
			return fmt.Errorf("error reading 'attachment': %w", err)
		}
		delete(object, "attachment")
	}

	if raw, found := object["attachment_description"]; found {
		err = json.Unmarshal(raw, &a.AttachmentDescription)
		if err != nil {
			return fmt.Errorf("error reading 'attachment_description': %w", err)
		}
		delete(object, "attachment_description")
	}

	if raw, found := object["author.group"]; found {
		err = json.Unmarshal(raw, &a.AuthorGroup)
		if err != nil {
			return fmt.Errorf("error reading 'author.group': %w", err)
		}
		delete(object, "author.group")
	}

	if raw, found := object["author.role"]; found {
		err = json.Unmarshal(raw, &a.AuthorRole)
		if err != nil {
			return fmt.Errorf("error reading 'author.role': %w", err)
		}
		delete(object, "author.role")
	}

	if raw, found := object["author_id"]; found {
		err = json.Unmarshal(raw, &a.AuthorId)
		if err != nil {
			return fmt.Errorf("error reading 'author_id': %w", err)
		}
		delete(object, "author_id")
	}

	if raw, found := object["category_id"]; found {
		err = json.Unmarshal(raw, &a.CategoryId)
		if err != nil {
			return fmt.Errorf("error reading 'category_id': %w", err)
		}
		delete(object, "category_id")
	}

	if raw, found := object["child_id"]; found {
		err = json.Unmarshal(raw, &a.ChildId)
		if err != nil {
			return fmt.Errorf("error reading 'child_id': %w", err)
		}
		delete(object, "child_id")
	}

	if raw, found := object["closed_on"]; found {
		err = json.Unmarshal(raw, &a.ClosedOn)
		if err != nil {
			return fmt.Errorf("error reading 'closed_on': %w", err)
		}
		delete(object, "closed_on")
	}

	if raw, found := object["created_on"]; found {
		err = json.Unmarshal(raw, &a.CreatedOn)
		if err != nil {
			return fmt.Errorf("error reading 'created_on': %w", err)
		}
		delete(object, "created_on")
	}

	if raw, found := object["description"]; found {
		err = json.Unmarshal(raw, &a.Description)
		if err != nil {
			return fmt.Errorf("error reading 'description': %w", err)
		}
		delete(object, "description")
	}

	if raw, found := object["done_ratio"]; found {
		err = json.Unmarshal(raw, &a.DoneRatio)
		if err != nil {
			return fmt.Errorf("error reading 'done_ratio': %w", err)
		}
		delete(object, "done_ratio")
	}

	if raw, found := object["due_date"]; found {
		err = json.Unmarshal(raw, &a.DueDate)
		if err != nil {
			return fmt.Errorf("error reading 'due_date': %w", err)
		}
		delete(object, "due_date")
	}

	if raw, found := object["estimated_hours"]; found {
		err = json.Unmarshal(raw, &a.EstimatedHours)
		if err != nil {
			return fmt.Errorf("error reading 'estimated_hours': %w", err)
		}
		delete(object, "estimated_hours")
	}

	if raw, found := object["fixed_version.due_date"]; found {
		err = json.Unmarshal(raw, &a.FixedVersionDueDate)
		if err != nil {
			return fmt.Errorf("error reading 'fixed_version.due_date': %w", err)
		}
		delete(object, "fixed_version.due_date")
	}

	if raw, found := object["fixed_version.status"]; found {
		err = json.Unmarshal(raw, &a.FixedVersionStatus)
		if err != nil {
			return fmt.Errorf("error reading 'fixed_version.status': %w", err)
		}
		delete(object, "fixed_version.status")
	}

	if raw, found := object["fixed_version_id"]; found {
		err = json.Unmarshal(raw, &a.FixedVersionId)
		if err != nil {
			return fmt.Errorf("error reading 'fixed_version_id': %w", err)
		}
		delete(object, "fixed_version_id")
	}

	if raw, found := object["is_private"]; found {
		err = json.Unmarshal(raw, &a.IsPrivate)
		if err != nil {
			return fmt.Errorf("error reading 'is_private': %w", err)
		}
		delete(object, "is_private")
	}

	if raw, found := object["issue_id"]; found {
		err = json.Unmarshal(raw, &a.IssueId)
		if err != nil {
			return fmt.Errorf("error reading 'issue_id': %w", err)
		}
		delete(object, "issue_id")
	}

	if raw, found := object["last_updated_by"]; found {
		err = json.Unmarshal(raw, &a.LastUpdatedBy)
		if err != nil {
			return fmt.Errorf("error reading 'last_updated_by': %w", err)
		}
		delete(object, "last_updated_by")
	}

	if raw, found := object["member_of_group"]; found {
		err = json.Unmarshal(raw, &a.MemberOfGroup)
		if err != nil {
			return fmt.Errorf("error reading 'member_of_group': %w", err)
		}
		delete(object, "member_of_group")
	}

	if raw, found := object["notes"]; found {
		err = json.Unmarshal(raw, &a.Notes)
		if err != nil {
			return fmt.Errorf("error reading 'notes': %w", err)
		}
		delete(object, "notes")
	}

	if raw, found := object["parent_id"]; found {
		err = json.Unmarshal(raw, &a.ParentId)
		if err != nil {
			return fmt.Errorf("error reading 'parent_id': %w", err)
		}
		delete(object, "parent_id")
	}

	if raw, found := object["priority_id"]; found {
		err = json.Unmarshal(raw, &a.PriorityId)
		if err != nil {
			return fmt.Errorf("error reading 'priority_id': %w", err)
		}
		delete(object, "priority_id")
	}

	if raw, found := object["project.status"]; found {
		err = json.Unmarshal(raw, &a.ProjectStatus)
		if err != nil {
			return fmt.Errorf("error reading 'project.status': %w", err)
		}
		delete(object, "project.status")
	}

	if raw, found := object["project_id"]; found {
		err = json.Unmarshal(raw, &a.ProjectId)
		if err != nil {
			return fmt.Errorf("error reading 'project_id': %w", err)
		}
		delete(object, "project_id")
	}

	if raw, found := object["relation_type"]; found {
		err = json.Unmarshal(raw, &a.RelationType)
		if err != nil {
			return fmt.Errorf("error reading 'relation_type': %w", err)
		}
		delete(object, "relation_type")
	}

	if raw, found := object["spent_time"]; found {
		err = json.Unmarshal(raw, &a.SpentTime)
		if err != nil {
			return fmt.Errorf("error reading 'spent_time': %w", err)
		}
		delete(object, "spent_time")
	}

	if raw, found := object["start_date"]; found {
		err = json.Unmarshal(raw, &a.StartDate)
		if err != nil {
			return fmt.Errorf("error reading 'start_date': %w", err)
		}
		delete(object, "start_date")
	}

	if raw, found := object["status_id"]; found {
		err = json.Unmarshal(raw, &a.StatusId)
		if err != nil {
			return fmt.Errorf("error reading 'status_id': %w", err)
		}
		delete(object, "status_id")
	}

	if raw, found := object["subject"]; found {
		err = json.Unmarshal(raw, &a.Subject)
		if err != nil {
			return fmt.Errorf("error reading 'subject': %w", err)
		}
		delete(object, "subject")
	}

	if raw, found := object["subproject_id"]; found {
		err = json.Unmarshal(raw, &a.SubprojectId)
		if err != nil {
			return fmt.Errorf("error reading 'subproject_id': %w", err)
		}
		delete(object, "subproject_id")
	}

	if raw, found := object["tracker_id"]; found {
		err = json.Unmarshal(raw, &a.TrackerId)
		if err != nil {
			return fmt.Errorf("error reading 'tracker_id': %w", err)
		}
		delete(object, "tracker_id")
	}

	if raw, found := object["updated_by"]; found {
		err = json.Unmarshal(raw, &a.UpdatedBy)
		if err != nil {
			return fmt.Errorf("error reading 'updated_by': %w", err)
		}
		delete(object, "updated_by")
	}

	if raw, found := object["updated_on"]; found {
		err = json.Unmarshal(raw, &a.UpdatedOn)
		if err != nil {
			return fmt.Errorf("error reading 'updated_on': %w", err)
		}
		delete(object, "updated_on")
	}

	if raw, found := object["watcher_id"]; found {
		err = json.Unmarshal(raw, &a.WatcherId)
		if err != nil {
			return fmt.Errorf("error reading 'watcher_id': %w", err)
		}
		delete(object, "watcher_id")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for IssuesIndexProjectCsvParams_Query to handle AdditionalProperties
func (a IssuesIndexProjectCsvParams_Query) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.AnySearchable != nil {
		object["any_searchable"], err = json.Marshal(a.AnySearchable)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'any_searchable': %w", err)
		}
	}

	if a.AssignedToId != nil {
		object["assigned_to_id"], err = json.Marshal(a.AssignedToId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'assigned_to_id': %w", err)
		}
	}

	if a.AssignedToRole != nil {
		object["assigned_to_role"], err = json.Marshal(a.AssignedToRole)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'assigned_to_role': %w", err)
		}
	}

	if a.Attachment != nil {
		object["attachment"], err = json.Marshal(a.Attachment)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'attachment': %w", err)
		}
	}

	if a.AttachmentDescription != nil {
		object["attachment_description"], err = json.Marshal(a.AttachmentDescription)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'attachment_description': %w", err)
		}
	}

	if a.AuthorGroup != nil {
		object["author.group"], err = json.Marshal(a.AuthorGroup)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'author.group': %w", err)
		}
	}

	if a.AuthorRole != nil {
		object["author.role"], err = json.Marshal(a.AuthorRole)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'author.role': %w", err)
		}
	}

	if a.AuthorId != nil {
		object["author_id"], err = json.Marshal(a.AuthorId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'author_id': %w", err)
		}
	}

	if a.CategoryId != nil {
		object["category_id"], err = json.Marshal(a.CategoryId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'category_id': %w", err)
		}
	}

	if a.ChildId != nil {
		object["child_id"], err = json.Marshal(a.ChildId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'child_id': %w", err)
		}
	}

	if a.ClosedOn != nil {
		object["closed_on"], err = json.Marshal(a.ClosedOn)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'closed_on': %w", err)
		}
	}

	if a.CreatedOn != nil {
		object["created_on"], err = json.Marshal(a.CreatedOn)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'created_on': %w", err)
		}
	}

	if a.Description != nil {
		object["description"], err = json.Marshal(a.Description)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'description': %w", err)
		}
	}

	if a.DoneRatio != nil {
		object["done_ratio"], err = json.Marshal(a.DoneRatio)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'done_ratio': %w", err)
		}
	}

	if a.DueDate != nil {
		object["due_date"], err = json.Marshal(a.DueDate)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'due_date': %w", err)
		}
	}

	if a.EstimatedHours != nil {
		object["estimated_hours"], err = json.Marshal(a.EstimatedHours)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'estimated_hours': %w", err)
		}
	}

	if a.FixedVersionDueDate != nil {
		object["fixed_version.due_date"], err = json.Marshal(a.FixedVersionDueDate)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'fixed_version.due_date': %w", err)
		}
	}

	if a.FixedVersionStatus != nil {
		object["fixed_version.status"], err = json.Marshal(a.FixedVersionStatus)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'fixed_version.status': %w", err)
		}
	}

	if a.FixedVersionId != nil {
		object["fixed_version_id"], err = json.Marshal(a.FixedVersionId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'fixed_version_id': %w", err)
		}
	}

	if a.IsPrivate != nil {
		object["is_private"], err = json.Marshal(a.IsPrivate)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'is_private': %w", err)
		}
	}

	if a.IssueId != nil {
		object["issue_id"], err = json.Marshal(a.IssueId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'issue_id': %w", err)
		}
	}

	if a.LastUpdatedBy != nil {
		object["last_updated_by"], err = json.Marshal(a.LastUpdatedBy)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'last_updated_by': %w", err)
		}
	}

	if a.MemberOfGroup != nil {
		object["member_of_group"], err = json.Marshal(a.MemberOfGroup)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'member_of_group': %w", err)
		}
	}

	if a.Notes != nil {
		object["notes"], err = json.Marshal(a.Notes)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'notes': %w", err)
		}
	}

	if a.ParentId != nil {
		object["parent_id"], err = json.Marshal(a.ParentId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'parent_id': %w", err)
		}
	}

	if a.PriorityId != nil {
		object["priority_id"], err = json.Marshal(a.PriorityId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'priority_id': %w", err)
		}
	}

	if a.ProjectStatus != nil {
		object["project.status"], err = json.Marshal(a.ProjectStatus)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'project.status': %w", err)
		}
	}

	if a.ProjectId != nil {
		object["project_id"], err = json.Marshal(a.ProjectId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'project_id': %w", err)
		}
	}

	if a.RelationType != nil {
		object["relation_type"], err = json.Marshal(a.RelationType)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'relation_type': %w", err)
		}
	}

	if a.SpentTime != nil {
		object["spent_time"], err = json.Marshal(a.SpentTime)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'spent_time': %w", err)
		}
	}

	if a.StartDate != nil {
		object["start_date"], err = json.Marshal(a.StartDate)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'start_date': %w", err)
		}
	}

	if a.StatusId != nil {
		object["status_id"], err = json.Marshal(a.StatusId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'status_id': %w", err)
		}
	}

	if a.Subject != nil {
		object["subject"], err = json.Marshal(a.Subject)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'subject': %w", err)
		}
	}

	if a.SubprojectId != nil {
		object["subproject_id"], err = json.Marshal(a.SubprojectId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'subproject_id': %w", err)
		}
	}

	if a.TrackerId != nil {
		object["tracker_id"], err = json.Marshal(a.TrackerId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'tracker_id': %w", err)
		}
	}

	if a.UpdatedBy != nil {
		object["updated_by"], err = json.Marshal(a.UpdatedBy)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'updated_by': %w", err)
		}
	}

	if a.UpdatedOn != nil {
		object["updated_on"], err = json.Marshal(a.UpdatedOn)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'updated_on': %w", err)
		}
	}

	if a.WatcherId != nil {
		object["watcher_id"], err = json.Marshal(a.WatcherId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'watcher_id': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for IssuesIndexProjectParams_Query. Returns the specified
// element and whether it was found
func (a IssuesIndexProjectParams_Query) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for IssuesIndexProjectParams_Query
func (a *IssuesIndexProjectParams_Query) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for IssuesIndexProjectParams_Query to handle AdditionalProperties
func (a *IssuesIndexProjectParams_Query) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["any_searchable"]; found {
		err = json.Unmarshal(raw, &a.AnySearchable)
		if err != nil {
			return fmt.Errorf("error reading 'any_searchable': %w", err)
		}
		delete(object, "any_searchable")
	}

	if raw, found := object["assigned_to_id"]; found {
		err = json.Unmarshal(raw, &a.AssignedToId)
		if err != nil {
			return fmt.Errorf("error reading 'assigned_to_id': %w", err)
		}
		delete(object, "assigned_to_id")
	}

	if raw, found := object["assigned_to_role"]; found {
		err = json.Unmarshal(raw, &a.AssignedToRole)
		if err != nil {
			return fmt.Errorf("error reading 'assigned_to_role': %w", err)
		}
		delete(object, "assigned_to_role")
	}

	if raw, found := object["attachment"]; found {
		err = json.Unmarshal(raw, &a.Attachment)
		if err != nil {
			return fmt.Errorf("error reading 'attachment': %w", err)
		}
		delete(object, "attachment")
	}

	if raw, found := object["attachment_description"]; found {
		err = json.Unmarshal(raw, &a.AttachmentDescription)
		if err != nil {
			return fmt.Errorf("error reading 'attachment_description': %w", err)
		}
		delete(object, "attachment_description")
	}

	if raw, found := object["author.group"]; found {
		err = json.Unmarshal(raw, &a.AuthorGroup)
		if err != nil {
			return fmt.Errorf("error reading 'author.group': %w", err)
		}
		delete(object, "author.group")
	}

	if raw, found := object["author.role"]; found {
		err = json.Unmarshal(raw, &a.AuthorRole)
		if err != nil {
			return fmt.Errorf("error reading 'author.role': %w", err)
		}
		delete(object, "author.role")
	}

	if raw, found := object["author_id"]; found {
		err = json.Unmarshal(raw, &a.AuthorId)
		if err != nil {
			return fmt.Errorf("error reading 'author_id': %w", err)
		}
		delete(object, "author_id")
	}

	if raw, found := object["category_id"]; found {
		err = json.Unmarshal(raw, &a.CategoryId)
		if err != nil {
			return fmt.Errorf("error reading 'category_id': %w", err)
		}
		delete(object, "category_id")
	}

	if raw, found := object["child_id"]; found {
		err = json.Unmarshal(raw, &a.ChildId)
		if err != nil {
			return fmt.Errorf("error reading 'child_id': %w", err)
		}
		delete(object, "child_id")
	}

	if raw, found := object["closed_on"]; found {
		err = json.Unmarshal(raw, &a.ClosedOn)
		if err != nil {
			return fmt.Errorf("error reading 'closed_on': %w", err)
		}
		delete(object, "closed_on")
	}

	if raw, found := object["created_on"]; found {
		err = json.Unmarshal(raw, &a.CreatedOn)
		if err != nil {
			return fmt.Errorf("error reading 'created_on': %w", err)
		}
		delete(object, "created_on")
	}

	if raw, found := object["description"]; found {
		err = json.Unmarshal(raw, &a.Description)
		if err != nil {
			return fmt.Errorf("error reading 'description': %w", err)
		}
		delete(object, "description")
	}

	if raw, found := object["done_ratio"]; found {
		err = json.Unmarshal(raw, &a.DoneRatio)
		if err != nil {
			return fmt.Errorf("error reading 'done_ratio': %w", err)
		}
		delete(object, "done_ratio")
	}

	if raw, found := object["due_date"]; found {
		err = json.Unmarshal(raw, &a.DueDate)
		if err != nil {
			return fmt.Errorf("error reading 'due_date': %w", err)
		}
		delete(object, "due_date")
	}

	if raw, found := object["estimated_hours"]; found {
		err = json.Unmarshal(raw, &a.EstimatedHours)
		if err != nil {
			return fmt.Errorf("error reading 'estimated_hours': %w", err)
		}
		delete(object, "estimated_hours")
	}

	if raw, found := object["fixed_version.due_date"]; found {
		err = json.Unmarshal(raw, &a.FixedVersionDueDate)
		if err != nil {
			return fmt.Errorf("error reading 'fixed_version.due_date': %w", err)
		}
		delete(object, "fixed_version.due_date")
	}

	if raw, found := object["fixed_version.status"]; found {
		err = json.Unmarshal(raw, &a.FixedVersionStatus)
		if err != nil {
			return fmt.Errorf("error reading 'fixed_version.status': %w", err)
		}
		delete(object, "fixed_version.status")
	}

	if raw, found := object["fixed_version_id"]; found {
		err = json.Unmarshal(raw, &a.FixedVersionId)
		if err != nil {
			return fmt.Errorf("error reading 'fixed_version_id': %w", err)
		}
		delete(object, "fixed_version_id")
	}

	if raw, found := object["is_private"]; found {
		err = json.Unmarshal(raw, &a.IsPrivate)
		if err != nil {
			return fmt.Errorf("error reading 'is_private': %w", err)
		}
		delete(object, "is_private")
	}

	if raw, found := object["issue_id"]; found {
		err = json.Unmarshal(raw, &a.IssueId)
		if err != nil {
			return fmt.Errorf("error reading 'issue_id': %w", err)
		}
		delete(object, "issue_id")
	}

	if raw, found := object["last_updated_by"]; found {
		err = json.Unmarshal(raw, &a.LastUpdatedBy)
		if err != nil {
			return fmt.Errorf("error reading 'last_updated_by': %w", err)
		}
		delete(object, "last_updated_by")
	}

	if raw, found := object["member_of_group"]; found {
		err = json.Unmarshal(raw, &a.MemberOfGroup)
		if err != nil {
			return fmt.Errorf("error reading 'member_of_group': %w", err)
		}
		delete(object, "member_of_group")
	}

	if raw, found := object["notes"]; found {
		err = json.Unmarshal(raw, &a.Notes)
		if err != nil {
			return fmt.Errorf("error reading 'notes': %w", err)
		}
		delete(object, "notes")
	}

	if raw, found := object["parent_id"]; found {
		err = json.Unmarshal(raw, &a.ParentId)
		if err != nil {
			return fmt.Errorf("error reading 'parent_id': %w", err)
		}
		delete(object, "parent_id")
	}

	if raw, found := object["priority_id"]; found {
		err = json.Unmarshal(raw, &a.PriorityId)
		if err != nil {
			return fmt.Errorf("error reading 'priority_id': %w", err)
		}
		delete(object, "priority_id")
	}

	if raw, found := object["project.status"]; found {
		err = json.Unmarshal(raw, &a.ProjectStatus)
		if err != nil {
			return fmt.Errorf("error reading 'project.status': %w", err)
		}
		delete(object, "project.status")
	}

	if raw, found := object["project_id"]; found {
		err = json.Unmarshal(raw, &a.ProjectId)
		if err != nil {
			return fmt.Errorf("error reading 'project_id': %w", err)
		}
		delete(object, "project_id")
	}

	if raw, found := object["relation_type"]; found {
		err = json.Unmarshal(raw, &a.RelationType)
		if err != nil {
			return fmt.Errorf("error reading 'relation_type': %w", err)
		}
		delete(object, "relation_type")
	}

	if raw, found := object["spent_time"]; found {
		err = json.Unmarshal(raw, &a.SpentTime)
		if err != nil {
			return fmt.Errorf("error reading 'spent_time': %w", err)
		}
		delete(object, "spent_time")
	}

	if raw, found := object["start_date"]; found {
		err = json.Unmarshal(raw, &a.StartDate)
		if err != nil {
			return fmt.Errorf("error reading 'start_date': %w", err)
		}
		delete(object, "start_date")
	}

	if raw, found := object["status_id"]; found {
		err = json.Unmarshal(raw, &a.StatusId)
		if err != nil {
			return fmt.Errorf("error reading 'status_id': %w", err)
		}
		delete(object, "status_id")
	}

	if raw, found := object["subject"]; found {
		err = json.Unmarshal(raw, &a.Subject)
		if err != nil {
			return fmt.Errorf("error reading 'subject': %w", err)
		}
		delete(object, "subject")
	}

	if raw, found := object["subproject_id"]; found {
		err = json.Unmarshal(raw, &a.SubprojectId)
		if err != nil {
			return fmt.Errorf("error reading 'subproject_id': %w", err)
		}
		delete(object, "subproject_id")
	}

	if raw, found := object["tracker_id"]; found {
		err = json.Unmarshal(raw, &a.TrackerId)
		if err != nil {
			return fmt.Errorf("error reading 'tracker_id': %w", err)
		}
		delete(object, "tracker_id")
	}

	if raw, found := object["updated_by"]; found {
		err = json.Unmarshal(raw, &a.UpdatedBy)
		if err != nil {
			return fmt.Errorf("error reading 'updated_by': %w", err)
		}
		delete(object, "updated_by")
	}

	if raw, found := object["updated_on"]; found {
		err = json.Unmarshal(raw, &a.UpdatedOn)
		if err != nil {
			return fmt.Errorf("error reading 'updated_on': %w", err)
		}
		delete(object, "updated_on")
	}

	if raw, found := object["watcher_id"]; found {
		err = json.Unmarshal(raw, &a.WatcherId)
		if err != nil {
			return fmt.Errorf("error reading 'watcher_id': %w", err)
		}
		delete(object, "watcher_id")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for IssuesIndexProjectParams_Query to handle AdditionalProperties
func (a IssuesIndexProjectParams_Query) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.AnySearchable != nil {
		object["any_searchable"], err = json.Marshal(a.AnySearchable)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'any_searchable': %w", err)
		}
	}

	if a.AssignedToId != nil {
		object["assigned_to_id"], err = json.Marshal(a.AssignedToId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'assigned_to_id': %w", err)
		}
	}

	if a.AssignedToRole != nil {
		object["assigned_to_role"], err = json.Marshal(a.AssignedToRole)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'assigned_to_role': %w", err)
		}
	}

	if a.Attachment != nil {
		object["attachment"], err = json.Marshal(a.Attachment)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'attachment': %w", err)
		}
	}

	if a.AttachmentDescription != nil {
		object["attachment_description"], err = json.Marshal(a.AttachmentDescription)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'attachment_description': %w", err)
		}
	}

	if a.AuthorGroup != nil {
		object["author.group"], err = json.Marshal(a.AuthorGroup)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'author.group': %w", err)
		}
	}

	if a.AuthorRole != nil {
		object["author.role"], err = json.Marshal(a.AuthorRole)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'author.role': %w", err)
		}
	}

	if a.AuthorId != nil {
		object["author_id"], err = json.Marshal(a.AuthorId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'author_id': %w", err)
		}
	}

	if a.CategoryId != nil {
		object["category_id"], err = json.Marshal(a.CategoryId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'category_id': %w", err)
		}
	}

	if a.ChildId != nil {
		object["child_id"], err = json.Marshal(a.ChildId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'child_id': %w", err)
		}
	}

	if a.ClosedOn != nil {
		object["closed_on"], err = json.Marshal(a.ClosedOn)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'closed_on': %w", err)
		}
	}

	if a.CreatedOn != nil {
		object["created_on"], err = json.Marshal(a.CreatedOn)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'created_on': %w", err)
		}
	}

	if a.Description != nil {
		object["description"], err = json.Marshal(a.Description)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'description': %w", err)
		}
	}

	if a.DoneRatio != nil {
		object["done_ratio"], err = json.Marshal(a.DoneRatio)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'done_ratio': %w", err)
		}
	}

	if a.DueDate != nil {
		object["due_date"], err = json.Marshal(a.DueDate)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'due_date': %w", err)
		}
	}

	if a.EstimatedHours != nil {
		object["estimated_hours"], err = json.Marshal(a.EstimatedHours)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'estimated_hours': %w", err)
		}
	}

	if a.FixedVersionDueDate != nil {
		object["fixed_version.due_date"], err = json.Marshal(a.FixedVersionDueDate)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'fixed_version.due_date': %w", err)
		}
	}

	if a.FixedVersionStatus != nil {
		object["fixed_version.status"], err = json.Marshal(a.FixedVersionStatus)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'fixed_version.status': %w", err)
		}
	}

	if a.FixedVersionId != nil {
		object["fixed_version_id"], err = json.Marshal(a.FixedVersionId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'fixed_version_id': %w", err)
		}
	}

	if a.IsPrivate != nil {
		object["is_private"], err = json.Marshal(a.IsPrivate)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'is_private': %w", err)
		}
	}

	if a.IssueId != nil {
		object["issue_id"], err = json.Marshal(a.IssueId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'issue_id': %w", err)
		}
	}

	if a.LastUpdatedBy != nil {
		object["last_updated_by"], err = json.Marshal(a.LastUpdatedBy)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'last_updated_by': %w", err)
		}
	}

	if a.MemberOfGroup != nil {
		object["member_of_group"], err = json.Marshal(a.MemberOfGroup)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'member_of_group': %w", err)
		}
	}

	if a.Notes != nil {
		object["notes"], err = json.Marshal(a.Notes)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'notes': %w", err)
		}
	}

	if a.ParentId != nil {
		object["parent_id"], err = json.Marshal(a.ParentId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'parent_id': %w", err)
		}
	}

	if a.PriorityId != nil {
		object["priority_id"], err = json.Marshal(a.PriorityId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'priority_id': %w", err)
		}
	}

	if a.ProjectStatus != nil {
		object["project.status"], err = json.Marshal(a.ProjectStatus)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'project.status': %w", err)
		}
	}

	if a.ProjectId != nil {
		object["project_id"], err = json.Marshal(a.ProjectId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'project_id': %w", err)
		}
	}

	if a.RelationType != nil {
		object["relation_type"], err = json.Marshal(a.RelationType)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'relation_type': %w", err)
		}
	}

	if a.SpentTime != nil {
		object["spent_time"], err = json.Marshal(a.SpentTime)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'spent_time': %w", err)
		}
	}

	if a.StartDate != nil {
		object["start_date"], err = json.Marshal(a.StartDate)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'start_date': %w", err)
		}
	}

	if a.StatusId != nil {
		object["status_id"], err = json.Marshal(a.StatusId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'status_id': %w", err)
		}
	}

	if a.Subject != nil {
		object["subject"], err = json.Marshal(a.Subject)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'subject': %w", err)
		}
	}

	if a.SubprojectId != nil {
		object["subproject_id"], err = json.Marshal(a.SubprojectId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'subproject_id': %w", err)
		}
	}

	if a.TrackerId != nil {
		object["tracker_id"], err = json.Marshal(a.TrackerId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'tracker_id': %w", err)
		}
	}

	if a.UpdatedBy != nil {
		object["updated_by"], err = json.Marshal(a.UpdatedBy)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'updated_by': %w", err)
		}
	}

	if a.UpdatedOn != nil {
		object["updated_on"], err = json.Marshal(a.UpdatedOn)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'updated_on': %w", err)
		}
	}

	if a.WatcherId != nil {
		object["watcher_id"], err = json.Marshal(a.WatcherId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'watcher_id': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for IssuesIndexProjectPdfParams_Query. Returns the specified
// element and whether it was found
func (a IssuesIndexProjectPdfParams_Query) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for IssuesIndexProjectPdfParams_Query
func (a *IssuesIndexProjectPdfParams_Query) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for IssuesIndexProjectPdfParams_Query to handle AdditionalProperties
func (a *IssuesIndexProjectPdfParams_Query) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["any_searchable"]; found {
		err = json.Unmarshal(raw, &a.AnySearchable)
		if err != nil {
			return fmt.Errorf("error reading 'any_searchable': %w", err)
		}
		delete(object, "any_searchable")
	}

	if raw, found := object["assigned_to_id"]; found {
		err = json.Unmarshal(raw, &a.AssignedToId)
		if err != nil {
			return fmt.Errorf("error reading 'assigned_to_id': %w", err)
		}
		delete(object, "assigned_to_id")
	}

	if raw, found := object["assigned_to_role"]; found {
		err = json.Unmarshal(raw, &a.AssignedToRole)
		if err != nil {
			return fmt.Errorf("error reading 'assigned_to_role': %w", err)
		}
		delete(object, "assigned_to_role")
	}

	if raw, found := object["attachment"]; found {
		err = json.Unmarshal(raw, &a.Attachment)
		if err != nil {
			return fmt.Errorf("error reading 'attachment': %w", err)
		}
		delete(object, "attachment")
	}

	if raw, found := object["attachment_description"]; found {
		err = json.Unmarshal(raw, &a.AttachmentDescription)
		if err != nil {
			return fmt.Errorf("error reading 'attachment_description': %w", err)
		}
		delete(object, "attachment_description")
	}

	if raw, found := object["author.group"]; found {
		err = json.Unmarshal(raw, &a.AuthorGroup)
		if err != nil {
			return fmt.Errorf("error reading 'author.group': %w", err)
		}
		delete(object, "author.group")
	}

	if raw, found := object["author.role"]; found {
		err = json.Unmarshal(raw, &a.AuthorRole)
		if err != nil {
			return fmt.Errorf("error reading 'author.role': %w", err)
		}
		delete(object, "author.role")
	}

	if raw, found := object["author_id"]; found {
		err = json.Unmarshal(raw, &a.AuthorId)
		if err != nil {
			return fmt.Errorf("error reading 'author_id': %w", err)
		}
		delete(object, "author_id")
	}

	if raw, found := object["category_id"]; found {
		err = json.Unmarshal(raw, &a.CategoryId)
		if err != nil {
			return fmt.Errorf("error reading 'category_id': %w", err)
		}
		delete(object, "category_id")
	}

	if raw, found := object["child_id"]; found {
		err = json.Unmarshal(raw, &a.ChildId)
		if err != nil {
			return fmt.Errorf("error reading 'child_id': %w", err)
		}
		delete(object, "child_id")
	}

	if raw, found := object["closed_on"]; found {
		err = json.Unmarshal(raw, &a.ClosedOn)
		if err != nil {
			return fmt.Errorf("error reading 'closed_on': %w", err)
		}
		delete(object, "closed_on")
	}

	if raw, found := object["created_on"]; found {
		err = json.Unmarshal(raw, &a.CreatedOn)
		if err != nil {
			return fmt.Errorf("error reading 'created_on': %w", err)
		}
		delete(object, "created_on")
	}

	if raw, found := object["description"]; found {
		err = json.Unmarshal(raw, &a.Description)
		if err != nil {
			return fmt.Errorf("error reading 'description': %w", err)
		}
		delete(object, "description")
	}

	if raw, found := object["done_ratio"]; found {
		err = json.Unmarshal(raw, &a.DoneRatio)
		if err != nil {
			return fmt.Errorf("error reading 'done_ratio': %w", err)
		}
		delete(object, "done_ratio")
	}

	if raw, found := object["due_date"]; found {
		err = json.Unmarshal(raw, &a.DueDate)
		if err != nil {
			return fmt.Errorf("error reading 'due_date': %w", err)
		}
		delete(object, "due_date")
	}

	if raw, found := object["estimated_hours"]; found {
		err = json.Unmarshal(raw, &a.EstimatedHours)
		if err != nil {
			return fmt.Errorf("error reading 'estimated_hours': %w", err)
		}
		delete(object, "estimated_hours")
	}

	if raw, found := object["fixed_version.due_date"]; found {
		err = json.Unmarshal(raw, &a.FixedVersionDueDate)
		if err != nil {
			return fmt.Errorf("error reading 'fixed_version.due_date': %w", err)
		}
		delete(object, "fixed_version.due_date")
	}

	if raw, found := object["fixed_version.status"]; found {
		err = json.Unmarshal(raw, &a.FixedVersionStatus)
		if err != nil {
			return fmt.Errorf("error reading 'fixed_version.status': %w", err)
		}
		delete(object, "fixed_version.status")
	}

	if raw, found := object["fixed_version_id"]; found {
		err = json.Unmarshal(raw, &a.FixedVersionId)
		if err != nil {
			return fmt.Errorf("error reading 'fixed_version_id': %w", err)
		}
		delete(object, "fixed_version_id")
	}

	if raw, found := object["is_private"]; found {
		err = json.Unmarshal(raw, &a.IsPrivate)
		if err != nil {
			return fmt.Errorf("error reading 'is_private': %w", err)
		}
		delete(object, "is_private")
	}

	if raw, found := object["issue_id"]; found {
		err = json.Unmarshal(raw, &a.IssueId)
		if err != nil {
			return fmt.Errorf("error reading 'issue_id': %w", err)
		}
		delete(object, "issue_id")
	}

	if raw, found := object["last_updated_by"]; found {
		err = json.Unmarshal(raw, &a.LastUpdatedBy)
		if err != nil {
			return fmt.Errorf("error reading 'last_updated_by': %w", err)
		}
		delete(object, "last_updated_by")
	}

	if raw, found := object["member_of_group"]; found {
		err = json.Unmarshal(raw, &a.MemberOfGroup)
		if err != nil {
			return fmt.Errorf("error reading 'member_of_group': %w", err)
		}
		delete(object, "member_of_group")
	}

	if raw, found := object["notes"]; found {
		err = json.Unmarshal(raw, &a.Notes)
		if err != nil {
			return fmt.Errorf("error reading 'notes': %w", err)
		}
		delete(object, "notes")
	}

	if raw, found := object["parent_id"]; found {
		err = json.Unmarshal(raw, &a.ParentId)
		if err != nil {
			return fmt.Errorf("error reading 'parent_id': %w", err)
		}
		delete(object, "parent_id")
	}

	if raw, found := object["priority_id"]; found {
		err = json.Unmarshal(raw, &a.PriorityId)
		if err != nil {
			return fmt.Errorf("error reading 'priority_id': %w", err)
		}
		delete(object, "priority_id")
	}

	if raw, found := object["project.status"]; found {
		err = json.Unmarshal(raw, &a.ProjectStatus)
		if err != nil {
			return fmt.Errorf("error reading 'project.status': %w", err)
		}
		delete(object, "project.status")
	}

	if raw, found := object["project_id"]; found {
		err = json.Unmarshal(raw, &a.ProjectId)
		if err != nil {
			return fmt.Errorf("error reading 'project_id': %w", err)
		}
		delete(object, "project_id")
	}

	if raw, found := object["relation_type"]; found {
		err = json.Unmarshal(raw, &a.RelationType)
		if err != nil {
			return fmt.Errorf("error reading 'relation_type': %w", err)
		}
		delete(object, "relation_type")
	}

	if raw, found := object["spent_time"]; found {
		err = json.Unmarshal(raw, &a.SpentTime)
		if err != nil {
			return fmt.Errorf("error reading 'spent_time': %w", err)
		}
		delete(object, "spent_time")
	}

	if raw, found := object["start_date"]; found {
		err = json.Unmarshal(raw, &a.StartDate)
		if err != nil {
			return fmt.Errorf("error reading 'start_date': %w", err)
		}
		delete(object, "start_date")
	}

	if raw, found := object["status_id"]; found {
		err = json.Unmarshal(raw, &a.StatusId)
		if err != nil {
			return fmt.Errorf("error reading 'status_id': %w", err)
		}
		delete(object, "status_id")
	}

	if raw, found := object["subject"]; found {
		err = json.Unmarshal(raw, &a.Subject)
		if err != nil {
			return fmt.Errorf("error reading 'subject': %w", err)
		}
		delete(object, "subject")
	}

	if raw, found := object["subproject_id"]; found {
		err = json.Unmarshal(raw, &a.SubprojectId)
		if err != nil {
			return fmt.Errorf("error reading 'subproject_id': %w", err)
		}
		delete(object, "subproject_id")
	}

	if raw, found := object["tracker_id"]; found {
		err = json.Unmarshal(raw, &a.TrackerId)
		if err != nil {
			return fmt.Errorf("error reading 'tracker_id': %w", err)
		}
		delete(object, "tracker_id")
	}

	if raw, found := object["updated_by"]; found {
		err = json.Unmarshal(raw, &a.UpdatedBy)
		if err != nil {
			return fmt.Errorf("error reading 'updated_by': %w", err)
		}
		delete(object, "updated_by")
	}

	if raw, found := object["updated_on"]; found {
		err = json.Unmarshal(raw, &a.UpdatedOn)
		if err != nil {
			return fmt.Errorf("error reading 'updated_on': %w", err)
		}
		delete(object, "updated_on")
	}

	if raw, found := object["watcher_id"]; found {
		err = json.Unmarshal(raw, &a.WatcherId)
		if err != nil {
			return fmt.Errorf("error reading 'watcher_id': %w", err)
		}
		delete(object, "watcher_id")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for IssuesIndexProjectPdfParams_Query to handle AdditionalProperties
func (a IssuesIndexProjectPdfParams_Query) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.AnySearchable != nil {
		object["any_searchable"], err = json.Marshal(a.AnySearchable)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'any_searchable': %w", err)
		}
	}

	if a.AssignedToId != nil {
		object["assigned_to_id"], err = json.Marshal(a.AssignedToId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'assigned_to_id': %w", err)
		}
	}

	if a.AssignedToRole != nil {
		object["assigned_to_role"], err = json.Marshal(a.AssignedToRole)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'assigned_to_role': %w", err)
		}
	}

	if a.Attachment != nil {
		object["attachment"], err = json.Marshal(a.Attachment)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'attachment': %w", err)
		}
	}

	if a.AttachmentDescription != nil {
		object["attachment_description"], err = json.Marshal(a.AttachmentDescription)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'attachment_description': %w", err)
		}
	}

	if a.AuthorGroup != nil {
		object["author.group"], err = json.Marshal(a.AuthorGroup)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'author.group': %w", err)
		}
	}

	if a.AuthorRole != nil {
		object["author.role"], err = json.Marshal(a.AuthorRole)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'author.role': %w", err)
		}
	}

	if a.AuthorId != nil {
		object["author_id"], err = json.Marshal(a.AuthorId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'author_id': %w", err)
		}
	}

	if a.CategoryId != nil {
		object["category_id"], err = json.Marshal(a.CategoryId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'category_id': %w", err)
		}
	}

	if a.ChildId != nil {
		object["child_id"], err = json.Marshal(a.ChildId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'child_id': %w", err)
		}
	}

	if a.ClosedOn != nil {
		object["closed_on"], err = json.Marshal(a.ClosedOn)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'closed_on': %w", err)
		}
	}

	if a.CreatedOn != nil {
		object["created_on"], err = json.Marshal(a.CreatedOn)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'created_on': %w", err)
		}
	}

	if a.Description != nil {
		object["description"], err = json.Marshal(a.Description)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'description': %w", err)
		}
	}

	if a.DoneRatio != nil {
		object["done_ratio"], err = json.Marshal(a.DoneRatio)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'done_ratio': %w", err)
		}
	}

	if a.DueDate != nil {
		object["due_date"], err = json.Marshal(a.DueDate)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'due_date': %w", err)
		}
	}

	if a.EstimatedHours != nil {
		object["estimated_hours"], err = json.Marshal(a.EstimatedHours)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'estimated_hours': %w", err)
		}
	}

	if a.FixedVersionDueDate != nil {
		object["fixed_version.due_date"], err = json.Marshal(a.FixedVersionDueDate)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'fixed_version.due_date': %w", err)
		}
	}

	if a.FixedVersionStatus != nil {
		object["fixed_version.status"], err = json.Marshal(a.FixedVersionStatus)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'fixed_version.status': %w", err)
		}
	}

	if a.FixedVersionId != nil {
		object["fixed_version_id"], err = json.Marshal(a.FixedVersionId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'fixed_version_id': %w", err)
		}
	}

	if a.IsPrivate != nil {
		object["is_private"], err = json.Marshal(a.IsPrivate)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'is_private': %w", err)
		}
	}

	if a.IssueId != nil {
		object["issue_id"], err = json.Marshal(a.IssueId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'issue_id': %w", err)
		}
	}

	if a.LastUpdatedBy != nil {
		object["last_updated_by"], err = json.Marshal(a.LastUpdatedBy)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'last_updated_by': %w", err)
		}
	}

	if a.MemberOfGroup != nil {
		object["member_of_group"], err = json.Marshal(a.MemberOfGroup)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'member_of_group': %w", err)
		}
	}

	if a.Notes != nil {
		object["notes"], err = json.Marshal(a.Notes)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'notes': %w", err)
		}
	}

	if a.ParentId != nil {
		object["parent_id"], err = json.Marshal(a.ParentId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'parent_id': %w", err)
		}
	}

	if a.PriorityId != nil {
		object["priority_id"], err = json.Marshal(a.PriorityId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'priority_id': %w", err)
		}
	}

	if a.ProjectStatus != nil {
		object["project.status"], err = json.Marshal(a.ProjectStatus)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'project.status': %w", err)
		}
	}

	if a.ProjectId != nil {
		object["project_id"], err = json.Marshal(a.ProjectId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'project_id': %w", err)
		}
	}

	if a.RelationType != nil {
		object["relation_type"], err = json.Marshal(a.RelationType)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'relation_type': %w", err)
		}
	}

	if a.SpentTime != nil {
		object["spent_time"], err = json.Marshal(a.SpentTime)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'spent_time': %w", err)
		}
	}

	if a.StartDate != nil {
		object["start_date"], err = json.Marshal(a.StartDate)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'start_date': %w", err)
		}
	}

	if a.StatusId != nil {
		object["status_id"], err = json.Marshal(a.StatusId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'status_id': %w", err)
		}
	}

	if a.Subject != nil {
		object["subject"], err = json.Marshal(a.Subject)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'subject': %w", err)
		}
	}

	if a.SubprojectId != nil {
		object["subproject_id"], err = json.Marshal(a.SubprojectId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'subproject_id': %w", err)
		}
	}

	if a.TrackerId != nil {
		object["tracker_id"], err = json.Marshal(a.TrackerId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'tracker_id': %w", err)
		}
	}

	if a.UpdatedBy != nil {
		object["updated_by"], err = json.Marshal(a.UpdatedBy)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'updated_by': %w", err)
		}
	}

	if a.UpdatedOn != nil {
		object["updated_on"], err = json.Marshal(a.UpdatedOn)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'updated_on': %w", err)
		}
	}

	if a.WatcherId != nil {
		object["watcher_id"], err = json.Marshal(a.WatcherId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'watcher_id': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for TimelogIndexProjectCsvParams_Query. Returns the specified
// element and whether it was found
func (a TimelogIndexProjectCsvParams_Query) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for TimelogIndexProjectCsvParams_Query
func (a *TimelogIndexProjectCsvParams_Query) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for TimelogIndexProjectCsvParams_Query to handle AdditionalProperties
func (a *TimelogIndexProjectCsvParams_Query) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["activity_id"]; found {
		err = json.Unmarshal(raw, &a.ActivityId)
		if err != nil {
			return fmt.Errorf("error reading 'activity_id': %w", err)
		}
		delete(object, "activity_id")
	}

	if raw, found := object["author_id"]; found {
		err = json.Unmarshal(raw, &a.AuthorId)
		if err != nil {
			return fmt.Errorf("error reading 'author_id': %w", err)
		}
		delete(object, "author_id")
	}

	if raw, found := object["hours"]; found {
		err = json.Unmarshal(raw, &a.Hours)
		if err != nil {
			return fmt.Errorf("error reading 'hours': %w", err)
		}
		delete(object, "hours")
	}

	if raw, found := object["issue.category_id"]; found {
		err = json.Unmarshal(raw, &a.IssueCategoryId)
		if err != nil {
			return fmt.Errorf("error reading 'issue.category_id': %w", err)
		}
		delete(object, "issue.category_id")
	}

	if raw, found := object["issue.comments"]; found {
		err = json.Unmarshal(raw, &a.IssueComments)
		if err != nil {
			return fmt.Errorf("error reading 'issue.comments': %w", err)
		}
		delete(object, "issue.comments")
	}

	if raw, found := object["issue.fixed_version_id"]; found {
		err = json.Unmarshal(raw, &a.IssueFixedVersionId)
		if err != nil {
			return fmt.Errorf("error reading 'issue.fixed_version_id': %w", err)
		}
		delete(object, "issue.fixed_version_id")
	}

	if raw, found := object["issue.parent_id"]; found {
		err = json.Unmarshal(raw, &a.IssueParentId)
		if err != nil {
			return fmt.Errorf("error reading 'issue.parent_id': %w", err)
		}
		delete(object, "issue.parent_id")
	}

	if raw, found := object["issue.status_id"]; found {
		err = json.Unmarshal(raw, &a.IssueStatusId)
		if err != nil {
			return fmt.Errorf("error reading 'issue.status_id': %w", err)
		}
		delete(object, "issue.status_id")
	}

	if raw, found := object["issue.subject"]; found {
		err = json.Unmarshal(raw, &a.IssueSubject)
		if err != nil {
			return fmt.Errorf("error reading 'issue.subject': %w", err)
		}
		delete(object, "issue.subject")
	}

	if raw, found := object["issue.tracker_id"]; found {
		err = json.Unmarshal(raw, &a.IssueTrackerId)
		if err != nil {
			return fmt.Errorf("error reading 'issue.tracker_id': %w", err)
		}
		delete(object, "issue.tracker_id")
	}

	if raw, found := object["issue_id"]; found {
		err = json.Unmarshal(raw, &a.IssueId)
		if err != nil {
			return fmt.Errorf("error reading 'issue_id': %w", err)
		}
		delete(object, "issue_id")
	}

	if raw, found := object["project.status"]; found {
		err = json.Unmarshal(raw, &a.ProjectStatus)
		if err != nil {
			return fmt.Errorf("error reading 'project.status': %w", err)
		}
		delete(object, "project.status")
	}

	if raw, found := object["project_id"]; found {
		err = json.Unmarshal(raw, &a.ProjectId)
		if err != nil {
			return fmt.Errorf("error reading 'project_id': %w", err)
		}
		delete(object, "project_id")
	}

	if raw, found := object["spent_on"]; found {
		err = json.Unmarshal(raw, &a.SpentOn)
		if err != nil {
			return fmt.Errorf("error reading 'spent_on': %w", err)
		}
		delete(object, "spent_on")
	}

	if raw, found := object["subproject_id"]; found {
		err = json.Unmarshal(raw, &a.SubprojectId)
		if err != nil {
			return fmt.Errorf("error reading 'subproject_id': %w", err)
		}
		delete(object, "subproject_id")
	}

	if raw, found := object["user.group"]; found {
		err = json.Unmarshal(raw, &a.UserGroup)
		if err != nil {
			return fmt.Errorf("error reading 'user.group': %w", err)
		}
		delete(object, "user.group")
	}

	if raw, found := object["user.role"]; found {
		err = json.Unmarshal(raw, &a.UserRole)
		if err != nil {
			return fmt.Errorf("error reading 'user.role': %w", err)
		}
		delete(object, "user.role")
	}

	if raw, found := object["user_id"]; found {
		err = json.Unmarshal(raw, &a.UserId)
		if err != nil {
			return fmt.Errorf("error reading 'user_id': %w", err)
		}
		delete(object, "user_id")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for TimelogIndexProjectCsvParams_Query to handle AdditionalProperties
func (a TimelogIndexProjectCsvParams_Query) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.ActivityId != nil {
		object["activity_id"], err = json.Marshal(a.ActivityId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'activity_id': %w", err)
		}
	}

	if a.AuthorId != nil {
		object["author_id"], err = json.Marshal(a.AuthorId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'author_id': %w", err)
		}
	}

	if a.Hours != nil {
		object["hours"], err = json.Marshal(a.Hours)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'hours': %w", err)
		}
	}

	if a.IssueCategoryId != nil {
		object["issue.category_id"], err = json.Marshal(a.IssueCategoryId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'issue.category_id': %w", err)
		}
	}

	if a.IssueComments != nil {
		object["issue.comments"], err = json.Marshal(a.IssueComments)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'issue.comments': %w", err)
		}
	}

	if a.IssueFixedVersionId != nil {
		object["issue.fixed_version_id"], err = json.Marshal(a.IssueFixedVersionId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'issue.fixed_version_id': %w", err)
		}
	}

	if a.IssueParentId != nil {
		object["issue.parent_id"], err = json.Marshal(a.IssueParentId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'issue.parent_id': %w", err)
		}
	}

	if a.IssueStatusId != nil {
		object["issue.status_id"], err = json.Marshal(a.IssueStatusId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'issue.status_id': %w", err)
		}
	}

	if a.IssueSubject != nil {
		object["issue.subject"], err = json.Marshal(a.IssueSubject)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'issue.subject': %w", err)
		}
	}

	if a.IssueTrackerId != nil {
		object["issue.tracker_id"], err = json.Marshal(a.IssueTrackerId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'issue.tracker_id': %w", err)
		}
	}

	if a.IssueId != nil {
		object["issue_id"], err = json.Marshal(a.IssueId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'issue_id': %w", err)
		}
	}

	if a.ProjectStatus != nil {
		object["project.status"], err = json.Marshal(a.ProjectStatus)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'project.status': %w", err)
		}
	}

	if a.ProjectId != nil {
		object["project_id"], err = json.Marshal(a.ProjectId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'project_id': %w", err)
		}
	}

	if a.SpentOn != nil {
		object["spent_on"], err = json.Marshal(a.SpentOn)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'spent_on': %w", err)
		}
	}

	if a.SubprojectId != nil {
		object["subproject_id"], err = json.Marshal(a.SubprojectId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'subproject_id': %w", err)
		}
	}

	if a.UserGroup != nil {
		object["user.group"], err = json.Marshal(a.UserGroup)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'user.group': %w", err)
		}
	}

	if a.UserRole != nil {
		object["user.role"], err = json.Marshal(a.UserRole)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'user.role': %w", err)
		}
	}

	if a.UserId != nil {
		object["user_id"], err = json.Marshal(a.UserId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'user_id': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for TimelogIndexProjectParams_Query. Returns the specified
// element and whether it was found
func (a TimelogIndexProjectParams_Query) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for TimelogIndexProjectParams_Query
func (a *TimelogIndexProjectParams_Query) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for TimelogIndexProjectParams_Query to handle AdditionalProperties
func (a *TimelogIndexProjectParams_Query) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["activity_id"]; found {
		err = json.Unmarshal(raw, &a.ActivityId)
		if err != nil {
			return fmt.Errorf("error reading 'activity_id': %w", err)
		}
		delete(object, "activity_id")
	}

	if raw, found := object["author_id"]; found {
		err = json.Unmarshal(raw, &a.AuthorId)
		if err != nil {
			return fmt.Errorf("error reading 'author_id': %w", err)
		}
		delete(object, "author_id")
	}

	if raw, found := object["hours"]; found {
		err = json.Unmarshal(raw, &a.Hours)
		if err != nil {
			return fmt.Errorf("error reading 'hours': %w", err)
		}
		delete(object, "hours")
	}

	if raw, found := object["issue.category_id"]; found {
		err = json.Unmarshal(raw, &a.IssueCategoryId)
		if err != nil {
			return fmt.Errorf("error reading 'issue.category_id': %w", err)
		}
		delete(object, "issue.category_id")
	}

	if raw, found := object["issue.comments"]; found {
		err = json.Unmarshal(raw, &a.IssueComments)
		if err != nil {
			return fmt.Errorf("error reading 'issue.comments': %w", err)
		}
		delete(object, "issue.comments")
	}

	if raw, found := object["issue.fixed_version_id"]; found {
		err = json.Unmarshal(raw, &a.IssueFixedVersionId)
		if err != nil {
			return fmt.Errorf("error reading 'issue.fixed_version_id': %w", err)
		}
		delete(object, "issue.fixed_version_id")
	}

	if raw, found := object["issue.parent_id"]; found {
		err = json.Unmarshal(raw, &a.IssueParentId)
		if err != nil {
			return fmt.Errorf("error reading 'issue.parent_id': %w", err)
		}
		delete(object, "issue.parent_id")
	}

	if raw, found := object["issue.status_id"]; found {
		err = json.Unmarshal(raw, &a.IssueStatusId)
		if err != nil {
			return fmt.Errorf("error reading 'issue.status_id': %w", err)
		}
		delete(object, "issue.status_id")
	}

	if raw, found := object["issue.subject"]; found {
		err = json.Unmarshal(raw, &a.IssueSubject)
		if err != nil {
			return fmt.Errorf("error reading 'issue.subject': %w", err)
		}
		delete(object, "issue.subject")
	}

	if raw, found := object["issue.tracker_id"]; found {
		err = json.Unmarshal(raw, &a.IssueTrackerId)
		if err != nil {
			return fmt.Errorf("error reading 'issue.tracker_id': %w", err)
		}
		delete(object, "issue.tracker_id")
	}

	if raw, found := object["issue_id"]; found {
		err = json.Unmarshal(raw, &a.IssueId)
		if err != nil {
			return fmt.Errorf("error reading 'issue_id': %w", err)
		}
		delete(object, "issue_id")
	}

	if raw, found := object["project.status"]; found {
		err = json.Unmarshal(raw, &a.ProjectStatus)
		if err != nil {
			return fmt.Errorf("error reading 'project.status': %w", err)
		}
		delete(object, "project.status")
	}

	if raw, found := object["project_id"]; found {
		err = json.Unmarshal(raw, &a.ProjectId)
		if err != nil {
			return fmt.Errorf("error reading 'project_id': %w", err)
		}
		delete(object, "project_id")
	}

	if raw, found := object["spent_on"]; found {
		err = json.Unmarshal(raw, &a.SpentOn)
		if err != nil {
			return fmt.Errorf("error reading 'spent_on': %w", err)
		}
		delete(object, "spent_on")
	}

	if raw, found := object["subproject_id"]; found {
		err = json.Unmarshal(raw, &a.SubprojectId)
		if err != nil {
			return fmt.Errorf("error reading 'subproject_id': %w", err)
		}
		delete(object, "subproject_id")
	}

	if raw, found := object["user.group"]; found {
		err = json.Unmarshal(raw, &a.UserGroup)
		if err != nil {
			return fmt.Errorf("error reading 'user.group': %w", err)
		}
		delete(object, "user.group")
	}

	if raw, found := object["user.role"]; found {
		err = json.Unmarshal(raw, &a.UserRole)
		if err != nil {
			return fmt.Errorf("error reading 'user.role': %w", err)
		}
		delete(object, "user.role")
	}

	if raw, found := object["user_id"]; found {
		err = json.Unmarshal(raw, &a.UserId)
		if err != nil {
			return fmt.Errorf("error reading 'user_id': %w", err)
		}
		delete(object, "user_id")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for TimelogIndexProjectParams_Query to handle AdditionalProperties
func (a TimelogIndexProjectParams_Query) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.ActivityId != nil {
		object["activity_id"], err = json.Marshal(a.ActivityId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'activity_id': %w", err)
		}
	}

	if a.AuthorId != nil {
		object["author_id"], err = json.Marshal(a.AuthorId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'author_id': %w", err)
		}
	}

	if a.Hours != nil {
		object["hours"], err = json.Marshal(a.Hours)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'hours': %w", err)
		}
	}

	if a.IssueCategoryId != nil {
		object["issue.category_id"], err = json.Marshal(a.IssueCategoryId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'issue.category_id': %w", err)
		}
	}

	if a.IssueComments != nil {
		object["issue.comments"], err = json.Marshal(a.IssueComments)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'issue.comments': %w", err)
		}
	}

	if a.IssueFixedVersionId != nil {
		object["issue.fixed_version_id"], err = json.Marshal(a.IssueFixedVersionId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'issue.fixed_version_id': %w", err)
		}
	}

	if a.IssueParentId != nil {
		object["issue.parent_id"], err = json.Marshal(a.IssueParentId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'issue.parent_id': %w", err)
		}
	}

	if a.IssueStatusId != nil {
		object["issue.status_id"], err = json.Marshal(a.IssueStatusId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'issue.status_id': %w", err)
		}
	}

	if a.IssueSubject != nil {
		object["issue.subject"], err = json.Marshal(a.IssueSubject)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'issue.subject': %w", err)
		}
	}

	if a.IssueTrackerId != nil {
		object["issue.tracker_id"], err = json.Marshal(a.IssueTrackerId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'issue.tracker_id': %w", err)
		}
	}

	if a.IssueId != nil {
		object["issue_id"], err = json.Marshal(a.IssueId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'issue_id': %w", err)
		}
	}

	if a.ProjectStatus != nil {
		object["project.status"], err = json.Marshal(a.ProjectStatus)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'project.status': %w", err)
		}
	}

	if a.ProjectId != nil {
		object["project_id"], err = json.Marshal(a.ProjectId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'project_id': %w", err)
		}
	}

	if a.SpentOn != nil {
		object["spent_on"], err = json.Marshal(a.SpentOn)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'spent_on': %w", err)
		}
	}

	if a.SubprojectId != nil {
		object["subproject_id"], err = json.Marshal(a.SubprojectId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'subproject_id': %w", err)
		}
	}

	if a.UserGroup != nil {
		object["user.group"], err = json.Marshal(a.UserGroup)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'user.group': %w", err)
		}
	}

	if a.UserRole != nil {
		object["user.role"], err = json.Marshal(a.UserRole)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'user.role': %w", err)
		}
	}

	if a.UserId != nil {
		object["user_id"], err = json.Marshal(a.UserId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'user_id': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for TimelogIndexCsvParams_Query. Returns the specified
// element and whether it was found
func (a TimelogIndexCsvParams_Query) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for TimelogIndexCsvParams_Query
func (a *TimelogIndexCsvParams_Query) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for TimelogIndexCsvParams_Query to handle AdditionalProperties
func (a *TimelogIndexCsvParams_Query) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["activity_id"]; found {
		err = json.Unmarshal(raw, &a.ActivityId)
		if err != nil {
			return fmt.Errorf("error reading 'activity_id': %w", err)
		}
		delete(object, "activity_id")
	}

	if raw, found := object["author_id"]; found {
		err = json.Unmarshal(raw, &a.AuthorId)
		if err != nil {
			return fmt.Errorf("error reading 'author_id': %w", err)
		}
		delete(object, "author_id")
	}

	if raw, found := object["hours"]; found {
		err = json.Unmarshal(raw, &a.Hours)
		if err != nil {
			return fmt.Errorf("error reading 'hours': %w", err)
		}
		delete(object, "hours")
	}

	if raw, found := object["issue.category_id"]; found {
		err = json.Unmarshal(raw, &a.IssueCategoryId)
		if err != nil {
			return fmt.Errorf("error reading 'issue.category_id': %w", err)
		}
		delete(object, "issue.category_id")
	}

	if raw, found := object["issue.comments"]; found {
		err = json.Unmarshal(raw, &a.IssueComments)
		if err != nil {
			return fmt.Errorf("error reading 'issue.comments': %w", err)
		}
		delete(object, "issue.comments")
	}

	if raw, found := object["issue.fixed_version_id"]; found {
		err = json.Unmarshal(raw, &a.IssueFixedVersionId)
		if err != nil {
			return fmt.Errorf("error reading 'issue.fixed_version_id': %w", err)
		}
		delete(object, "issue.fixed_version_id")
	}

	if raw, found := object["issue.parent_id"]; found {
		err = json.Unmarshal(raw, &a.IssueParentId)
		if err != nil {
			return fmt.Errorf("error reading 'issue.parent_id': %w", err)
		}
		delete(object, "issue.parent_id")
	}

	if raw, found := object["issue.status_id"]; found {
		err = json.Unmarshal(raw, &a.IssueStatusId)
		if err != nil {
			return fmt.Errorf("error reading 'issue.status_id': %w", err)
		}
		delete(object, "issue.status_id")
	}

	if raw, found := object["issue.subject"]; found {
		err = json.Unmarshal(raw, &a.IssueSubject)
		if err != nil {
			return fmt.Errorf("error reading 'issue.subject': %w", err)
		}
		delete(object, "issue.subject")
	}

	if raw, found := object["issue.tracker_id"]; found {
		err = json.Unmarshal(raw, &a.IssueTrackerId)
		if err != nil {
			return fmt.Errorf("error reading 'issue.tracker_id': %w", err)
		}
		delete(object, "issue.tracker_id")
	}

	if raw, found := object["issue_id"]; found {
		err = json.Unmarshal(raw, &a.IssueId)
		if err != nil {
			return fmt.Errorf("error reading 'issue_id': %w", err)
		}
		delete(object, "issue_id")
	}

	if raw, found := object["project.status"]; found {
		err = json.Unmarshal(raw, &a.ProjectStatus)
		if err != nil {
			return fmt.Errorf("error reading 'project.status': %w", err)
		}
		delete(object, "project.status")
	}

	if raw, found := object["project_id"]; found {
		err = json.Unmarshal(raw, &a.ProjectId)
		if err != nil {
			return fmt.Errorf("error reading 'project_id': %w", err)
		}
		delete(object, "project_id")
	}

	if raw, found := object["spent_on"]; found {
		err = json.Unmarshal(raw, &a.SpentOn)
		if err != nil {
			return fmt.Errorf("error reading 'spent_on': %w", err)
		}
		delete(object, "spent_on")
	}

	if raw, found := object["subproject_id"]; found {
		err = json.Unmarshal(raw, &a.SubprojectId)
		if err != nil {
			return fmt.Errorf("error reading 'subproject_id': %w", err)
		}
		delete(object, "subproject_id")
	}

	if raw, found := object["user.group"]; found {
		err = json.Unmarshal(raw, &a.UserGroup)
		if err != nil {
			return fmt.Errorf("error reading 'user.group': %w", err)
		}
		delete(object, "user.group")
	}

	if raw, found := object["user.role"]; found {
		err = json.Unmarshal(raw, &a.UserRole)
		if err != nil {
			return fmt.Errorf("error reading 'user.role': %w", err)
		}
		delete(object, "user.role")
	}

	if raw, found := object["user_id"]; found {
		err = json.Unmarshal(raw, &a.UserId)
		if err != nil {
			return fmt.Errorf("error reading 'user_id': %w", err)
		}
		delete(object, "user_id")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for TimelogIndexCsvParams_Query to handle AdditionalProperties
func (a TimelogIndexCsvParams_Query) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.ActivityId != nil {
		object["activity_id"], err = json.Marshal(a.ActivityId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'activity_id': %w", err)
		}
	}

	if a.AuthorId != nil {
		object["author_id"], err = json.Marshal(a.AuthorId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'author_id': %w", err)
		}
	}

	if a.Hours != nil {
		object["hours"], err = json.Marshal(a.Hours)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'hours': %w", err)
		}
	}

	if a.IssueCategoryId != nil {
		object["issue.category_id"], err = json.Marshal(a.IssueCategoryId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'issue.category_id': %w", err)
		}
	}

	if a.IssueComments != nil {
		object["issue.comments"], err = json.Marshal(a.IssueComments)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'issue.comments': %w", err)
		}
	}

	if a.IssueFixedVersionId != nil {
		object["issue.fixed_version_id"], err = json.Marshal(a.IssueFixedVersionId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'issue.fixed_version_id': %w", err)
		}
	}

	if a.IssueParentId != nil {
		object["issue.parent_id"], err = json.Marshal(a.IssueParentId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'issue.parent_id': %w", err)
		}
	}

	if a.IssueStatusId != nil {
		object["issue.status_id"], err = json.Marshal(a.IssueStatusId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'issue.status_id': %w", err)
		}
	}

	if a.IssueSubject != nil {
		object["issue.subject"], err = json.Marshal(a.IssueSubject)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'issue.subject': %w", err)
		}
	}

	if a.IssueTrackerId != nil {
		object["issue.tracker_id"], err = json.Marshal(a.IssueTrackerId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'issue.tracker_id': %w", err)
		}
	}

	if a.IssueId != nil {
		object["issue_id"], err = json.Marshal(a.IssueId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'issue_id': %w", err)
		}
	}

	if a.ProjectStatus != nil {
		object["project.status"], err = json.Marshal(a.ProjectStatus)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'project.status': %w", err)
		}
	}

	if a.ProjectId != nil {
		object["project_id"], err = json.Marshal(a.ProjectId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'project_id': %w", err)
		}
	}

	if a.SpentOn != nil {
		object["spent_on"], err = json.Marshal(a.SpentOn)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'spent_on': %w", err)
		}
	}

	if a.SubprojectId != nil {
		object["subproject_id"], err = json.Marshal(a.SubprojectId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'subproject_id': %w", err)
		}
	}

	if a.UserGroup != nil {
		object["user.group"], err = json.Marshal(a.UserGroup)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'user.group': %w", err)
		}
	}

	if a.UserRole != nil {
		object["user.role"], err = json.Marshal(a.UserRole)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'user.role': %w", err)
		}
	}

	if a.UserId != nil {
		object["user_id"], err = json.Marshal(a.UserId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'user_id': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for TimelogIndexParams_Query. Returns the specified
// element and whether it was found
func (a TimelogIndexParams_Query) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for TimelogIndexParams_Query
func (a *TimelogIndexParams_Query) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for TimelogIndexParams_Query to handle AdditionalProperties
func (a *TimelogIndexParams_Query) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["activity_id"]; found {
		err = json.Unmarshal(raw, &a.ActivityId)
		if err != nil {
			return fmt.Errorf("error reading 'activity_id': %w", err)
		}
		delete(object, "activity_id")
	}

	if raw, found := object["author_id"]; found {
		err = json.Unmarshal(raw, &a.AuthorId)
		if err != nil {
			return fmt.Errorf("error reading 'author_id': %w", err)
		}
		delete(object, "author_id")
	}

	if raw, found := object["hours"]; found {
		err = json.Unmarshal(raw, &a.Hours)
		if err != nil {
			return fmt.Errorf("error reading 'hours': %w", err)
		}
		delete(object, "hours")
	}

	if raw, found := object["issue.category_id"]; found {
		err = json.Unmarshal(raw, &a.IssueCategoryId)
		if err != nil {
			return fmt.Errorf("error reading 'issue.category_id': %w", err)
		}
		delete(object, "issue.category_id")
	}

	if raw, found := object["issue.comments"]; found {
		err = json.Unmarshal(raw, &a.IssueComments)
		if err != nil {
			return fmt.Errorf("error reading 'issue.comments': %w", err)
		}
		delete(object, "issue.comments")
	}

	if raw, found := object["issue.fixed_version_id"]; found {
		err = json.Unmarshal(raw, &a.IssueFixedVersionId)
		if err != nil {
			return fmt.Errorf("error reading 'issue.fixed_version_id': %w", err)
		}
		delete(object, "issue.fixed_version_id")
	}

	if raw, found := object["issue.parent_id"]; found {
		err = json.Unmarshal(raw, &a.IssueParentId)
		if err != nil {
			return fmt.Errorf("error reading 'issue.parent_id': %w", err)
		}
		delete(object, "issue.parent_id")
	}

	if raw, found := object["issue.status_id"]; found {
		err = json.Unmarshal(raw, &a.IssueStatusId)
		if err != nil {
			return fmt.Errorf("error reading 'issue.status_id': %w", err)
		}
		delete(object, "issue.status_id")
	}

	if raw, found := object["issue.subject"]; found {
		err = json.Unmarshal(raw, &a.IssueSubject)
		if err != nil {
			return fmt.Errorf("error reading 'issue.subject': %w", err)
		}
		delete(object, "issue.subject")
	}

	if raw, found := object["issue.tracker_id"]; found {
		err = json.Unmarshal(raw, &a.IssueTrackerId)
		if err != nil {
			return fmt.Errorf("error reading 'issue.tracker_id': %w", err)
		}
		delete(object, "issue.tracker_id")
	}

	if raw, found := object["issue_id"]; found {
		err = json.Unmarshal(raw, &a.IssueId)
		if err != nil {
			return fmt.Errorf("error reading 'issue_id': %w", err)
		}
		delete(object, "issue_id")
	}

	if raw, found := object["project.status"]; found {
		err = json.Unmarshal(raw, &a.ProjectStatus)
		if err != nil {
			return fmt.Errorf("error reading 'project.status': %w", err)
		}
		delete(object, "project.status")
	}

	if raw, found := object["project_id"]; found {
		err = json.Unmarshal(raw, &a.ProjectId)
		if err != nil {
			return fmt.Errorf("error reading 'project_id': %w", err)
		}
		delete(object, "project_id")
	}

	if raw, found := object["spent_on"]; found {
		err = json.Unmarshal(raw, &a.SpentOn)
		if err != nil {
			return fmt.Errorf("error reading 'spent_on': %w", err)
		}
		delete(object, "spent_on")
	}

	if raw, found := object["subproject_id"]; found {
		err = json.Unmarshal(raw, &a.SubprojectId)
		if err != nil {
			return fmt.Errorf("error reading 'subproject_id': %w", err)
		}
		delete(object, "subproject_id")
	}

	if raw, found := object["user.group"]; found {
		err = json.Unmarshal(raw, &a.UserGroup)
		if err != nil {
			return fmt.Errorf("error reading 'user.group': %w", err)
		}
		delete(object, "user.group")
	}

	if raw, found := object["user.role"]; found {
		err = json.Unmarshal(raw, &a.UserRole)
		if err != nil {
			return fmt.Errorf("error reading 'user.role': %w", err)
		}
		delete(object, "user.role")
	}

	if raw, found := object["user_id"]; found {
		err = json.Unmarshal(raw, &a.UserId)
		if err != nil {
			return fmt.Errorf("error reading 'user_id': %w", err)
		}
		delete(object, "user_id")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for TimelogIndexParams_Query to handle AdditionalProperties
func (a TimelogIndexParams_Query) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.ActivityId != nil {
		object["activity_id"], err = json.Marshal(a.ActivityId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'activity_id': %w", err)
		}
	}

	if a.AuthorId != nil {
		object["author_id"], err = json.Marshal(a.AuthorId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'author_id': %w", err)
		}
	}

	if a.Hours != nil {
		object["hours"], err = json.Marshal(a.Hours)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'hours': %w", err)
		}
	}

	if a.IssueCategoryId != nil {
		object["issue.category_id"], err = json.Marshal(a.IssueCategoryId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'issue.category_id': %w", err)
		}
	}

	if a.IssueComments != nil {
		object["issue.comments"], err = json.Marshal(a.IssueComments)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'issue.comments': %w", err)
		}
	}

	if a.IssueFixedVersionId != nil {
		object["issue.fixed_version_id"], err = json.Marshal(a.IssueFixedVersionId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'issue.fixed_version_id': %w", err)
		}
	}

	if a.IssueParentId != nil {
		object["issue.parent_id"], err = json.Marshal(a.IssueParentId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'issue.parent_id': %w", err)
		}
	}

	if a.IssueStatusId != nil {
		object["issue.status_id"], err = json.Marshal(a.IssueStatusId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'issue.status_id': %w", err)
		}
	}

	if a.IssueSubject != nil {
		object["issue.subject"], err = json.Marshal(a.IssueSubject)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'issue.subject': %w", err)
		}
	}

	if a.IssueTrackerId != nil {
		object["issue.tracker_id"], err = json.Marshal(a.IssueTrackerId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'issue.tracker_id': %w", err)
		}
	}

	if a.IssueId != nil {
		object["issue_id"], err = json.Marshal(a.IssueId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'issue_id': %w", err)
		}
	}

	if a.ProjectStatus != nil {
		object["project.status"], err = json.Marshal(a.ProjectStatus)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'project.status': %w", err)
		}
	}

	if a.ProjectId != nil {
		object["project_id"], err = json.Marshal(a.ProjectId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'project_id': %w", err)
		}
	}

	if a.SpentOn != nil {
		object["spent_on"], err = json.Marshal(a.SpentOn)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'spent_on': %w", err)
		}
	}

	if a.SubprojectId != nil {
		object["subproject_id"], err = json.Marshal(a.SubprojectId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'subproject_id': %w", err)
		}
	}

	if a.UserGroup != nil {
		object["user.group"], err = json.Marshal(a.UserGroup)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'user.group': %w", err)
		}
	}

	if a.UserRole != nil {
		object["user.role"], err = json.Marshal(a.UserRole)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'user.role': %w", err)
		}
	}

	if a.UserId != nil {
		object["user_id"], err = json.Marshal(a.UserId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'user_id': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for UsersIndexCsvParams_Query. Returns the specified
// element and whether it was found
func (a UsersIndexCsvParams_Query) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for UsersIndexCsvParams_Query
func (a *UsersIndexCsvParams_Query) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for UsersIndexCsvParams_Query to handle AdditionalProperties
func (a *UsersIndexCsvParams_Query) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["admin"]; found {
		err = json.Unmarshal(raw, &a.Admin)
		if err != nil {
			return fmt.Errorf("error reading 'admin': %w", err)
		}
		delete(object, "admin")
	}

	if raw, found := object["auth_source_id"]; found {
		err = json.Unmarshal(raw, &a.AuthSourceId)
		if err != nil {
			return fmt.Errorf("error reading 'auth_source_id': %w", err)
		}
		delete(object, "auth_source_id")
	}

	if raw, found := object["created_on"]; found {
		err = json.Unmarshal(raw, &a.CreatedOn)
		if err != nil {
			return fmt.Errorf("error reading 'created_on': %w", err)
		}
		delete(object, "created_on")
	}

	if raw, found := object["firstname"]; found {
		err = json.Unmarshal(raw, &a.Firstname)
		if err != nil {
			return fmt.Errorf("error reading 'firstname': %w", err)
		}
		delete(object, "firstname")
	}

	if raw, found := object["is_member_of_group"]; found {
		err = json.Unmarshal(raw, &a.IsMemberOfGroup)
		if err != nil {
			return fmt.Errorf("error reading 'is_member_of_group': %w", err)
		}
		delete(object, "is_member_of_group")
	}

	if raw, found := object["last_login_on"]; found {
		err = json.Unmarshal(raw, &a.LastLoginOn)
		if err != nil {
			return fmt.Errorf("error reading 'last_login_on': %w", err)
		}
		delete(object, "last_login_on")
	}

	if raw, found := object["lastname"]; found {
		err = json.Unmarshal(raw, &a.Lastname)
		if err != nil {
			return fmt.Errorf("error reading 'lastname': %w", err)
		}
		delete(object, "lastname")
	}

	if raw, found := object["login"]; found {
		err = json.Unmarshal(raw, &a.Login)
		if err != nil {
			return fmt.Errorf("error reading 'login': %w", err)
		}
		delete(object, "login")
	}

	if raw, found := object["mail"]; found {
		err = json.Unmarshal(raw, &a.Mail)
		if err != nil {
			return fmt.Errorf("error reading 'mail': %w", err)
		}
		delete(object, "mail")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["status"]; found {
		err = json.Unmarshal(raw, &a.Status)
		if err != nil {
			return fmt.Errorf("error reading 'status': %w", err)
		}
		delete(object, "status")
	}

	if raw, found := object["twofa_scheme"]; found {
		err = json.Unmarshal(raw, &a.TwofaScheme)
		if err != nil {
			return fmt.Errorf("error reading 'twofa_scheme': %w", err)
		}
		delete(object, "twofa_scheme")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for UsersIndexCsvParams_Query to handle AdditionalProperties
func (a UsersIndexCsvParams_Query) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Admin != nil {
		object["admin"], err = json.Marshal(a.Admin)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'admin': %w", err)
		}
	}

	if a.AuthSourceId != nil {
		object["auth_source_id"], err = json.Marshal(a.AuthSourceId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'auth_source_id': %w", err)
		}
	}

	if a.CreatedOn != nil {
		object["created_on"], err = json.Marshal(a.CreatedOn)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'created_on': %w", err)
		}
	}

	if a.Firstname != nil {
		object["firstname"], err = json.Marshal(a.Firstname)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'firstname': %w", err)
		}
	}

	if a.IsMemberOfGroup != nil {
		object["is_member_of_group"], err = json.Marshal(a.IsMemberOfGroup)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'is_member_of_group': %w", err)
		}
	}

	if a.LastLoginOn != nil {
		object["last_login_on"], err = json.Marshal(a.LastLoginOn)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'last_login_on': %w", err)
		}
	}

	if a.Lastname != nil {
		object["lastname"], err = json.Marshal(a.Lastname)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'lastname': %w", err)
		}
	}

	if a.Login != nil {
		object["login"], err = json.Marshal(a.Login)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'login': %w", err)
		}
	}

	if a.Mail != nil {
		object["mail"], err = json.Marshal(a.Mail)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'mail': %w", err)
		}
	}

	if a.Name != nil {
		object["name"], err = json.Marshal(a.Name)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'name': %w", err)
		}
	}

	if a.Status != nil {
		object["status"], err = json.Marshal(a.Status)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'status': %w", err)
		}
	}

	if a.TwofaScheme != nil {
		object["twofa_scheme"], err = json.Marshal(a.TwofaScheme)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'twofa_scheme': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for UsersIndexParams_Query. Returns the specified
// element and whether it was found
func (a UsersIndexParams_Query) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for UsersIndexParams_Query
func (a *UsersIndexParams_Query) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for UsersIndexParams_Query to handle AdditionalProperties
func (a *UsersIndexParams_Query) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["admin"]; found {
		err = json.Unmarshal(raw, &a.Admin)
		if err != nil {
			return fmt.Errorf("error reading 'admin': %w", err)
		}
		delete(object, "admin")
	}

	if raw, found := object["auth_source_id"]; found {
		err = json.Unmarshal(raw, &a.AuthSourceId)
		if err != nil {
			return fmt.Errorf("error reading 'auth_source_id': %w", err)
		}
		delete(object, "auth_source_id")
	}

	if raw, found := object["created_on"]; found {
		err = json.Unmarshal(raw, &a.CreatedOn)
		if err != nil {
			return fmt.Errorf("error reading 'created_on': %w", err)
		}
		delete(object, "created_on")
	}

	if raw, found := object["firstname"]; found {
		err = json.Unmarshal(raw, &a.Firstname)
		if err != nil {
			return fmt.Errorf("error reading 'firstname': %w", err)
		}
		delete(object, "firstname")
	}

	if raw, found := object["is_member_of_group"]; found {
		err = json.Unmarshal(raw, &a.IsMemberOfGroup)
		if err != nil {
			return fmt.Errorf("error reading 'is_member_of_group': %w", err)
		}
		delete(object, "is_member_of_group")
	}

	if raw, found := object["last_login_on"]; found {
		err = json.Unmarshal(raw, &a.LastLoginOn)
		if err != nil {
			return fmt.Errorf("error reading 'last_login_on': %w", err)
		}
		delete(object, "last_login_on")
	}

	if raw, found := object["lastname"]; found {
		err = json.Unmarshal(raw, &a.Lastname)
		if err != nil {
			return fmt.Errorf("error reading 'lastname': %w", err)
		}
		delete(object, "lastname")
	}

	if raw, found := object["login"]; found {
		err = json.Unmarshal(raw, &a.Login)
		if err != nil {
			return fmt.Errorf("error reading 'login': %w", err)
		}
		delete(object, "login")
	}

	if raw, found := object["mail"]; found {
		err = json.Unmarshal(raw, &a.Mail)
		if err != nil {
			return fmt.Errorf("error reading 'mail': %w", err)
		}
		delete(object, "mail")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["status"]; found {
		err = json.Unmarshal(raw, &a.Status)
		if err != nil {
			return fmt.Errorf("error reading 'status': %w", err)
		}
		delete(object, "status")
	}

	if raw, found := object["twofa_scheme"]; found {
		err = json.Unmarshal(raw, &a.TwofaScheme)
		if err != nil {
			return fmt.Errorf("error reading 'twofa_scheme': %w", err)
		}
		delete(object, "twofa_scheme")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for UsersIndexParams_Query to handle AdditionalProperties
func (a UsersIndexParams_Query) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Admin != nil {
		object["admin"], err = json.Marshal(a.Admin)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'admin': %w", err)
		}
	}

	if a.AuthSourceId != nil {
		object["auth_source_id"], err = json.Marshal(a.AuthSourceId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'auth_source_id': %w", err)
		}
	}

	if a.CreatedOn != nil {
		object["created_on"], err = json.Marshal(a.CreatedOn)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'created_on': %w", err)
		}
	}

	if a.Firstname != nil {
		object["firstname"], err = json.Marshal(a.Firstname)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'firstname': %w", err)
		}
	}

	if a.IsMemberOfGroup != nil {
		object["is_member_of_group"], err = json.Marshal(a.IsMemberOfGroup)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'is_member_of_group': %w", err)
		}
	}

	if a.LastLoginOn != nil {
		object["last_login_on"], err = json.Marshal(a.LastLoginOn)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'last_login_on': %w", err)
		}
	}

	if a.Lastname != nil {
		object["lastname"], err = json.Marshal(a.Lastname)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'lastname': %w", err)
		}
	}

	if a.Login != nil {
		object["login"], err = json.Marshal(a.Login)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'login': %w", err)
		}
	}

	if a.Mail != nil {
		object["mail"], err = json.Marshal(a.Mail)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'mail': %w", err)
		}
	}

	if a.Name != nil {
		object["name"], err = json.Marshal(a.Name)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'name': %w", err)
		}
	}

	if a.Status != nil {
		object["status"], err = json.Marshal(a.Status)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'status': %w", err)
		}
	}

	if a.TwofaScheme != nil {
		object["twofa_scheme"], err = json.Marshal(a.TwofaScheme)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'twofa_scheme': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// AttachmentsDownload request
	AttachmentsDownload(ctx context.Context, id int, params *AttachmentsDownloadParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AttachmentsThumbnail request
	AttachmentsThumbnail(ctx context.Context, id int, params *AttachmentsThumbnailParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AttachmentsThumbnailSize request
	AttachmentsThumbnailSize(ctx context.Context, id int, size int, params *AttachmentsThumbnailSizeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AttachmentsDestroy request
	AttachmentsDestroy(ctx context.Context, id int, params *AttachmentsDestroyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AttachmentsShow request
	AttachmentsShow(ctx context.Context, id int, params *AttachmentsShowParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AttachmentsUpdatePatchWithBody request with any body
	AttachmentsUpdatePatchWithBody(ctx context.Context, id int, params *AttachmentsUpdatePatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AttachmentsUpdatePatch(ctx context.Context, id int, params *AttachmentsUpdatePatchParams, body AttachmentsUpdatePatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AttachmentsUpdatePutWithBody request with any body
	AttachmentsUpdatePutWithBody(ctx context.Context, id int, params *AttachmentsUpdatePutParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AttachmentsUpdatePut(ctx context.Context, id int, params *AttachmentsUpdatePutParams, body AttachmentsUpdatePutJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AttachmentsDownloadAll request
	AttachmentsDownloadAll(ctx context.Context, objectType string, objectId int, params *AttachmentsDownloadAllParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CustomFieldsIndex request
	CustomFieldsIndex(ctx context.Context, params *CustomFieldsIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnumerationsIndexDocumentCategory request
	EnumerationsIndexDocumentCategory(ctx context.Context, params *EnumerationsIndexDocumentCategoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnumerationsIndexIssuePriority request
	EnumerationsIndexIssuePriority(ctx context.Context, params *EnumerationsIndexIssuePriorityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnumerationsIndexTimeEntryActivity request
	EnumerationsIndexTimeEntryActivity(ctx context.Context, params *EnumerationsIndexTimeEntryActivityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GroupsIndex request
	GroupsIndex(ctx context.Context, params *GroupsIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GroupsCreateWithBody request with any body
	GroupsCreateWithBody(ctx context.Context, params *GroupsCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GroupsCreate(ctx context.Context, params *GroupsCreateParams, body GroupsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GroupsDestroy request
	GroupsDestroy(ctx context.Context, id int, params *GroupsDestroyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GroupsShow request
	GroupsShow(ctx context.Context, id int, params *GroupsShowParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GroupsUpdatePatchWithBody request with any body
	GroupsUpdatePatchWithBody(ctx context.Context, id int, params *GroupsUpdatePatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GroupsUpdatePatch(ctx context.Context, id int, params *GroupsUpdatePatchParams, body GroupsUpdatePatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GroupsUpdatePutWithBody request with any body
	GroupsUpdatePutWithBody(ctx context.Context, id int, params *GroupsUpdatePutParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GroupsUpdatePut(ctx context.Context, id int, params *GroupsUpdatePutParams, body GroupsUpdatePutJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GroupsAddUsersWithBody request with any body
	GroupsAddUsersWithBody(ctx context.Context, id int, params *GroupsAddUsersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GroupsAddUsers(ctx context.Context, id int, params *GroupsAddUsersParams, body GroupsAddUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GroupsRemoveUser request
	GroupsRemoveUser(ctx context.Context, id int, userId int, params *GroupsRemoveUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IssueCategoriesDestroy request
	IssueCategoriesDestroy(ctx context.Context, id int, params *IssueCategoriesDestroyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IssueCategoriesShow request
	IssueCategoriesShow(ctx context.Context, id int, params *IssueCategoriesShowParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IssueCategoriesUpdatePatchWithBody request with any body
	IssueCategoriesUpdatePatchWithBody(ctx context.Context, id int, params *IssueCategoriesUpdatePatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	IssueCategoriesUpdatePatch(ctx context.Context, id int, params *IssueCategoriesUpdatePatchParams, body IssueCategoriesUpdatePatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IssueCategoriesUpdatePutWithBody request with any body
	IssueCategoriesUpdatePutWithBody(ctx context.Context, id int, params *IssueCategoriesUpdatePutParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	IssueCategoriesUpdatePut(ctx context.Context, id int, params *IssueCategoriesUpdatePutParams, body IssueCategoriesUpdatePutJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IssueStatusesIndex request
	IssueStatusesIndex(ctx context.Context, params *IssueStatusesIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IssuesIndexCsv request
	IssuesIndexCsv(ctx context.Context, params *IssuesIndexCsvParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IssuesIndex request
	IssuesIndex(ctx context.Context, params *IssuesIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IssuesCreateWithBody request with any body
	IssuesCreateWithBody(ctx context.Context, params *IssuesCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	IssuesCreate(ctx context.Context, params *IssuesCreateParams, body IssuesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IssuesIndexPdf request
	IssuesIndexPdf(ctx context.Context, params *IssuesIndexPdfParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GanttsShowPdf request
	GanttsShowPdf(ctx context.Context, params *GanttsShowPdfParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GanttsShowPng request
	GanttsShowPng(ctx context.Context, params *GanttsShowPngParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IssuesDestroy request
	IssuesDestroy(ctx context.Context, id int, params *IssuesDestroyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IssuesShow request
	IssuesShow(ctx context.Context, id int, params *IssuesShowParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IssuesUpdatePatchWithBody request with any body
	IssuesUpdatePatchWithBody(ctx context.Context, id int, params *IssuesUpdatePatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	IssuesUpdatePatch(ctx context.Context, id int, params *IssuesUpdatePatchParams, body IssuesUpdatePatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IssuesUpdatePutWithBody request with any body
	IssuesUpdatePutWithBody(ctx context.Context, id int, params *IssuesUpdatePutParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	IssuesUpdatePut(ctx context.Context, id int, params *IssuesUpdatePutParams, body IssuesUpdatePutJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IssuesShowPdf request
	IssuesShowPdf(ctx context.Context, id int, params *IssuesShowPdfParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IssueRelationsIndex request
	IssueRelationsIndex(ctx context.Context, issueId int, params *IssueRelationsIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IssueRelationsCreateWithBody request with any body
	IssueRelationsCreateWithBody(ctx context.Context, issueId int, params *IssueRelationsCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	IssueRelationsCreate(ctx context.Context, issueId int, params *IssueRelationsCreateParams, body IssueRelationsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TimelogCreateIssueWithBody request with any body
	TimelogCreateIssueWithBody(ctx context.Context, issueId int, params *TimelogCreateIssueParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TimelogCreateIssue(ctx context.Context, issueId int, params *TimelogCreateIssueParams, body TimelogCreateIssueJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WatchersCreateIssueWithBody request with any body
	WatchersCreateIssueWithBody(ctx context.Context, issueId int, params *WatchersCreateIssueParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	WatchersCreateIssue(ctx context.Context, issueId int, params *WatchersCreateIssueParams, body WatchersCreateIssueJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WatchersDestroyIssue request
	WatchersDestroyIssue(ctx context.Context, issueId int, userId int, params *WatchersDestroyIssueParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// JournalsUpdatePatchWithBody request with any body
	JournalsUpdatePatchWithBody(ctx context.Context, id int, params *JournalsUpdatePatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	JournalsUpdatePatch(ctx context.Context, id int, params *JournalsUpdatePatchParams, body JournalsUpdatePatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// JournalsUpdatePutWithBody request with any body
	JournalsUpdatePutWithBody(ctx context.Context, id int, params *JournalsUpdatePutParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	JournalsUpdatePut(ctx context.Context, id int, params *JournalsUpdatePutParams, body JournalsUpdatePutJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MembersDestroy request
	MembersDestroy(ctx context.Context, id int, params *MembersDestroyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MembersShow request
	MembersShow(ctx context.Context, id int, params *MembersShowParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MembersUpdatePatchWithBody request with any body
	MembersUpdatePatchWithBody(ctx context.Context, id int, params *MembersUpdatePatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MembersUpdatePatch(ctx context.Context, id int, params *MembersUpdatePatchParams, body MembersUpdatePatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MembersUpdatePutWithBody request with any body
	MembersUpdatePutWithBody(ctx context.Context, id int, params *MembersUpdatePutParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MembersUpdatePut(ctx context.Context, id int, params *MembersUpdatePutParams, body MembersUpdatePutJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MyAccount request
	MyAccount(ctx context.Context, params *MyAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MyAccountPutWithBody request with any body
	MyAccountPutWithBody(ctx context.Context, params *MyAccountPutParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MyAccountPut(ctx context.Context, params *MyAccountPutParams, body MyAccountPutJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NewsIndex request
	NewsIndex(ctx context.Context, params *NewsIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NewsCreateWithBody request with any body
	NewsCreateWithBody(ctx context.Context, params *NewsCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NewsCreate(ctx context.Context, params *NewsCreateParams, body NewsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NewsDestroy request
	NewsDestroy(ctx context.Context, id int, params *NewsDestroyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NewsShow request
	NewsShow(ctx context.Context, id int, params *NewsShowParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NewsUpdatePatchWithBody request with any body
	NewsUpdatePatchWithBody(ctx context.Context, id int, params *NewsUpdatePatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NewsUpdatePatch(ctx context.Context, id int, params *NewsUpdatePatchParams, body NewsUpdatePatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NewsUpdatePutWithBody request with any body
	NewsUpdatePutWithBody(ctx context.Context, id int, params *NewsUpdatePutParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NewsUpdatePut(ctx context.Context, id int, params *NewsUpdatePutParams, body NewsUpdatePutJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectsIndexCsv request
	ProjectsIndexCsv(ctx context.Context, params *ProjectsIndexCsvParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectsIndex request
	ProjectsIndex(ctx context.Context, params *ProjectsIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectsCreateWithBody request with any body
	ProjectsCreateWithBody(ctx context.Context, params *ProjectsCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ProjectsCreate(ctx context.Context, params *ProjectsCreateParams, body ProjectsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectsDestroy request
	ProjectsDestroy(ctx context.Context, id string, params *ProjectsDestroyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectsShow request
	ProjectsShow(ctx context.Context, id string, params *ProjectsShowParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectsUpdatePatchWithBody request with any body
	ProjectsUpdatePatchWithBody(ctx context.Context, id string, params *ProjectsUpdatePatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ProjectsUpdatePatch(ctx context.Context, id string, params *ProjectsUpdatePatchParams, body ProjectsUpdatePatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectsUpdatePutWithBody request with any body
	ProjectsUpdatePutWithBody(ctx context.Context, id string, params *ProjectsUpdatePutParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ProjectsUpdatePut(ctx context.Context, id string, params *ProjectsUpdatePutParams, body ProjectsUpdatePutJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectsArchivePost request
	ProjectsArchivePost(ctx context.Context, id string, params *ProjectsArchivePostParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectsArchivePut request
	ProjectsArchivePut(ctx context.Context, id string, params *ProjectsArchivePutParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RepositoriesAddRelatedIssueWithBody request with any body
	RepositoriesAddRelatedIssueWithBody(ctx context.Context, id string, repositoryId string, rev string, params *RepositoriesAddRelatedIssueParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RepositoriesAddRelatedIssue(ctx context.Context, id string, repositoryId string, rev string, params *RepositoriesAddRelatedIssueParams, body RepositoriesAddRelatedIssueJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RepositoriesRemoveRelatedIssue request
	RepositoriesRemoveRelatedIssue(ctx context.Context, id string, repositoryId string, rev string, issueId int, params *RepositoriesRemoveRelatedIssueParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectsUnarchivePost request
	ProjectsUnarchivePost(ctx context.Context, id string, params *ProjectsUnarchivePostParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectsUnarchivePut request
	ProjectsUnarchivePut(ctx context.Context, id string, params *ProjectsUnarchivePutParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FilesIndex request
	FilesIndex(ctx context.Context, projectId string, params *FilesIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FilesCreateWithBody request with any body
	FilesCreateWithBody(ctx context.Context, projectId string, params *FilesCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FilesCreate(ctx context.Context, projectId string, params *FilesCreateParams, body FilesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IssueCategoriesIndex request
	IssueCategoriesIndex(ctx context.Context, projectId string, params *IssueCategoriesIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IssueCategoriesCreateWithBody request with any body
	IssueCategoriesCreateWithBody(ctx context.Context, projectId string, params *IssueCategoriesCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	IssueCategoriesCreate(ctx context.Context, projectId string, params *IssueCategoriesCreateParams, body IssueCategoriesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IssuesIndexProjectCsv request
	IssuesIndexProjectCsv(ctx context.Context, projectId string, params *IssuesIndexProjectCsvParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IssuesIndexProject request
	IssuesIndexProject(ctx context.Context, projectId string, params *IssuesIndexProjectParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IssuesCreateProjectWithBody request with any body
	IssuesCreateProjectWithBody(ctx context.Context, projectId string, params *IssuesCreateProjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	IssuesCreateProject(ctx context.Context, projectId string, params *IssuesCreateProjectParams, body IssuesCreateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IssuesIndexProjectPdf request
	IssuesIndexProjectPdf(ctx context.Context, projectId string, params *IssuesIndexProjectPdfParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GanttsShowProjectPdf request
	GanttsShowProjectPdf(ctx context.Context, projectId string, params *GanttsShowProjectPdfParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GanttsShowProjectPng request
	GanttsShowProjectPng(ctx context.Context, projectId string, params *GanttsShowProjectPngParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MembersIndex request
	MembersIndex(ctx context.Context, projectId string, params *MembersIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MembersCreateWithBody request with any body
	MembersCreateWithBody(ctx context.Context, projectId string, params *MembersCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MembersCreate(ctx context.Context, projectId string, params *MembersCreateParams, body MembersCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NewsIndexProject request
	NewsIndexProject(ctx context.Context, projectId string, params *NewsIndexProjectParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NewsCreateProjectWithBody request with any body
	NewsCreateProjectWithBody(ctx context.Context, projectId string, params *NewsCreateProjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NewsCreateProject(ctx context.Context, projectId string, params *NewsCreateProjectParams, body NewsCreateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchIndexProject request
	SearchIndexProject(ctx context.Context, projectId string, params *SearchIndexProjectParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TimelogIndexProjectCsv request
	TimelogIndexProjectCsv(ctx context.Context, projectId string, params *TimelogIndexProjectCsvParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TimelogIndexProject request
	TimelogIndexProject(ctx context.Context, projectId string, params *TimelogIndexProjectParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TimelogCreateProjectWithBody request with any body
	TimelogCreateProjectWithBody(ctx context.Context, projectId string, params *TimelogCreateProjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TimelogCreateProject(ctx context.Context, projectId string, params *TimelogCreateProjectParams, body TimelogCreateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VersionsIndex request
	VersionsIndex(ctx context.Context, projectId string, params *VersionsIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VersionsCreateWithBody request with any body
	VersionsCreateWithBody(ctx context.Context, projectId string, params *VersionsCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	VersionsCreate(ctx context.Context, projectId string, params *VersionsCreateParams, body VersionsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WikiShowRoot request
	WikiShowRoot(ctx context.Context, projectId string, params *WikiShowRootParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WikiIndex request
	WikiIndex(ctx context.Context, projectId string, params *WikiIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WikiDestroy request
	WikiDestroy(ctx context.Context, projectId string, id string, params *WikiDestroyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WikiShow request
	WikiShow(ctx context.Context, projectId string, id string, params *WikiShowParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WikiUpdatePatchWithBody request with any body
	WikiUpdatePatchWithBody(ctx context.Context, projectId string, id string, params *WikiUpdatePatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	WikiUpdatePatch(ctx context.Context, projectId string, id string, params *WikiUpdatePatchParams, body WikiUpdatePatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WikiUpdatePutWithBody request with any body
	WikiUpdatePutWithBody(ctx context.Context, projectId string, id string, params *WikiUpdatePutParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	WikiUpdatePut(ctx context.Context, projectId string, id string, params *WikiUpdatePutParams, body WikiUpdatePutJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WikiShowPdf request
	WikiShowPdf(ctx context.Context, projectId string, id string, params *WikiShowPdfParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WikiShowTxt request
	WikiShowTxt(ctx context.Context, projectId string, id string, params *WikiShowTxtParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WikiShowVersion request
	WikiShowVersion(ctx context.Context, projectId string, id string, version int, params *WikiShowVersionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WikiShowVersionPdf request
	WikiShowVersionPdf(ctx context.Context, projectId string, id string, version int, params *WikiShowVersionPdfParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WikiShowVersionTxt request
	WikiShowVersionTxt(ctx context.Context, projectId string, id string, version int, params *WikiShowVersionTxtParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// QueriesIndex request
	QueriesIndex(ctx context.Context, params *QueriesIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IssueRelationsDestroy request
	IssueRelationsDestroy(ctx context.Context, id int, params *IssueRelationsDestroyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IssueRelationsShow request
	IssueRelationsShow(ctx context.Context, id int, params *IssueRelationsShowParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RolesIndex request
	RolesIndex(ctx context.Context, params *RolesIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RolesShow request
	RolesShow(ctx context.Context, id int, params *RolesShowParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchIndex request
	SearchIndex(ctx context.Context, params *SearchIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TimelogIndexCsv request
	TimelogIndexCsv(ctx context.Context, params *TimelogIndexCsvParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TimelogIndex request
	TimelogIndex(ctx context.Context, params *TimelogIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TimelogCreateWithBody request with any body
	TimelogCreateWithBody(ctx context.Context, params *TimelogCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TimelogCreate(ctx context.Context, params *TimelogCreateParams, body TimelogCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TimelogDestroy request
	TimelogDestroy(ctx context.Context, id int, params *TimelogDestroyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TimelogShow request
	TimelogShow(ctx context.Context, id int, params *TimelogShowParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TimelogUpdatePatchWithBody request with any body
	TimelogUpdatePatchWithBody(ctx context.Context, id int, params *TimelogUpdatePatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TimelogUpdatePatch(ctx context.Context, id int, params *TimelogUpdatePatchParams, body TimelogUpdatePatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TimelogUpdatePutWithBody request with any body
	TimelogUpdatePutWithBody(ctx context.Context, id int, params *TimelogUpdatePutParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TimelogUpdatePut(ctx context.Context, id int, params *TimelogUpdatePutParams, body TimelogUpdatePutJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TrackersIndex request
	TrackersIndex(ctx context.Context, params *TrackersIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AttachmentsUploadWithBody request with any body
	AttachmentsUploadWithBody(ctx context.Context, params *AttachmentsUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UsersIndexCsv request
	UsersIndexCsv(ctx context.Context, params *UsersIndexCsvParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UsersIndex request
	UsersIndex(ctx context.Context, params *UsersIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UsersCreateWithBody request with any body
	UsersCreateWithBody(ctx context.Context, params *UsersCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UsersCreate(ctx context.Context, params *UsersCreateParams, body UsersCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UsersDestroy request
	UsersDestroy(ctx context.Context, id string, params *UsersDestroyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UsersShow request
	UsersShow(ctx context.Context, id string, params *UsersShowParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UsersUpdatePatchWithBody request with any body
	UsersUpdatePatchWithBody(ctx context.Context, id string, params *UsersUpdatePatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UsersUpdatePatch(ctx context.Context, id string, params *UsersUpdatePatchParams, body UsersUpdatePatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UsersUpdatePutWithBody request with any body
	UsersUpdatePutWithBody(ctx context.Context, id string, params *UsersUpdatePutParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UsersUpdatePut(ctx context.Context, id string, params *UsersUpdatePutParams, body UsersUpdatePutJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VersionsDestroy request
	VersionsDestroy(ctx context.Context, id int, params *VersionsDestroyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VersionsShow request
	VersionsShow(ctx context.Context, id int, params *VersionsShowParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VersionsUpdatePatchWithBody request with any body
	VersionsUpdatePatchWithBody(ctx context.Context, id int, params *VersionsUpdatePatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	VersionsUpdatePatch(ctx context.Context, id int, params *VersionsUpdatePatchParams, body VersionsUpdatePatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VersionsUpdatePutWithBody request with any body
	VersionsUpdatePutWithBody(ctx context.Context, id int, params *VersionsUpdatePutParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	VersionsUpdatePut(ctx context.Context, id int, params *VersionsUpdatePutParams, body VersionsUpdatePutJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VersionsShowTxt request
	VersionsShowTxt(ctx context.Context, id int, params *VersionsShowTxtParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WatchersDestroy request
	WatchersDestroy(ctx context.Context, params *WatchersDestroyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WatchersCreateWithBody request with any body
	WatchersCreateWithBody(ctx context.Context, params *WatchersCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	WatchersCreate(ctx context.Context, params *WatchersCreateParams, body WatchersCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) AttachmentsDownload(ctx context.Context, id int, params *AttachmentsDownloadParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachmentsDownloadRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachmentsThumbnail(ctx context.Context, id int, params *AttachmentsThumbnailParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachmentsThumbnailRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachmentsThumbnailSize(ctx context.Context, id int, size int, params *AttachmentsThumbnailSizeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachmentsThumbnailSizeRequest(c.Server, id, size, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachmentsDestroy(ctx context.Context, id int, params *AttachmentsDestroyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachmentsDestroyRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachmentsShow(ctx context.Context, id int, params *AttachmentsShowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachmentsShowRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachmentsUpdatePatchWithBody(ctx context.Context, id int, params *AttachmentsUpdatePatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachmentsUpdatePatchRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachmentsUpdatePatch(ctx context.Context, id int, params *AttachmentsUpdatePatchParams, body AttachmentsUpdatePatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachmentsUpdatePatchRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachmentsUpdatePutWithBody(ctx context.Context, id int, params *AttachmentsUpdatePutParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachmentsUpdatePutRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachmentsUpdatePut(ctx context.Context, id int, params *AttachmentsUpdatePutParams, body AttachmentsUpdatePutJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachmentsUpdatePutRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachmentsDownloadAll(ctx context.Context, objectType string, objectId int, params *AttachmentsDownloadAllParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachmentsDownloadAllRequest(c.Server, objectType, objectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CustomFieldsIndex(ctx context.Context, params *CustomFieldsIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCustomFieldsIndexRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnumerationsIndexDocumentCategory(ctx context.Context, params *EnumerationsIndexDocumentCategoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnumerationsIndexDocumentCategoryRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnumerationsIndexIssuePriority(ctx context.Context, params *EnumerationsIndexIssuePriorityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnumerationsIndexIssuePriorityRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnumerationsIndexTimeEntryActivity(ctx context.Context, params *EnumerationsIndexTimeEntryActivityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnumerationsIndexTimeEntryActivityRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GroupsIndex(ctx context.Context, params *GroupsIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGroupsIndexRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GroupsCreateWithBody(ctx context.Context, params *GroupsCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGroupsCreateRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GroupsCreate(ctx context.Context, params *GroupsCreateParams, body GroupsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGroupsCreateRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GroupsDestroy(ctx context.Context, id int, params *GroupsDestroyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGroupsDestroyRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GroupsShow(ctx context.Context, id int, params *GroupsShowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGroupsShowRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GroupsUpdatePatchWithBody(ctx context.Context, id int, params *GroupsUpdatePatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGroupsUpdatePatchRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GroupsUpdatePatch(ctx context.Context, id int, params *GroupsUpdatePatchParams, body GroupsUpdatePatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGroupsUpdatePatchRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GroupsUpdatePutWithBody(ctx context.Context, id int, params *GroupsUpdatePutParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGroupsUpdatePutRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GroupsUpdatePut(ctx context.Context, id int, params *GroupsUpdatePutParams, body GroupsUpdatePutJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGroupsUpdatePutRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GroupsAddUsersWithBody(ctx context.Context, id int, params *GroupsAddUsersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGroupsAddUsersRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GroupsAddUsers(ctx context.Context, id int, params *GroupsAddUsersParams, body GroupsAddUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGroupsAddUsersRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GroupsRemoveUser(ctx context.Context, id int, userId int, params *GroupsRemoveUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGroupsRemoveUserRequest(c.Server, id, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssueCategoriesDestroy(ctx context.Context, id int, params *IssueCategoriesDestroyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssueCategoriesDestroyRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssueCategoriesShow(ctx context.Context, id int, params *IssueCategoriesShowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssueCategoriesShowRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssueCategoriesUpdatePatchWithBody(ctx context.Context, id int, params *IssueCategoriesUpdatePatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssueCategoriesUpdatePatchRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssueCategoriesUpdatePatch(ctx context.Context, id int, params *IssueCategoriesUpdatePatchParams, body IssueCategoriesUpdatePatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssueCategoriesUpdatePatchRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssueCategoriesUpdatePutWithBody(ctx context.Context, id int, params *IssueCategoriesUpdatePutParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssueCategoriesUpdatePutRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssueCategoriesUpdatePut(ctx context.Context, id int, params *IssueCategoriesUpdatePutParams, body IssueCategoriesUpdatePutJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssueCategoriesUpdatePutRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssueStatusesIndex(ctx context.Context, params *IssueStatusesIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssueStatusesIndexRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssuesIndexCsv(ctx context.Context, params *IssuesIndexCsvParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssuesIndexCsvRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssuesIndex(ctx context.Context, params *IssuesIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssuesIndexRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssuesCreateWithBody(ctx context.Context, params *IssuesCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssuesCreateRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssuesCreate(ctx context.Context, params *IssuesCreateParams, body IssuesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssuesCreateRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssuesIndexPdf(ctx context.Context, params *IssuesIndexPdfParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssuesIndexPdfRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GanttsShowPdf(ctx context.Context, params *GanttsShowPdfParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGanttsShowPdfRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GanttsShowPng(ctx context.Context, params *GanttsShowPngParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGanttsShowPngRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssuesDestroy(ctx context.Context, id int, params *IssuesDestroyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssuesDestroyRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssuesShow(ctx context.Context, id int, params *IssuesShowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssuesShowRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssuesUpdatePatchWithBody(ctx context.Context, id int, params *IssuesUpdatePatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssuesUpdatePatchRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssuesUpdatePatch(ctx context.Context, id int, params *IssuesUpdatePatchParams, body IssuesUpdatePatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssuesUpdatePatchRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssuesUpdatePutWithBody(ctx context.Context, id int, params *IssuesUpdatePutParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssuesUpdatePutRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssuesUpdatePut(ctx context.Context, id int, params *IssuesUpdatePutParams, body IssuesUpdatePutJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssuesUpdatePutRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssuesShowPdf(ctx context.Context, id int, params *IssuesShowPdfParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssuesShowPdfRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssueRelationsIndex(ctx context.Context, issueId int, params *IssueRelationsIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssueRelationsIndexRequest(c.Server, issueId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssueRelationsCreateWithBody(ctx context.Context, issueId int, params *IssueRelationsCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssueRelationsCreateRequestWithBody(c.Server, issueId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssueRelationsCreate(ctx context.Context, issueId int, params *IssueRelationsCreateParams, body IssueRelationsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssueRelationsCreateRequest(c.Server, issueId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TimelogCreateIssueWithBody(ctx context.Context, issueId int, params *TimelogCreateIssueParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTimelogCreateIssueRequestWithBody(c.Server, issueId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TimelogCreateIssue(ctx context.Context, issueId int, params *TimelogCreateIssueParams, body TimelogCreateIssueJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTimelogCreateIssueRequest(c.Server, issueId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WatchersCreateIssueWithBody(ctx context.Context, issueId int, params *WatchersCreateIssueParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWatchersCreateIssueRequestWithBody(c.Server, issueId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WatchersCreateIssue(ctx context.Context, issueId int, params *WatchersCreateIssueParams, body WatchersCreateIssueJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWatchersCreateIssueRequest(c.Server, issueId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WatchersDestroyIssue(ctx context.Context, issueId int, userId int, params *WatchersDestroyIssueParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWatchersDestroyIssueRequest(c.Server, issueId, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JournalsUpdatePatchWithBody(ctx context.Context, id int, params *JournalsUpdatePatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJournalsUpdatePatchRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JournalsUpdatePatch(ctx context.Context, id int, params *JournalsUpdatePatchParams, body JournalsUpdatePatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJournalsUpdatePatchRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JournalsUpdatePutWithBody(ctx context.Context, id int, params *JournalsUpdatePutParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJournalsUpdatePutRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JournalsUpdatePut(ctx context.Context, id int, params *JournalsUpdatePutParams, body JournalsUpdatePutJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJournalsUpdatePutRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MembersDestroy(ctx context.Context, id int, params *MembersDestroyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMembersDestroyRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MembersShow(ctx context.Context, id int, params *MembersShowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMembersShowRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MembersUpdatePatchWithBody(ctx context.Context, id int, params *MembersUpdatePatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMembersUpdatePatchRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MembersUpdatePatch(ctx context.Context, id int, params *MembersUpdatePatchParams, body MembersUpdatePatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMembersUpdatePatchRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MembersUpdatePutWithBody(ctx context.Context, id int, params *MembersUpdatePutParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMembersUpdatePutRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MembersUpdatePut(ctx context.Context, id int, params *MembersUpdatePutParams, body MembersUpdatePutJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMembersUpdatePutRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MyAccount(ctx context.Context, params *MyAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMyAccountRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MyAccountPutWithBody(ctx context.Context, params *MyAccountPutParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMyAccountPutRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MyAccountPut(ctx context.Context, params *MyAccountPutParams, body MyAccountPutJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMyAccountPutRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NewsIndex(ctx context.Context, params *NewsIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNewsIndexRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NewsCreateWithBody(ctx context.Context, params *NewsCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNewsCreateRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NewsCreate(ctx context.Context, params *NewsCreateParams, body NewsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNewsCreateRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NewsDestroy(ctx context.Context, id int, params *NewsDestroyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNewsDestroyRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NewsShow(ctx context.Context, id int, params *NewsShowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNewsShowRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NewsUpdatePatchWithBody(ctx context.Context, id int, params *NewsUpdatePatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNewsUpdatePatchRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NewsUpdatePatch(ctx context.Context, id int, params *NewsUpdatePatchParams, body NewsUpdatePatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNewsUpdatePatchRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NewsUpdatePutWithBody(ctx context.Context, id int, params *NewsUpdatePutParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNewsUpdatePutRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NewsUpdatePut(ctx context.Context, id int, params *NewsUpdatePutParams, body NewsUpdatePutJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNewsUpdatePutRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectsIndexCsv(ctx context.Context, params *ProjectsIndexCsvParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectsIndexCsvRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectsIndex(ctx context.Context, params *ProjectsIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectsIndexRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectsCreateWithBody(ctx context.Context, params *ProjectsCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectsCreateRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectsCreate(ctx context.Context, params *ProjectsCreateParams, body ProjectsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectsCreateRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectsDestroy(ctx context.Context, id string, params *ProjectsDestroyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectsDestroyRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectsShow(ctx context.Context, id string, params *ProjectsShowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectsShowRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectsUpdatePatchWithBody(ctx context.Context, id string, params *ProjectsUpdatePatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectsUpdatePatchRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectsUpdatePatch(ctx context.Context, id string, params *ProjectsUpdatePatchParams, body ProjectsUpdatePatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectsUpdatePatchRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectsUpdatePutWithBody(ctx context.Context, id string, params *ProjectsUpdatePutParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectsUpdatePutRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectsUpdatePut(ctx context.Context, id string, params *ProjectsUpdatePutParams, body ProjectsUpdatePutJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectsUpdatePutRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectsArchivePost(ctx context.Context, id string, params *ProjectsArchivePostParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectsArchivePostRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectsArchivePut(ctx context.Context, id string, params *ProjectsArchivePutParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectsArchivePutRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RepositoriesAddRelatedIssueWithBody(ctx context.Context, id string, repositoryId string, rev string, params *RepositoriesAddRelatedIssueParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRepositoriesAddRelatedIssueRequestWithBody(c.Server, id, repositoryId, rev, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RepositoriesAddRelatedIssue(ctx context.Context, id string, repositoryId string, rev string, params *RepositoriesAddRelatedIssueParams, body RepositoriesAddRelatedIssueJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRepositoriesAddRelatedIssueRequest(c.Server, id, repositoryId, rev, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RepositoriesRemoveRelatedIssue(ctx context.Context, id string, repositoryId string, rev string, issueId int, params *RepositoriesRemoveRelatedIssueParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRepositoriesRemoveRelatedIssueRequest(c.Server, id, repositoryId, rev, issueId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectsUnarchivePost(ctx context.Context, id string, params *ProjectsUnarchivePostParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectsUnarchivePostRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectsUnarchivePut(ctx context.Context, id string, params *ProjectsUnarchivePutParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectsUnarchivePutRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FilesIndex(ctx context.Context, projectId string, params *FilesIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFilesIndexRequest(c.Server, projectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FilesCreateWithBody(ctx context.Context, projectId string, params *FilesCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFilesCreateRequestWithBody(c.Server, projectId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FilesCreate(ctx context.Context, projectId string, params *FilesCreateParams, body FilesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFilesCreateRequest(c.Server, projectId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssueCategoriesIndex(ctx context.Context, projectId string, params *IssueCategoriesIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssueCategoriesIndexRequest(c.Server, projectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssueCategoriesCreateWithBody(ctx context.Context, projectId string, params *IssueCategoriesCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssueCategoriesCreateRequestWithBody(c.Server, projectId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssueCategoriesCreate(ctx context.Context, projectId string, params *IssueCategoriesCreateParams, body IssueCategoriesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssueCategoriesCreateRequest(c.Server, projectId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssuesIndexProjectCsv(ctx context.Context, projectId string, params *IssuesIndexProjectCsvParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssuesIndexProjectCsvRequest(c.Server, projectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssuesIndexProject(ctx context.Context, projectId string, params *IssuesIndexProjectParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssuesIndexProjectRequest(c.Server, projectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssuesCreateProjectWithBody(ctx context.Context, projectId string, params *IssuesCreateProjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssuesCreateProjectRequestWithBody(c.Server, projectId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssuesCreateProject(ctx context.Context, projectId string, params *IssuesCreateProjectParams, body IssuesCreateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssuesCreateProjectRequest(c.Server, projectId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssuesIndexProjectPdf(ctx context.Context, projectId string, params *IssuesIndexProjectPdfParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssuesIndexProjectPdfRequest(c.Server, projectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GanttsShowProjectPdf(ctx context.Context, projectId string, params *GanttsShowProjectPdfParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGanttsShowProjectPdfRequest(c.Server, projectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GanttsShowProjectPng(ctx context.Context, projectId string, params *GanttsShowProjectPngParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGanttsShowProjectPngRequest(c.Server, projectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MembersIndex(ctx context.Context, projectId string, params *MembersIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMembersIndexRequest(c.Server, projectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MembersCreateWithBody(ctx context.Context, projectId string, params *MembersCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMembersCreateRequestWithBody(c.Server, projectId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MembersCreate(ctx context.Context, projectId string, params *MembersCreateParams, body MembersCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMembersCreateRequest(c.Server, projectId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NewsIndexProject(ctx context.Context, projectId string, params *NewsIndexProjectParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNewsIndexProjectRequest(c.Server, projectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NewsCreateProjectWithBody(ctx context.Context, projectId string, params *NewsCreateProjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNewsCreateProjectRequestWithBody(c.Server, projectId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NewsCreateProject(ctx context.Context, projectId string, params *NewsCreateProjectParams, body NewsCreateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNewsCreateProjectRequest(c.Server, projectId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchIndexProject(ctx context.Context, projectId string, params *SearchIndexProjectParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchIndexProjectRequest(c.Server, projectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TimelogIndexProjectCsv(ctx context.Context, projectId string, params *TimelogIndexProjectCsvParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTimelogIndexProjectCsvRequest(c.Server, projectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TimelogIndexProject(ctx context.Context, projectId string, params *TimelogIndexProjectParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTimelogIndexProjectRequest(c.Server, projectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TimelogCreateProjectWithBody(ctx context.Context, projectId string, params *TimelogCreateProjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTimelogCreateProjectRequestWithBody(c.Server, projectId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TimelogCreateProject(ctx context.Context, projectId string, params *TimelogCreateProjectParams, body TimelogCreateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTimelogCreateProjectRequest(c.Server, projectId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VersionsIndex(ctx context.Context, projectId string, params *VersionsIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVersionsIndexRequest(c.Server, projectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VersionsCreateWithBody(ctx context.Context, projectId string, params *VersionsCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVersionsCreateRequestWithBody(c.Server, projectId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VersionsCreate(ctx context.Context, projectId string, params *VersionsCreateParams, body VersionsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVersionsCreateRequest(c.Server, projectId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WikiShowRoot(ctx context.Context, projectId string, params *WikiShowRootParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWikiShowRootRequest(c.Server, projectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WikiIndex(ctx context.Context, projectId string, params *WikiIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWikiIndexRequest(c.Server, projectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WikiDestroy(ctx context.Context, projectId string, id string, params *WikiDestroyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWikiDestroyRequest(c.Server, projectId, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WikiShow(ctx context.Context, projectId string, id string, params *WikiShowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWikiShowRequest(c.Server, projectId, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WikiUpdatePatchWithBody(ctx context.Context, projectId string, id string, params *WikiUpdatePatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWikiUpdatePatchRequestWithBody(c.Server, projectId, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WikiUpdatePatch(ctx context.Context, projectId string, id string, params *WikiUpdatePatchParams, body WikiUpdatePatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWikiUpdatePatchRequest(c.Server, projectId, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WikiUpdatePutWithBody(ctx context.Context, projectId string, id string, params *WikiUpdatePutParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWikiUpdatePutRequestWithBody(c.Server, projectId, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WikiUpdatePut(ctx context.Context, projectId string, id string, params *WikiUpdatePutParams, body WikiUpdatePutJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWikiUpdatePutRequest(c.Server, projectId, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WikiShowPdf(ctx context.Context, projectId string, id string, params *WikiShowPdfParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWikiShowPdfRequest(c.Server, projectId, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WikiShowTxt(ctx context.Context, projectId string, id string, params *WikiShowTxtParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWikiShowTxtRequest(c.Server, projectId, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WikiShowVersion(ctx context.Context, projectId string, id string, version int, params *WikiShowVersionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWikiShowVersionRequest(c.Server, projectId, id, version, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WikiShowVersionPdf(ctx context.Context, projectId string, id string, version int, params *WikiShowVersionPdfParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWikiShowVersionPdfRequest(c.Server, projectId, id, version, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WikiShowVersionTxt(ctx context.Context, projectId string, id string, version int, params *WikiShowVersionTxtParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWikiShowVersionTxtRequest(c.Server, projectId, id, version, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QueriesIndex(ctx context.Context, params *QueriesIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQueriesIndexRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssueRelationsDestroy(ctx context.Context, id int, params *IssueRelationsDestroyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssueRelationsDestroyRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssueRelationsShow(ctx context.Context, id int, params *IssueRelationsShowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssueRelationsShowRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RolesIndex(ctx context.Context, params *RolesIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRolesIndexRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RolesShow(ctx context.Context, id int, params *RolesShowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRolesShowRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchIndex(ctx context.Context, params *SearchIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchIndexRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TimelogIndexCsv(ctx context.Context, params *TimelogIndexCsvParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTimelogIndexCsvRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TimelogIndex(ctx context.Context, params *TimelogIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTimelogIndexRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TimelogCreateWithBody(ctx context.Context, params *TimelogCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTimelogCreateRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TimelogCreate(ctx context.Context, params *TimelogCreateParams, body TimelogCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTimelogCreateRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TimelogDestroy(ctx context.Context, id int, params *TimelogDestroyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTimelogDestroyRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TimelogShow(ctx context.Context, id int, params *TimelogShowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTimelogShowRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TimelogUpdatePatchWithBody(ctx context.Context, id int, params *TimelogUpdatePatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTimelogUpdatePatchRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TimelogUpdatePatch(ctx context.Context, id int, params *TimelogUpdatePatchParams, body TimelogUpdatePatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTimelogUpdatePatchRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TimelogUpdatePutWithBody(ctx context.Context, id int, params *TimelogUpdatePutParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTimelogUpdatePutRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TimelogUpdatePut(ctx context.Context, id int, params *TimelogUpdatePutParams, body TimelogUpdatePutJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTimelogUpdatePutRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TrackersIndex(ctx context.Context, params *TrackersIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTrackersIndexRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachmentsUploadWithBody(ctx context.Context, params *AttachmentsUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachmentsUploadRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsersIndexCsv(ctx context.Context, params *UsersIndexCsvParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersIndexCsvRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsersIndex(ctx context.Context, params *UsersIndexParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersIndexRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsersCreateWithBody(ctx context.Context, params *UsersCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersCreateRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsersCreate(ctx context.Context, params *UsersCreateParams, body UsersCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersCreateRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsersDestroy(ctx context.Context, id string, params *UsersDestroyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersDestroyRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsersShow(ctx context.Context, id string, params *UsersShowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersShowRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsersUpdatePatchWithBody(ctx context.Context, id string, params *UsersUpdatePatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersUpdatePatchRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsersUpdatePatch(ctx context.Context, id string, params *UsersUpdatePatchParams, body UsersUpdatePatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersUpdatePatchRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsersUpdatePutWithBody(ctx context.Context, id string, params *UsersUpdatePutParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersUpdatePutRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsersUpdatePut(ctx context.Context, id string, params *UsersUpdatePutParams, body UsersUpdatePutJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersUpdatePutRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VersionsDestroy(ctx context.Context, id int, params *VersionsDestroyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVersionsDestroyRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VersionsShow(ctx context.Context, id int, params *VersionsShowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVersionsShowRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VersionsUpdatePatchWithBody(ctx context.Context, id int, params *VersionsUpdatePatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVersionsUpdatePatchRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VersionsUpdatePatch(ctx context.Context, id int, params *VersionsUpdatePatchParams, body VersionsUpdatePatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVersionsUpdatePatchRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VersionsUpdatePutWithBody(ctx context.Context, id int, params *VersionsUpdatePutParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVersionsUpdatePutRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VersionsUpdatePut(ctx context.Context, id int, params *VersionsUpdatePutParams, body VersionsUpdatePutJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVersionsUpdatePutRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VersionsShowTxt(ctx context.Context, id int, params *VersionsShowTxtParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVersionsShowTxtRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WatchersDestroy(ctx context.Context, params *WatchersDestroyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWatchersDestroyRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WatchersCreateWithBody(ctx context.Context, params *WatchersCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWatchersCreateRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WatchersCreate(ctx context.Context, params *WatchersCreateParams, body WatchersCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWatchersCreateRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewAttachmentsDownloadRequest generates requests for AttachmentsDownload
func NewAttachmentsDownloadRequest(server string, id int, params *AttachmentsDownloadParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/attachments/download/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewAttachmentsThumbnailRequest generates requests for AttachmentsThumbnail
func NewAttachmentsThumbnailRequest(server string, id int, params *AttachmentsThumbnailParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/attachments/thumbnail/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewAttachmentsThumbnailSizeRequest generates requests for AttachmentsThumbnailSize
func NewAttachmentsThumbnailSizeRequest(server string, id int, size int, params *AttachmentsThumbnailSizeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "size", runtime.ParamLocationPath, size)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/attachments/thumbnail/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewAttachmentsDestroyRequest generates requests for AttachmentsDestroy
func NewAttachmentsDestroyRequest(server string, id int, params *AttachmentsDestroyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/attachments/%s.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewAttachmentsShowRequest generates requests for AttachmentsShow
func NewAttachmentsShowRequest(server string, id int, params *AttachmentsShowParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/attachments/%s.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewAttachmentsUpdatePatchRequest calls the generic AttachmentsUpdatePatch builder with application/json body
func NewAttachmentsUpdatePatchRequest(server string, id int, params *AttachmentsUpdatePatchParams, body AttachmentsUpdatePatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAttachmentsUpdatePatchRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewAttachmentsUpdatePatchRequestWithBody generates requests for AttachmentsUpdatePatch with any type of body
func NewAttachmentsUpdatePatchRequestWithBody(server string, id int, params *AttachmentsUpdatePatchParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/attachments/%s.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewAttachmentsUpdatePutRequest calls the generic AttachmentsUpdatePut builder with application/json body
func NewAttachmentsUpdatePutRequest(server string, id int, params *AttachmentsUpdatePutParams, body AttachmentsUpdatePutJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAttachmentsUpdatePutRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewAttachmentsUpdatePutRequestWithBody generates requests for AttachmentsUpdatePut with any type of body
func NewAttachmentsUpdatePutRequestWithBody(server string, id int, params *AttachmentsUpdatePutParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/attachments/%s.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewAttachmentsDownloadAllRequest generates requests for AttachmentsDownloadAll
func NewAttachmentsDownloadAllRequest(server string, objectType string, objectId int, params *AttachmentsDownloadAllParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "object_type", runtime.ParamLocationPath, objectType)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "object_id", runtime.ParamLocationPath, objectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/attachments/%s/%s/download.zip", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewCustomFieldsIndexRequest generates requests for CustomFieldsIndex
func NewCustomFieldsIndexRequest(server string, params *CustomFieldsIndexParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/custom_fields.json")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewEnumerationsIndexDocumentCategoryRequest generates requests for EnumerationsIndexDocumentCategory
func NewEnumerationsIndexDocumentCategoryRequest(server string, params *EnumerationsIndexDocumentCategoryParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/enumerations/document_categories.json")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewEnumerationsIndexIssuePriorityRequest generates requests for EnumerationsIndexIssuePriority
func NewEnumerationsIndexIssuePriorityRequest(server string, params *EnumerationsIndexIssuePriorityParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/enumerations/issue_priorities.json")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewEnumerationsIndexTimeEntryActivityRequest generates requests for EnumerationsIndexTimeEntryActivity
func NewEnumerationsIndexTimeEntryActivityRequest(server string, params *EnumerationsIndexTimeEntryActivityParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/enumerations/time_entry_activities.json")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewGroupsIndexRequest generates requests for GroupsIndex
func NewGroupsIndexRequest(server string, params *GroupsIndexParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups.json")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Pagination != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination", runtime.ParamLocationQuery, *params.Pagination); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineNometa != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Nometa", runtime.ParamLocationHeader, *params.XRedmineNometa)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Nometa", headerParam0)
		}

		if params.XRedmineSwitchUser != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam1)
		}

	}

	return req, nil
}

// NewGroupsCreateRequest calls the generic GroupsCreate builder with application/json body
func NewGroupsCreateRequest(server string, params *GroupsCreateParams, body GroupsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGroupsCreateRequestWithBody(server, params, "application/json", bodyReader)
}

// NewGroupsCreateRequestWithBody generates requests for GroupsCreate with any type of body
func NewGroupsCreateRequestWithBody(server string, params *GroupsCreateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups.json")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewGroupsDestroyRequest generates requests for GroupsDestroy
func NewGroupsDestroyRequest(server string, id int, params *GroupsDestroyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewGroupsShowRequest generates requests for GroupsShow
func NewGroupsShowRequest(server string, id int, params *GroupsShowParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewGroupsUpdatePatchRequest calls the generic GroupsUpdatePatch builder with application/json body
func NewGroupsUpdatePatchRequest(server string, id int, params *GroupsUpdatePatchParams, body GroupsUpdatePatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGroupsUpdatePatchRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewGroupsUpdatePatchRequestWithBody generates requests for GroupsUpdatePatch with any type of body
func NewGroupsUpdatePatchRequestWithBody(server string, id int, params *GroupsUpdatePatchParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewGroupsUpdatePutRequest calls the generic GroupsUpdatePut builder with application/json body
func NewGroupsUpdatePutRequest(server string, id int, params *GroupsUpdatePutParams, body GroupsUpdatePutJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGroupsUpdatePutRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewGroupsUpdatePutRequestWithBody generates requests for GroupsUpdatePut with any type of body
func NewGroupsUpdatePutRequestWithBody(server string, id int, params *GroupsUpdatePutParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewGroupsAddUsersRequest calls the generic GroupsAddUsers builder with application/json body
func NewGroupsAddUsersRequest(server string, id int, params *GroupsAddUsersParams, body GroupsAddUsersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGroupsAddUsersRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewGroupsAddUsersRequestWithBody generates requests for GroupsAddUsers with any type of body
func NewGroupsAddUsersRequestWithBody(server string, id int, params *GroupsAddUsersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s/users.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewGroupsRemoveUserRequest generates requests for GroupsRemoveUser
func NewGroupsRemoveUserRequest(server string, id int, userId int, params *GroupsRemoveUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s/users/%s.json", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewIssueCategoriesDestroyRequest generates requests for IssueCategoriesDestroy
func NewIssueCategoriesDestroyRequest(server string, id int, params *IssueCategoriesDestroyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issue_categories/%s.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ReassignToId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reassign_to_id", runtime.ParamLocationQuery, *params.ReassignToId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewIssueCategoriesShowRequest generates requests for IssueCategoriesShow
func NewIssueCategoriesShowRequest(server string, id int, params *IssueCategoriesShowParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issue_categories/%s.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewIssueCategoriesUpdatePatchRequest calls the generic IssueCategoriesUpdatePatch builder with application/json body
func NewIssueCategoriesUpdatePatchRequest(server string, id int, params *IssueCategoriesUpdatePatchParams, body IssueCategoriesUpdatePatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewIssueCategoriesUpdatePatchRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewIssueCategoriesUpdatePatchRequestWithBody generates requests for IssueCategoriesUpdatePatch with any type of body
func NewIssueCategoriesUpdatePatchRequestWithBody(server string, id int, params *IssueCategoriesUpdatePatchParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issue_categories/%s.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewIssueCategoriesUpdatePutRequest calls the generic IssueCategoriesUpdatePut builder with application/json body
func NewIssueCategoriesUpdatePutRequest(server string, id int, params *IssueCategoriesUpdatePutParams, body IssueCategoriesUpdatePutJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewIssueCategoriesUpdatePutRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewIssueCategoriesUpdatePutRequestWithBody generates requests for IssueCategoriesUpdatePut with any type of body
func NewIssueCategoriesUpdatePutRequestWithBody(server string, id int, params *IssueCategoriesUpdatePutParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issue_categories/%s.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewIssueStatusesIndexRequest generates requests for IssueStatusesIndex
func NewIssueStatusesIndexRequest(server string, params *IssueStatusesIndexParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issue_statuses.json")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewIssuesIndexCsvRequest generates requests for IssuesIndexCsv
func NewIssuesIndexCsvRequest(server string, params *IssuesIndexCsvParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issues.csv")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Pagination != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination", runtime.ParamLocationQuery, *params.Pagination); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Query != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, *params.Query); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineNometa != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Nometa", runtime.ParamLocationHeader, *params.XRedmineNometa)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Nometa", headerParam0)
		}

		if params.XRedmineSwitchUser != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam1)
		}

	}

	return req, nil
}

// NewIssuesIndexRequest generates requests for IssuesIndex
func NewIssuesIndexRequest(server string, params *IssuesIndexParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issues.json")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Pagination != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination", runtime.ParamLocationQuery, *params.Pagination); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Query != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, *params.Query); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineNometa != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Nometa", runtime.ParamLocationHeader, *params.XRedmineNometa)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Nometa", headerParam0)
		}

		if params.XRedmineSwitchUser != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam1)
		}

	}

	return req, nil
}

// NewIssuesCreateRequest calls the generic IssuesCreate builder with application/json body
func NewIssuesCreateRequest(server string, params *IssuesCreateParams, body IssuesCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewIssuesCreateRequestWithBody(server, params, "application/json", bodyReader)
}

// NewIssuesCreateRequestWithBody generates requests for IssuesCreate with any type of body
func NewIssuesCreateRequestWithBody(server string, params *IssuesCreateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issues.json")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewIssuesIndexPdfRequest generates requests for IssuesIndexPdf
func NewIssuesIndexPdfRequest(server string, params *IssuesIndexPdfParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issues.pdf")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Pagination != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination", runtime.ParamLocationQuery, *params.Pagination); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Query != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, *params.Query); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineNometa != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Nometa", runtime.ParamLocationHeader, *params.XRedmineNometa)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Nometa", headerParam0)
		}

		if params.XRedmineSwitchUser != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam1)
		}

	}

	return req, nil
}

// NewGanttsShowPdfRequest generates requests for GanttsShowPdf
func NewGanttsShowPdfRequest(server string, params *GanttsShowPdfParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issues/gantt.pdf")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewGanttsShowPngRequest generates requests for GanttsShowPng
func NewGanttsShowPngRequest(server string, params *GanttsShowPngParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issues/gantt.png")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewIssuesDestroyRequest generates requests for IssuesDestroy
func NewIssuesDestroyRequest(server string, id int, params *IssuesDestroyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issues/%s.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewIssuesShowRequest generates requests for IssuesShow
func NewIssuesShowRequest(server string, id int, params *IssuesShowParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issues/%s.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewIssuesUpdatePatchRequest calls the generic IssuesUpdatePatch builder with application/json body
func NewIssuesUpdatePatchRequest(server string, id int, params *IssuesUpdatePatchParams, body IssuesUpdatePatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewIssuesUpdatePatchRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewIssuesUpdatePatchRequestWithBody generates requests for IssuesUpdatePatch with any type of body
func NewIssuesUpdatePatchRequestWithBody(server string, id int, params *IssuesUpdatePatchParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issues/%s.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewIssuesUpdatePutRequest calls the generic IssuesUpdatePut builder with application/json body
func NewIssuesUpdatePutRequest(server string, id int, params *IssuesUpdatePutParams, body IssuesUpdatePutJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewIssuesUpdatePutRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewIssuesUpdatePutRequestWithBody generates requests for IssuesUpdatePut with any type of body
func NewIssuesUpdatePutRequestWithBody(server string, id int, params *IssuesUpdatePutParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issues/%s.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewIssuesShowPdfRequest generates requests for IssuesShowPdf
func NewIssuesShowPdfRequest(server string, id int, params *IssuesShowPdfParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issues/%s.pdf", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewIssueRelationsIndexRequest generates requests for IssueRelationsIndex
func NewIssueRelationsIndexRequest(server string, issueId int, params *IssueRelationsIndexParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "issue_id", runtime.ParamLocationPath, issueId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issues/%s/relations.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewIssueRelationsCreateRequest calls the generic IssueRelationsCreate builder with application/json body
func NewIssueRelationsCreateRequest(server string, issueId int, params *IssueRelationsCreateParams, body IssueRelationsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewIssueRelationsCreateRequestWithBody(server, issueId, params, "application/json", bodyReader)
}

// NewIssueRelationsCreateRequestWithBody generates requests for IssueRelationsCreate with any type of body
func NewIssueRelationsCreateRequestWithBody(server string, issueId int, params *IssueRelationsCreateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "issue_id", runtime.ParamLocationPath, issueId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issues/%s/relations.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewTimelogCreateIssueRequest calls the generic TimelogCreateIssue builder with application/json body
func NewTimelogCreateIssueRequest(server string, issueId int, params *TimelogCreateIssueParams, body TimelogCreateIssueJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTimelogCreateIssueRequestWithBody(server, issueId, params, "application/json", bodyReader)
}

// NewTimelogCreateIssueRequestWithBody generates requests for TimelogCreateIssue with any type of body
func NewTimelogCreateIssueRequestWithBody(server string, issueId int, params *TimelogCreateIssueParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "issue_id", runtime.ParamLocationPath, issueId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issues/%s/time_entries.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewWatchersCreateIssueRequest calls the generic WatchersCreateIssue builder with application/json body
func NewWatchersCreateIssueRequest(server string, issueId int, params *WatchersCreateIssueParams, body WatchersCreateIssueJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWatchersCreateIssueRequestWithBody(server, issueId, params, "application/json", bodyReader)
}

// NewWatchersCreateIssueRequestWithBody generates requests for WatchersCreateIssue with any type of body
func NewWatchersCreateIssueRequestWithBody(server string, issueId int, params *WatchersCreateIssueParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "issue_id", runtime.ParamLocationPath, issueId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issues/%s/watchers.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewWatchersDestroyIssueRequest generates requests for WatchersDestroyIssue
func NewWatchersDestroyIssueRequest(server string, issueId int, userId int, params *WatchersDestroyIssueParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "issue_id", runtime.ParamLocationPath, issueId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issues/%s/watchers/%s.json", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewJournalsUpdatePatchRequest calls the generic JournalsUpdatePatch builder with application/json body
func NewJournalsUpdatePatchRequest(server string, id int, params *JournalsUpdatePatchParams, body JournalsUpdatePatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewJournalsUpdatePatchRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewJournalsUpdatePatchRequestWithBody generates requests for JournalsUpdatePatch with any type of body
func NewJournalsUpdatePatchRequestWithBody(server string, id int, params *JournalsUpdatePatchParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/journals/%s.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewJournalsUpdatePutRequest calls the generic JournalsUpdatePut builder with application/json body
func NewJournalsUpdatePutRequest(server string, id int, params *JournalsUpdatePutParams, body JournalsUpdatePutJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewJournalsUpdatePutRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewJournalsUpdatePutRequestWithBody generates requests for JournalsUpdatePut with any type of body
func NewJournalsUpdatePutRequestWithBody(server string, id int, params *JournalsUpdatePutParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/journals/%s.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewMembersDestroyRequest generates requests for MembersDestroy
func NewMembersDestroyRequest(server string, id int, params *MembersDestroyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/memberships/%s.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewMembersShowRequest generates requests for MembersShow
func NewMembersShowRequest(server string, id int, params *MembersShowParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/memberships/%s.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewMembersUpdatePatchRequest calls the generic MembersUpdatePatch builder with application/json body
func NewMembersUpdatePatchRequest(server string, id int, params *MembersUpdatePatchParams, body MembersUpdatePatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMembersUpdatePatchRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewMembersUpdatePatchRequestWithBody generates requests for MembersUpdatePatch with any type of body
func NewMembersUpdatePatchRequestWithBody(server string, id int, params *MembersUpdatePatchParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/memberships/%s.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewMembersUpdatePutRequest calls the generic MembersUpdatePut builder with application/json body
func NewMembersUpdatePutRequest(server string, id int, params *MembersUpdatePutParams, body MembersUpdatePutJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMembersUpdatePutRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewMembersUpdatePutRequestWithBody generates requests for MembersUpdatePut with any type of body
func NewMembersUpdatePutRequestWithBody(server string, id int, params *MembersUpdatePutParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/memberships/%s.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewMyAccountRequest generates requests for MyAccount
func NewMyAccountRequest(server string, params *MyAccountParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/my/account.json")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewMyAccountPutRequest calls the generic MyAccountPut builder with application/json body
func NewMyAccountPutRequest(server string, params *MyAccountPutParams, body MyAccountPutJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMyAccountPutRequestWithBody(server, params, "application/json", bodyReader)
}

// NewMyAccountPutRequestWithBody generates requests for MyAccountPut with any type of body
func NewMyAccountPutRequestWithBody(server string, params *MyAccountPutParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/my/account.json")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewNewsIndexRequest generates requests for NewsIndex
func NewNewsIndexRequest(server string, params *NewsIndexParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/news.json")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Pagination != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination", runtime.ParamLocationQuery, *params.Pagination); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineNometa != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Nometa", runtime.ParamLocationHeader, *params.XRedmineNometa)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Nometa", headerParam0)
		}

		if params.XRedmineSwitchUser != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam1)
		}

	}

	return req, nil
}

// NewNewsCreateRequest calls the generic NewsCreate builder with application/json body
func NewNewsCreateRequest(server string, params *NewsCreateParams, body NewsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNewsCreateRequestWithBody(server, params, "application/json", bodyReader)
}

// NewNewsCreateRequestWithBody generates requests for NewsCreate with any type of body
func NewNewsCreateRequestWithBody(server string, params *NewsCreateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/news.json")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewNewsDestroyRequest generates requests for NewsDestroy
func NewNewsDestroyRequest(server string, id int, params *NewsDestroyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/news/%s.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewNewsShowRequest generates requests for NewsShow
func NewNewsShowRequest(server string, id int, params *NewsShowParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/news/%s.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewNewsUpdatePatchRequest calls the generic NewsUpdatePatch builder with application/json body
func NewNewsUpdatePatchRequest(server string, id int, params *NewsUpdatePatchParams, body NewsUpdatePatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNewsUpdatePatchRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewNewsUpdatePatchRequestWithBody generates requests for NewsUpdatePatch with any type of body
func NewNewsUpdatePatchRequestWithBody(server string, id int, params *NewsUpdatePatchParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/news/%s.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewNewsUpdatePutRequest calls the generic NewsUpdatePut builder with application/json body
func NewNewsUpdatePutRequest(server string, id int, params *NewsUpdatePutParams, body NewsUpdatePutJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNewsUpdatePutRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewNewsUpdatePutRequestWithBody generates requests for NewsUpdatePut with any type of body
func NewNewsUpdatePutRequestWithBody(server string, id int, params *NewsUpdatePutParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/news/%s.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewProjectsIndexCsvRequest generates requests for ProjectsIndexCsv
func NewProjectsIndexCsvRequest(server string, params *ProjectsIndexCsvParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects.csv")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Pagination != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination", runtime.ParamLocationQuery, *params.Pagination); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Query != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, *params.Query); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineNometa != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Nometa", runtime.ParamLocationHeader, *params.XRedmineNometa)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Nometa", headerParam0)
		}

		if params.XRedmineSwitchUser != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam1)
		}

	}

	return req, nil
}

// NewProjectsIndexRequest generates requests for ProjectsIndex
func NewProjectsIndexRequest(server string, params *ProjectsIndexParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects.json")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Pagination != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination", runtime.ParamLocationQuery, *params.Pagination); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Query != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, *params.Query); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineNometa != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Nometa", runtime.ParamLocationHeader, *params.XRedmineNometa)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Nometa", headerParam0)
		}

		if params.XRedmineSwitchUser != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam1)
		}

	}

	return req, nil
}

// NewProjectsCreateRequest calls the generic ProjectsCreate builder with application/json body
func NewProjectsCreateRequest(server string, params *ProjectsCreateParams, body ProjectsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewProjectsCreateRequestWithBody(server, params, "application/json", bodyReader)
}

// NewProjectsCreateRequestWithBody generates requests for ProjectsCreate with any type of body
func NewProjectsCreateRequestWithBody(server string, params *ProjectsCreateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects.json")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewProjectsDestroyRequest generates requests for ProjectsDestroy
func NewProjectsDestroyRequest(server string, id string, params *ProjectsDestroyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewProjectsShowRequest generates requests for ProjectsShow
func NewProjectsShowRequest(server string, id string, params *ProjectsShowParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewProjectsUpdatePatchRequest calls the generic ProjectsUpdatePatch builder with application/json body
func NewProjectsUpdatePatchRequest(server string, id string, params *ProjectsUpdatePatchParams, body ProjectsUpdatePatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewProjectsUpdatePatchRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewProjectsUpdatePatchRequestWithBody generates requests for ProjectsUpdatePatch with any type of body
func NewProjectsUpdatePatchRequestWithBody(server string, id string, params *ProjectsUpdatePatchParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewProjectsUpdatePutRequest calls the generic ProjectsUpdatePut builder with application/json body
func NewProjectsUpdatePutRequest(server string, id string, params *ProjectsUpdatePutParams, body ProjectsUpdatePutJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewProjectsUpdatePutRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewProjectsUpdatePutRequestWithBody generates requests for ProjectsUpdatePut with any type of body
func NewProjectsUpdatePutRequestWithBody(server string, id string, params *ProjectsUpdatePutParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewProjectsArchivePostRequest generates requests for ProjectsArchivePost
func NewProjectsArchivePostRequest(server string, id string, params *ProjectsArchivePostParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/archive.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewProjectsArchivePutRequest generates requests for ProjectsArchivePut
func NewProjectsArchivePutRequest(server string, id string, params *ProjectsArchivePutParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/archive.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewRepositoriesAddRelatedIssueRequest calls the generic RepositoriesAddRelatedIssue builder with application/json body
func NewRepositoriesAddRelatedIssueRequest(server string, id string, repositoryId string, rev string, params *RepositoriesAddRelatedIssueParams, body RepositoriesAddRelatedIssueJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRepositoriesAddRelatedIssueRequestWithBody(server, id, repositoryId, rev, params, "application/json", bodyReader)
}

// NewRepositoriesAddRelatedIssueRequestWithBody generates requests for RepositoriesAddRelatedIssue with any type of body
func NewRepositoriesAddRelatedIssueRequestWithBody(server string, id string, repositoryId string, rev string, params *RepositoriesAddRelatedIssueParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repository_id", runtime.ParamLocationPath, repositoryId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "rev", runtime.ParamLocationPath, rev)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/repository/%s/revisions/%s/issues.json", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewRepositoriesRemoveRelatedIssueRequest generates requests for RepositoriesRemoveRelatedIssue
func NewRepositoriesRemoveRelatedIssueRequest(server string, id string, repositoryId string, rev string, issueId int, params *RepositoriesRemoveRelatedIssueParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repository_id", runtime.ParamLocationPath, repositoryId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "rev", runtime.ParamLocationPath, rev)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "issue_id", runtime.ParamLocationPath, issueId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/repository/%s/revisions/%s/issues/%s.json", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewProjectsUnarchivePostRequest generates requests for ProjectsUnarchivePost
func NewProjectsUnarchivePostRequest(server string, id string, params *ProjectsUnarchivePostParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/unarchive.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewProjectsUnarchivePutRequest generates requests for ProjectsUnarchivePut
func NewProjectsUnarchivePutRequest(server string, id string, params *ProjectsUnarchivePutParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/unarchive.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewFilesIndexRequest generates requests for FilesIndex
func NewFilesIndexRequest(server string, projectId string, params *FilesIndexParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/files.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewFilesCreateRequest calls the generic FilesCreate builder with application/json body
func NewFilesCreateRequest(server string, projectId string, params *FilesCreateParams, body FilesCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFilesCreateRequestWithBody(server, projectId, params, "application/json", bodyReader)
}

// NewFilesCreateRequestWithBody generates requests for FilesCreate with any type of body
func NewFilesCreateRequestWithBody(server string, projectId string, params *FilesCreateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/files.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewIssueCategoriesIndexRequest generates requests for IssueCategoriesIndex
func NewIssueCategoriesIndexRequest(server string, projectId string, params *IssueCategoriesIndexParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/issue_categories.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Nometa != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nometa", runtime.ParamLocationQuery, *params.Nometa); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineNometa != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Nometa", runtime.ParamLocationHeader, *params.XRedmineNometa)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Nometa", headerParam0)
		}

		if params.XRedmineSwitchUser != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam1)
		}

	}

	return req, nil
}

// NewIssueCategoriesCreateRequest calls the generic IssueCategoriesCreate builder with application/json body
func NewIssueCategoriesCreateRequest(server string, projectId string, params *IssueCategoriesCreateParams, body IssueCategoriesCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewIssueCategoriesCreateRequestWithBody(server, projectId, params, "application/json", bodyReader)
}

// NewIssueCategoriesCreateRequestWithBody generates requests for IssueCategoriesCreate with any type of body
func NewIssueCategoriesCreateRequestWithBody(server string, projectId string, params *IssueCategoriesCreateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/issue_categories.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewIssuesIndexProjectCsvRequest generates requests for IssuesIndexProjectCsv
func NewIssuesIndexProjectCsvRequest(server string, projectId string, params *IssuesIndexProjectCsvParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/issues.csv", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Pagination != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination", runtime.ParamLocationQuery, *params.Pagination); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Query != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, *params.Query); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineNometa != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Nometa", runtime.ParamLocationHeader, *params.XRedmineNometa)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Nometa", headerParam0)
		}

		if params.XRedmineSwitchUser != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam1)
		}

	}

	return req, nil
}

// NewIssuesIndexProjectRequest generates requests for IssuesIndexProject
func NewIssuesIndexProjectRequest(server string, projectId string, params *IssuesIndexProjectParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/issues.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Pagination != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination", runtime.ParamLocationQuery, *params.Pagination); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Query != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, *params.Query); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineNometa != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Nometa", runtime.ParamLocationHeader, *params.XRedmineNometa)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Nometa", headerParam0)
		}

		if params.XRedmineSwitchUser != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam1)
		}

	}

	return req, nil
}

// NewIssuesCreateProjectRequest calls the generic IssuesCreateProject builder with application/json body
func NewIssuesCreateProjectRequest(server string, projectId string, params *IssuesCreateProjectParams, body IssuesCreateProjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewIssuesCreateProjectRequestWithBody(server, projectId, params, "application/json", bodyReader)
}

// NewIssuesCreateProjectRequestWithBody generates requests for IssuesCreateProject with any type of body
func NewIssuesCreateProjectRequestWithBody(server string, projectId string, params *IssuesCreateProjectParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/issues.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewIssuesIndexProjectPdfRequest generates requests for IssuesIndexProjectPdf
func NewIssuesIndexProjectPdfRequest(server string, projectId string, params *IssuesIndexProjectPdfParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/issues.pdf", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Pagination != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination", runtime.ParamLocationQuery, *params.Pagination); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Query != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, *params.Query); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineNometa != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Nometa", runtime.ParamLocationHeader, *params.XRedmineNometa)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Nometa", headerParam0)
		}

		if params.XRedmineSwitchUser != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam1)
		}

	}

	return req, nil
}

// NewGanttsShowProjectPdfRequest generates requests for GanttsShowProjectPdf
func NewGanttsShowProjectPdfRequest(server string, projectId string, params *GanttsShowProjectPdfParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/issues/gantt.pdf", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewGanttsShowProjectPngRequest generates requests for GanttsShowProjectPng
func NewGanttsShowProjectPngRequest(server string, projectId string, params *GanttsShowProjectPngParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/issues/gantt.png", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewMembersIndexRequest generates requests for MembersIndex
func NewMembersIndexRequest(server string, projectId string, params *MembersIndexParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/memberships.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Pagination != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination", runtime.ParamLocationQuery, *params.Pagination); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineNometa != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Nometa", runtime.ParamLocationHeader, *params.XRedmineNometa)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Nometa", headerParam0)
		}

		if params.XRedmineSwitchUser != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam1)
		}

	}

	return req, nil
}

// NewMembersCreateRequest calls the generic MembersCreate builder with application/json body
func NewMembersCreateRequest(server string, projectId string, params *MembersCreateParams, body MembersCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMembersCreateRequestWithBody(server, projectId, params, "application/json", bodyReader)
}

// NewMembersCreateRequestWithBody generates requests for MembersCreate with any type of body
func NewMembersCreateRequestWithBody(server string, projectId string, params *MembersCreateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/memberships.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewNewsIndexProjectRequest generates requests for NewsIndexProject
func NewNewsIndexProjectRequest(server string, projectId string, params *NewsIndexProjectParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/news.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Pagination != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination", runtime.ParamLocationQuery, *params.Pagination); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineNometa != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Nometa", runtime.ParamLocationHeader, *params.XRedmineNometa)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Nometa", headerParam0)
		}

		if params.XRedmineSwitchUser != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam1)
		}

	}

	return req, nil
}

// NewNewsCreateProjectRequest calls the generic NewsCreateProject builder with application/json body
func NewNewsCreateProjectRequest(server string, projectId string, params *NewsCreateProjectParams, body NewsCreateProjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNewsCreateProjectRequestWithBody(server, projectId, params, "application/json", bodyReader)
}

// NewNewsCreateProjectRequestWithBody generates requests for NewsCreateProject with any type of body
func NewNewsCreateProjectRequestWithBody(server string, projectId string, params *NewsCreateProjectParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/news.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewSearchIndexProjectRequest generates requests for SearchIndexProject
func NewSearchIndexProjectRequest(server string, projectId string, params *SearchIndexProjectParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/search.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Pagination != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination", runtime.ParamLocationQuery, *params.Pagination); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, params.Q); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Query != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, *params.Query); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineNometa != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Nometa", runtime.ParamLocationHeader, *params.XRedmineNometa)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Nometa", headerParam0)
		}

		if params.XRedmineSwitchUser != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam1)
		}

	}

	return req, nil
}

// NewTimelogIndexProjectCsvRequest generates requests for TimelogIndexProjectCsv
func NewTimelogIndexProjectCsvRequest(server string, projectId string, params *TimelogIndexProjectCsvParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/time_entries.csv", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Query != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, *params.Query); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewTimelogIndexProjectRequest generates requests for TimelogIndexProject
func NewTimelogIndexProjectRequest(server string, projectId string, params *TimelogIndexProjectParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/time_entries.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Pagination != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination", runtime.ParamLocationQuery, *params.Pagination); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Query != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, *params.Query); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineNometa != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Nometa", runtime.ParamLocationHeader, *params.XRedmineNometa)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Nometa", headerParam0)
		}

		if params.XRedmineSwitchUser != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam1)
		}

	}

	return req, nil
}

// NewTimelogCreateProjectRequest calls the generic TimelogCreateProject builder with application/json body
func NewTimelogCreateProjectRequest(server string, projectId string, params *TimelogCreateProjectParams, body TimelogCreateProjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTimelogCreateProjectRequestWithBody(server, projectId, params, "application/json", bodyReader)
}

// NewTimelogCreateProjectRequestWithBody generates requests for TimelogCreateProject with any type of body
func NewTimelogCreateProjectRequestWithBody(server string, projectId string, params *TimelogCreateProjectParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/time_entries.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewVersionsIndexRequest generates requests for VersionsIndex
func NewVersionsIndexRequest(server string, projectId string, params *VersionsIndexParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/versions.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Nometa != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nometa", runtime.ParamLocationQuery, *params.Nometa); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineNometa != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Nometa", runtime.ParamLocationHeader, *params.XRedmineNometa)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Nometa", headerParam0)
		}

		if params.XRedmineSwitchUser != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam1)
		}

	}

	return req, nil
}

// NewVersionsCreateRequest calls the generic VersionsCreate builder with application/json body
func NewVersionsCreateRequest(server string, projectId string, params *VersionsCreateParams, body VersionsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewVersionsCreateRequestWithBody(server, projectId, params, "application/json", bodyReader)
}

// NewVersionsCreateRequestWithBody generates requests for VersionsCreate with any type of body
func NewVersionsCreateRequestWithBody(server string, projectId string, params *VersionsCreateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/versions.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewWikiShowRootRequest generates requests for WikiShowRoot
func NewWikiShowRootRequest(server string, projectId string, params *WikiShowRootParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/wiki.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewWikiIndexRequest generates requests for WikiIndex
func NewWikiIndexRequest(server string, projectId string, params *WikiIndexParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/wiki/index.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewWikiDestroyRequest generates requests for WikiDestroy
func NewWikiDestroyRequest(server string, projectId string, id string, params *WikiDestroyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/wiki/%s.json", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewWikiShowRequest generates requests for WikiShow
func NewWikiShowRequest(server string, projectId string, id string, params *WikiShowParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/wiki/%s.json", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewWikiUpdatePatchRequest calls the generic WikiUpdatePatch builder with application/json body
func NewWikiUpdatePatchRequest(server string, projectId string, id string, params *WikiUpdatePatchParams, body WikiUpdatePatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWikiUpdatePatchRequestWithBody(server, projectId, id, params, "application/json", bodyReader)
}

// NewWikiUpdatePatchRequestWithBody generates requests for WikiUpdatePatch with any type of body
func NewWikiUpdatePatchRequestWithBody(server string, projectId string, id string, params *WikiUpdatePatchParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/wiki/%s.json", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewWikiUpdatePutRequest calls the generic WikiUpdatePut builder with application/json body
func NewWikiUpdatePutRequest(server string, projectId string, id string, params *WikiUpdatePutParams, body WikiUpdatePutJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWikiUpdatePutRequestWithBody(server, projectId, id, params, "application/json", bodyReader)
}

// NewWikiUpdatePutRequestWithBody generates requests for WikiUpdatePut with any type of body
func NewWikiUpdatePutRequestWithBody(server string, projectId string, id string, params *WikiUpdatePutParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/wiki/%s.json", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewWikiShowPdfRequest generates requests for WikiShowPdf
func NewWikiShowPdfRequest(server string, projectId string, id string, params *WikiShowPdfParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/wiki/%s.pdf", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewWikiShowTxtRequest generates requests for WikiShowTxt
func NewWikiShowTxtRequest(server string, projectId string, id string, params *WikiShowTxtParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/wiki/%s.txt", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewWikiShowVersionRequest generates requests for WikiShowVersion
func NewWikiShowVersionRequest(server string, projectId string, id string, version int, params *WikiShowVersionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, version)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/wiki/%s/%s.json", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewWikiShowVersionPdfRequest generates requests for WikiShowVersionPdf
func NewWikiShowVersionPdfRequest(server string, projectId string, id string, version int, params *WikiShowVersionPdfParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, version)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/wiki/%s/%s.pdf", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewWikiShowVersionTxtRequest generates requests for WikiShowVersionTxt
func NewWikiShowVersionTxtRequest(server string, projectId string, id string, version int, params *WikiShowVersionTxtParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, version)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/wiki/%s/%s.txt", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewQueriesIndexRequest generates requests for QueriesIndex
func NewQueriesIndexRequest(server string, params *QueriesIndexParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/queries.json")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Pagination != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination", runtime.ParamLocationQuery, *params.Pagination); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineNometa != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Nometa", runtime.ParamLocationHeader, *params.XRedmineNometa)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Nometa", headerParam0)
		}

		if params.XRedmineSwitchUser != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam1)
		}

	}

	return req, nil
}

// NewIssueRelationsDestroyRequest generates requests for IssueRelationsDestroy
func NewIssueRelationsDestroyRequest(server string, id int, params *IssueRelationsDestroyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/relations/%s.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewIssueRelationsShowRequest generates requests for IssueRelationsShow
func NewIssueRelationsShowRequest(server string, id int, params *IssueRelationsShowParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/relations/%s.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewRolesIndexRequest generates requests for RolesIndex
func NewRolesIndexRequest(server string, params *RolesIndexParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/roles.json")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewRolesShowRequest generates requests for RolesShow
func NewRolesShowRequest(server string, id int, params *RolesShowParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/roles/%s.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewSearchIndexRequest generates requests for SearchIndex
func NewSearchIndexRequest(server string, params *SearchIndexParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search.json")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Pagination != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination", runtime.ParamLocationQuery, *params.Pagination); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, params.Q); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Query != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, *params.Query); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineNometa != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Nometa", runtime.ParamLocationHeader, *params.XRedmineNometa)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Nometa", headerParam0)
		}

		if params.XRedmineSwitchUser != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam1)
		}

	}

	return req, nil
}

// NewTimelogIndexCsvRequest generates requests for TimelogIndexCsv
func NewTimelogIndexCsvRequest(server string, params *TimelogIndexCsvParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/time_entries.csv")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Query != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, *params.Query); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewTimelogIndexRequest generates requests for TimelogIndex
func NewTimelogIndexRequest(server string, params *TimelogIndexParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/time_entries.json")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Pagination != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination", runtime.ParamLocationQuery, *params.Pagination); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Query != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, *params.Query); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineNometa != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Nometa", runtime.ParamLocationHeader, *params.XRedmineNometa)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Nometa", headerParam0)
		}

		if params.XRedmineSwitchUser != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam1)
		}

	}

	return req, nil
}

// NewTimelogCreateRequest calls the generic TimelogCreate builder with application/json body
func NewTimelogCreateRequest(server string, params *TimelogCreateParams, body TimelogCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTimelogCreateRequestWithBody(server, params, "application/json", bodyReader)
}

// NewTimelogCreateRequestWithBody generates requests for TimelogCreate with any type of body
func NewTimelogCreateRequestWithBody(server string, params *TimelogCreateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/time_entries.json")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewTimelogDestroyRequest generates requests for TimelogDestroy
func NewTimelogDestroyRequest(server string, id int, params *TimelogDestroyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/time_entries/%s.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewTimelogShowRequest generates requests for TimelogShow
func NewTimelogShowRequest(server string, id int, params *TimelogShowParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/time_entries/%s.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewTimelogUpdatePatchRequest calls the generic TimelogUpdatePatch builder with application/json body
func NewTimelogUpdatePatchRequest(server string, id int, params *TimelogUpdatePatchParams, body TimelogUpdatePatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTimelogUpdatePatchRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewTimelogUpdatePatchRequestWithBody generates requests for TimelogUpdatePatch with any type of body
func NewTimelogUpdatePatchRequestWithBody(server string, id int, params *TimelogUpdatePatchParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/time_entries/%s.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewTimelogUpdatePutRequest calls the generic TimelogUpdatePut builder with application/json body
func NewTimelogUpdatePutRequest(server string, id int, params *TimelogUpdatePutParams, body TimelogUpdatePutJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTimelogUpdatePutRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewTimelogUpdatePutRequestWithBody generates requests for TimelogUpdatePut with any type of body
func NewTimelogUpdatePutRequestWithBody(server string, id int, params *TimelogUpdatePutParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/time_entries/%s.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewTrackersIndexRequest generates requests for TrackersIndex
func NewTrackersIndexRequest(server string, params *TrackersIndexParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/trackers.json")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewAttachmentsUploadRequestWithBody generates requests for AttachmentsUpload with any type of body
func NewAttachmentsUploadRequestWithBody(server string, params *AttachmentsUploadParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/uploads.json")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filename != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filename", runtime.ParamLocationQuery, *params.Filename); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContentType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "content_type", runtime.ParamLocationQuery, *params.ContentType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewUsersIndexCsvRequest generates requests for UsersIndexCsv
func NewUsersIndexCsvRequest(server string, params *UsersIndexCsvParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users.csv")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Pagination != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination", runtime.ParamLocationQuery, *params.Pagination); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Query != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, *params.Query); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineNometa != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Nometa", runtime.ParamLocationHeader, *params.XRedmineNometa)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Nometa", headerParam0)
		}

		if params.XRedmineSwitchUser != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam1)
		}

	}

	return req, nil
}

// NewUsersIndexRequest generates requests for UsersIndex
func NewUsersIndexRequest(server string, params *UsersIndexParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users.json")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Pagination != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination", runtime.ParamLocationQuery, *params.Pagination); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Query != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, *params.Query); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineNometa != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Nometa", runtime.ParamLocationHeader, *params.XRedmineNometa)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Nometa", headerParam0)
		}

		if params.XRedmineSwitchUser != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam1)
		}

	}

	return req, nil
}

// NewUsersCreateRequest calls the generic UsersCreate builder with application/json body
func NewUsersCreateRequest(server string, params *UsersCreateParams, body UsersCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUsersCreateRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUsersCreateRequestWithBody generates requests for UsersCreate with any type of body
func NewUsersCreateRequestWithBody(server string, params *UsersCreateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users.json")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewUsersDestroyRequest generates requests for UsersDestroy
func NewUsersDestroyRequest(server string, id string, params *UsersDestroyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewUsersShowRequest generates requests for UsersShow
func NewUsersShowRequest(server string, id string, params *UsersShowParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewUsersUpdatePatchRequest calls the generic UsersUpdatePatch builder with application/json body
func NewUsersUpdatePatchRequest(server string, id string, params *UsersUpdatePatchParams, body UsersUpdatePatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUsersUpdatePatchRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewUsersUpdatePatchRequestWithBody generates requests for UsersUpdatePatch with any type of body
func NewUsersUpdatePatchRequestWithBody(server string, id string, params *UsersUpdatePatchParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewUsersUpdatePutRequest calls the generic UsersUpdatePut builder with application/json body
func NewUsersUpdatePutRequest(server string, id string, params *UsersUpdatePutParams, body UsersUpdatePutJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUsersUpdatePutRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewUsersUpdatePutRequestWithBody generates requests for UsersUpdatePut with any type of body
func NewUsersUpdatePutRequestWithBody(server string, id string, params *UsersUpdatePutParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewVersionsDestroyRequest generates requests for VersionsDestroy
func NewVersionsDestroyRequest(server string, id int, params *VersionsDestroyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/versions/%s.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewVersionsShowRequest generates requests for VersionsShow
func NewVersionsShowRequest(server string, id int, params *VersionsShowParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/versions/%s.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewVersionsUpdatePatchRequest calls the generic VersionsUpdatePatch builder with application/json body
func NewVersionsUpdatePatchRequest(server string, id int, params *VersionsUpdatePatchParams, body VersionsUpdatePatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewVersionsUpdatePatchRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewVersionsUpdatePatchRequestWithBody generates requests for VersionsUpdatePatch with any type of body
func NewVersionsUpdatePatchRequestWithBody(server string, id int, params *VersionsUpdatePatchParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/versions/%s.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewVersionsUpdatePutRequest calls the generic VersionsUpdatePut builder with application/json body
func NewVersionsUpdatePutRequest(server string, id int, params *VersionsUpdatePutParams, body VersionsUpdatePutJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewVersionsUpdatePutRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewVersionsUpdatePutRequestWithBody generates requests for VersionsUpdatePut with any type of body
func NewVersionsUpdatePutRequestWithBody(server string, id int, params *VersionsUpdatePutParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/versions/%s.json", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewVersionsShowTxtRequest generates requests for VersionsShowTxt
func NewVersionsShowTxtRequest(server string, id int, params *VersionsShowTxtParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/versions/%s.txt", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewWatchersDestroyRequest generates requests for WatchersDestroy
func NewWatchersDestroyRequest(server string, params *WatchersDestroyParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/watchers.json")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "object_type", runtime.ParamLocationQuery, params.ObjectType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "object_id", runtime.ParamLocationQuery, params.ObjectId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, params.UserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

// NewWatchersCreateRequest calls the generic WatchersCreate builder with application/json body
func NewWatchersCreateRequest(server string, params *WatchersCreateParams, body WatchersCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWatchersCreateRequestWithBody(server, params, "application/json", bodyReader)
}

// NewWatchersCreateRequestWithBody generates requests for WatchersCreate with any type of body
func NewWatchersCreateRequestWithBody(server string, params *WatchersCreateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/watchers.json")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRedmineSwitchUser != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Redmine-Switch-User", runtime.ParamLocationHeader, *params.XRedmineSwitchUser)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Redmine-Switch-User", headerParam0)
		}

	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// AttachmentsDownloadWithResponse request
	AttachmentsDownloadWithResponse(ctx context.Context, id int, params *AttachmentsDownloadParams, reqEditors ...RequestEditorFn) (*AttachmentsDownloadResponse, error)

	// AttachmentsThumbnailWithResponse request
	AttachmentsThumbnailWithResponse(ctx context.Context, id int, params *AttachmentsThumbnailParams, reqEditors ...RequestEditorFn) (*AttachmentsThumbnailResponse, error)

	// AttachmentsThumbnailSizeWithResponse request
	AttachmentsThumbnailSizeWithResponse(ctx context.Context, id int, size int, params *AttachmentsThumbnailSizeParams, reqEditors ...RequestEditorFn) (*AttachmentsThumbnailSizeResponse, error)

	// AttachmentsDestroyWithResponse request
	AttachmentsDestroyWithResponse(ctx context.Context, id int, params *AttachmentsDestroyParams, reqEditors ...RequestEditorFn) (*AttachmentsDestroyResponse, error)

	// AttachmentsShowWithResponse request
	AttachmentsShowWithResponse(ctx context.Context, id int, params *AttachmentsShowParams, reqEditors ...RequestEditorFn) (*AttachmentsShowResponse, error)

	// AttachmentsUpdatePatchWithBodyWithResponse request with any body
	AttachmentsUpdatePatchWithBodyWithResponse(ctx context.Context, id int, params *AttachmentsUpdatePatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachmentsUpdatePatchResponse, error)

	AttachmentsUpdatePatchWithResponse(ctx context.Context, id int, params *AttachmentsUpdatePatchParams, body AttachmentsUpdatePatchJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachmentsUpdatePatchResponse, error)

	// AttachmentsUpdatePutWithBodyWithResponse request with any body
	AttachmentsUpdatePutWithBodyWithResponse(ctx context.Context, id int, params *AttachmentsUpdatePutParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachmentsUpdatePutResponse, error)

	AttachmentsUpdatePutWithResponse(ctx context.Context, id int, params *AttachmentsUpdatePutParams, body AttachmentsUpdatePutJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachmentsUpdatePutResponse, error)

	// AttachmentsDownloadAllWithResponse request
	AttachmentsDownloadAllWithResponse(ctx context.Context, objectType string, objectId int, params *AttachmentsDownloadAllParams, reqEditors ...RequestEditorFn) (*AttachmentsDownloadAllResponse, error)

	// CustomFieldsIndexWithResponse request
	CustomFieldsIndexWithResponse(ctx context.Context, params *CustomFieldsIndexParams, reqEditors ...RequestEditorFn) (*CustomFieldsIndexResponse, error)

	// EnumerationsIndexDocumentCategoryWithResponse request
	EnumerationsIndexDocumentCategoryWithResponse(ctx context.Context, params *EnumerationsIndexDocumentCategoryParams, reqEditors ...RequestEditorFn) (*EnumerationsIndexDocumentCategoryResponse, error)

	// EnumerationsIndexIssuePriorityWithResponse request
	EnumerationsIndexIssuePriorityWithResponse(ctx context.Context, params *EnumerationsIndexIssuePriorityParams, reqEditors ...RequestEditorFn) (*EnumerationsIndexIssuePriorityResponse, error)

	// EnumerationsIndexTimeEntryActivityWithResponse request
	EnumerationsIndexTimeEntryActivityWithResponse(ctx context.Context, params *EnumerationsIndexTimeEntryActivityParams, reqEditors ...RequestEditorFn) (*EnumerationsIndexTimeEntryActivityResponse, error)

	// GroupsIndexWithResponse request
	GroupsIndexWithResponse(ctx context.Context, params *GroupsIndexParams, reqEditors ...RequestEditorFn) (*GroupsIndexResponse, error)

	// GroupsCreateWithBodyWithResponse request with any body
	GroupsCreateWithBodyWithResponse(ctx context.Context, params *GroupsCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GroupsCreateResponse, error)

	GroupsCreateWithResponse(ctx context.Context, params *GroupsCreateParams, body GroupsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*GroupsCreateResponse, error)

	// GroupsDestroyWithResponse request
	GroupsDestroyWithResponse(ctx context.Context, id int, params *GroupsDestroyParams, reqEditors ...RequestEditorFn) (*GroupsDestroyResponse, error)

	// GroupsShowWithResponse request
	GroupsShowWithResponse(ctx context.Context, id int, params *GroupsShowParams, reqEditors ...RequestEditorFn) (*GroupsShowResponse, error)

	// GroupsUpdatePatchWithBodyWithResponse request with any body
	GroupsUpdatePatchWithBodyWithResponse(ctx context.Context, id int, params *GroupsUpdatePatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GroupsUpdatePatchResponse, error)

	GroupsUpdatePatchWithResponse(ctx context.Context, id int, params *GroupsUpdatePatchParams, body GroupsUpdatePatchJSONRequestBody, reqEditors ...RequestEditorFn) (*GroupsUpdatePatchResponse, error)

	// GroupsUpdatePutWithBodyWithResponse request with any body
	GroupsUpdatePutWithBodyWithResponse(ctx context.Context, id int, params *GroupsUpdatePutParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GroupsUpdatePutResponse, error)

	GroupsUpdatePutWithResponse(ctx context.Context, id int, params *GroupsUpdatePutParams, body GroupsUpdatePutJSONRequestBody, reqEditors ...RequestEditorFn) (*GroupsUpdatePutResponse, error)

	// GroupsAddUsersWithBodyWithResponse request with any body
	GroupsAddUsersWithBodyWithResponse(ctx context.Context, id int, params *GroupsAddUsersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GroupsAddUsersResponse, error)

	GroupsAddUsersWithResponse(ctx context.Context, id int, params *GroupsAddUsersParams, body GroupsAddUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*GroupsAddUsersResponse, error)

	// GroupsRemoveUserWithResponse request
	GroupsRemoveUserWithResponse(ctx context.Context, id int, userId int, params *GroupsRemoveUserParams, reqEditors ...RequestEditorFn) (*GroupsRemoveUserResponse, error)

	// IssueCategoriesDestroyWithResponse request
	IssueCategoriesDestroyWithResponse(ctx context.Context, id int, params *IssueCategoriesDestroyParams, reqEditors ...RequestEditorFn) (*IssueCategoriesDestroyResponse, error)

	// IssueCategoriesShowWithResponse request
	IssueCategoriesShowWithResponse(ctx context.Context, id int, params *IssueCategoriesShowParams, reqEditors ...RequestEditorFn) (*IssueCategoriesShowResponse, error)

	// IssueCategoriesUpdatePatchWithBodyWithResponse request with any body
	IssueCategoriesUpdatePatchWithBodyWithResponse(ctx context.Context, id int, params *IssueCategoriesUpdatePatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IssueCategoriesUpdatePatchResponse, error)

	IssueCategoriesUpdatePatchWithResponse(ctx context.Context, id int, params *IssueCategoriesUpdatePatchParams, body IssueCategoriesUpdatePatchJSONRequestBody, reqEditors ...RequestEditorFn) (*IssueCategoriesUpdatePatchResponse, error)

	// IssueCategoriesUpdatePutWithBodyWithResponse request with any body
	IssueCategoriesUpdatePutWithBodyWithResponse(ctx context.Context, id int, params *IssueCategoriesUpdatePutParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IssueCategoriesUpdatePutResponse, error)

	IssueCategoriesUpdatePutWithResponse(ctx context.Context, id int, params *IssueCategoriesUpdatePutParams, body IssueCategoriesUpdatePutJSONRequestBody, reqEditors ...RequestEditorFn) (*IssueCategoriesUpdatePutResponse, error)

	// IssueStatusesIndexWithResponse request
	IssueStatusesIndexWithResponse(ctx context.Context, params *IssueStatusesIndexParams, reqEditors ...RequestEditorFn) (*IssueStatusesIndexResponse, error)

	// IssuesIndexCsvWithResponse request
	IssuesIndexCsvWithResponse(ctx context.Context, params *IssuesIndexCsvParams, reqEditors ...RequestEditorFn) (*IssuesIndexCsvResponse, error)

	// IssuesIndexWithResponse request
	IssuesIndexWithResponse(ctx context.Context, params *IssuesIndexParams, reqEditors ...RequestEditorFn) (*IssuesIndexResponse, error)

	// IssuesCreateWithBodyWithResponse request with any body
	IssuesCreateWithBodyWithResponse(ctx context.Context, params *IssuesCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IssuesCreateResponse, error)

	IssuesCreateWithResponse(ctx context.Context, params *IssuesCreateParams, body IssuesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*IssuesCreateResponse, error)

	// IssuesIndexPdfWithResponse request
	IssuesIndexPdfWithResponse(ctx context.Context, params *IssuesIndexPdfParams, reqEditors ...RequestEditorFn) (*IssuesIndexPdfResponse, error)

	// GanttsShowPdfWithResponse request
	GanttsShowPdfWithResponse(ctx context.Context, params *GanttsShowPdfParams, reqEditors ...RequestEditorFn) (*GanttsShowPdfResponse, error)

	// GanttsShowPngWithResponse request
	GanttsShowPngWithResponse(ctx context.Context, params *GanttsShowPngParams, reqEditors ...RequestEditorFn) (*GanttsShowPngResponse, error)

	// IssuesDestroyWithResponse request
	IssuesDestroyWithResponse(ctx context.Context, id int, params *IssuesDestroyParams, reqEditors ...RequestEditorFn) (*IssuesDestroyResponse, error)

	// IssuesShowWithResponse request
	IssuesShowWithResponse(ctx context.Context, id int, params *IssuesShowParams, reqEditors ...RequestEditorFn) (*IssuesShowResponse, error)

	// IssuesUpdatePatchWithBodyWithResponse request with any body
	IssuesUpdatePatchWithBodyWithResponse(ctx context.Context, id int, params *IssuesUpdatePatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IssuesUpdatePatchResponse, error)

	IssuesUpdatePatchWithResponse(ctx context.Context, id int, params *IssuesUpdatePatchParams, body IssuesUpdatePatchJSONRequestBody, reqEditors ...RequestEditorFn) (*IssuesUpdatePatchResponse, error)

	// IssuesUpdatePutWithBodyWithResponse request with any body
	IssuesUpdatePutWithBodyWithResponse(ctx context.Context, id int, params *IssuesUpdatePutParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IssuesUpdatePutResponse, error)

	IssuesUpdatePutWithResponse(ctx context.Context, id int, params *IssuesUpdatePutParams, body IssuesUpdatePutJSONRequestBody, reqEditors ...RequestEditorFn) (*IssuesUpdatePutResponse, error)

	// IssuesShowPdfWithResponse request
	IssuesShowPdfWithResponse(ctx context.Context, id int, params *IssuesShowPdfParams, reqEditors ...RequestEditorFn) (*IssuesShowPdfResponse, error)

	// IssueRelationsIndexWithResponse request
	IssueRelationsIndexWithResponse(ctx context.Context, issueId int, params *IssueRelationsIndexParams, reqEditors ...RequestEditorFn) (*IssueRelationsIndexResponse, error)

	// IssueRelationsCreateWithBodyWithResponse request with any body
	IssueRelationsCreateWithBodyWithResponse(ctx context.Context, issueId int, params *IssueRelationsCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IssueRelationsCreateResponse, error)

	IssueRelationsCreateWithResponse(ctx context.Context, issueId int, params *IssueRelationsCreateParams, body IssueRelationsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*IssueRelationsCreateResponse, error)

	// TimelogCreateIssueWithBodyWithResponse request with any body
	TimelogCreateIssueWithBodyWithResponse(ctx context.Context, issueId int, params *TimelogCreateIssueParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TimelogCreateIssueResponse, error)

	TimelogCreateIssueWithResponse(ctx context.Context, issueId int, params *TimelogCreateIssueParams, body TimelogCreateIssueJSONRequestBody, reqEditors ...RequestEditorFn) (*TimelogCreateIssueResponse, error)

	// WatchersCreateIssueWithBodyWithResponse request with any body
	WatchersCreateIssueWithBodyWithResponse(ctx context.Context, issueId int, params *WatchersCreateIssueParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WatchersCreateIssueResponse, error)

	WatchersCreateIssueWithResponse(ctx context.Context, issueId int, params *WatchersCreateIssueParams, body WatchersCreateIssueJSONRequestBody, reqEditors ...RequestEditorFn) (*WatchersCreateIssueResponse, error)

	// WatchersDestroyIssueWithResponse request
	WatchersDestroyIssueWithResponse(ctx context.Context, issueId int, userId int, params *WatchersDestroyIssueParams, reqEditors ...RequestEditorFn) (*WatchersDestroyIssueResponse, error)

	// JournalsUpdatePatchWithBodyWithResponse request with any body
	JournalsUpdatePatchWithBodyWithResponse(ctx context.Context, id int, params *JournalsUpdatePatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*JournalsUpdatePatchResponse, error)

	JournalsUpdatePatchWithResponse(ctx context.Context, id int, params *JournalsUpdatePatchParams, body JournalsUpdatePatchJSONRequestBody, reqEditors ...RequestEditorFn) (*JournalsUpdatePatchResponse, error)

	// JournalsUpdatePutWithBodyWithResponse request with any body
	JournalsUpdatePutWithBodyWithResponse(ctx context.Context, id int, params *JournalsUpdatePutParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*JournalsUpdatePutResponse, error)

	JournalsUpdatePutWithResponse(ctx context.Context, id int, params *JournalsUpdatePutParams, body JournalsUpdatePutJSONRequestBody, reqEditors ...RequestEditorFn) (*JournalsUpdatePutResponse, error)

	// MembersDestroyWithResponse request
	MembersDestroyWithResponse(ctx context.Context, id int, params *MembersDestroyParams, reqEditors ...RequestEditorFn) (*MembersDestroyResponse, error)

	// MembersShowWithResponse request
	MembersShowWithResponse(ctx context.Context, id int, params *MembersShowParams, reqEditors ...RequestEditorFn) (*MembersShowResponse, error)

	// MembersUpdatePatchWithBodyWithResponse request with any body
	MembersUpdatePatchWithBodyWithResponse(ctx context.Context, id int, params *MembersUpdatePatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MembersUpdatePatchResponse, error)

	MembersUpdatePatchWithResponse(ctx context.Context, id int, params *MembersUpdatePatchParams, body MembersUpdatePatchJSONRequestBody, reqEditors ...RequestEditorFn) (*MembersUpdatePatchResponse, error)

	// MembersUpdatePutWithBodyWithResponse request with any body
	MembersUpdatePutWithBodyWithResponse(ctx context.Context, id int, params *MembersUpdatePutParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MembersUpdatePutResponse, error)

	MembersUpdatePutWithResponse(ctx context.Context, id int, params *MembersUpdatePutParams, body MembersUpdatePutJSONRequestBody, reqEditors ...RequestEditorFn) (*MembersUpdatePutResponse, error)

	// MyAccountWithResponse request
	MyAccountWithResponse(ctx context.Context, params *MyAccountParams, reqEditors ...RequestEditorFn) (*MyAccountResponse, error)

	// MyAccountPutWithBodyWithResponse request with any body
	MyAccountPutWithBodyWithResponse(ctx context.Context, params *MyAccountPutParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MyAccountPutResponse, error)

	MyAccountPutWithResponse(ctx context.Context, params *MyAccountPutParams, body MyAccountPutJSONRequestBody, reqEditors ...RequestEditorFn) (*MyAccountPutResponse, error)

	// NewsIndexWithResponse request
	NewsIndexWithResponse(ctx context.Context, params *NewsIndexParams, reqEditors ...RequestEditorFn) (*NewsIndexResponse, error)

	// NewsCreateWithBodyWithResponse request with any body
	NewsCreateWithBodyWithResponse(ctx context.Context, params *NewsCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NewsCreateResponse, error)

	NewsCreateWithResponse(ctx context.Context, params *NewsCreateParams, body NewsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*NewsCreateResponse, error)

	// NewsDestroyWithResponse request
	NewsDestroyWithResponse(ctx context.Context, id int, params *NewsDestroyParams, reqEditors ...RequestEditorFn) (*NewsDestroyResponse, error)

	// NewsShowWithResponse request
	NewsShowWithResponse(ctx context.Context, id int, params *NewsShowParams, reqEditors ...RequestEditorFn) (*NewsShowResponse, error)

	// NewsUpdatePatchWithBodyWithResponse request with any body
	NewsUpdatePatchWithBodyWithResponse(ctx context.Context, id int, params *NewsUpdatePatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NewsUpdatePatchResponse, error)

	NewsUpdatePatchWithResponse(ctx context.Context, id int, params *NewsUpdatePatchParams, body NewsUpdatePatchJSONRequestBody, reqEditors ...RequestEditorFn) (*NewsUpdatePatchResponse, error)

	// NewsUpdatePutWithBodyWithResponse request with any body
	NewsUpdatePutWithBodyWithResponse(ctx context.Context, id int, params *NewsUpdatePutParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NewsUpdatePutResponse, error)

	NewsUpdatePutWithResponse(ctx context.Context, id int, params *NewsUpdatePutParams, body NewsUpdatePutJSONRequestBody, reqEditors ...RequestEditorFn) (*NewsUpdatePutResponse, error)

	// ProjectsIndexCsvWithResponse request
	ProjectsIndexCsvWithResponse(ctx context.Context, params *ProjectsIndexCsvParams, reqEditors ...RequestEditorFn) (*ProjectsIndexCsvResponse, error)

	// ProjectsIndexWithResponse request
	ProjectsIndexWithResponse(ctx context.Context, params *ProjectsIndexParams, reqEditors ...RequestEditorFn) (*ProjectsIndexResponse, error)

	// ProjectsCreateWithBodyWithResponse request with any body
	ProjectsCreateWithBodyWithResponse(ctx context.Context, params *ProjectsCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProjectsCreateResponse, error)

	ProjectsCreateWithResponse(ctx context.Context, params *ProjectsCreateParams, body ProjectsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ProjectsCreateResponse, error)

	// ProjectsDestroyWithResponse request
	ProjectsDestroyWithResponse(ctx context.Context, id string, params *ProjectsDestroyParams, reqEditors ...RequestEditorFn) (*ProjectsDestroyResponse, error)

	// ProjectsShowWithResponse request
	ProjectsShowWithResponse(ctx context.Context, id string, params *ProjectsShowParams, reqEditors ...RequestEditorFn) (*ProjectsShowResponse, error)

	// ProjectsUpdatePatchWithBodyWithResponse request with any body
	ProjectsUpdatePatchWithBodyWithResponse(ctx context.Context, id string, params *ProjectsUpdatePatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProjectsUpdatePatchResponse, error)

	ProjectsUpdatePatchWithResponse(ctx context.Context, id string, params *ProjectsUpdatePatchParams, body ProjectsUpdatePatchJSONRequestBody, reqEditors ...RequestEditorFn) (*ProjectsUpdatePatchResponse, error)

	// ProjectsUpdatePutWithBodyWithResponse request with any body
	ProjectsUpdatePutWithBodyWithResponse(ctx context.Context, id string, params *ProjectsUpdatePutParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProjectsUpdatePutResponse, error)

	ProjectsUpdatePutWithResponse(ctx context.Context, id string, params *ProjectsUpdatePutParams, body ProjectsUpdatePutJSONRequestBody, reqEditors ...RequestEditorFn) (*ProjectsUpdatePutResponse, error)

	// ProjectsArchivePostWithResponse request
	ProjectsArchivePostWithResponse(ctx context.Context, id string, params *ProjectsArchivePostParams, reqEditors ...RequestEditorFn) (*ProjectsArchivePostResponse, error)

	// ProjectsArchivePutWithResponse request
	ProjectsArchivePutWithResponse(ctx context.Context, id string, params *ProjectsArchivePutParams, reqEditors ...RequestEditorFn) (*ProjectsArchivePutResponse, error)

	// RepositoriesAddRelatedIssueWithBodyWithResponse request with any body
	RepositoriesAddRelatedIssueWithBodyWithResponse(ctx context.Context, id string, repositoryId string, rev string, params *RepositoriesAddRelatedIssueParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RepositoriesAddRelatedIssueResponse, error)

	RepositoriesAddRelatedIssueWithResponse(ctx context.Context, id string, repositoryId string, rev string, params *RepositoriesAddRelatedIssueParams, body RepositoriesAddRelatedIssueJSONRequestBody, reqEditors ...RequestEditorFn) (*RepositoriesAddRelatedIssueResponse, error)

	// RepositoriesRemoveRelatedIssueWithResponse request
	RepositoriesRemoveRelatedIssueWithResponse(ctx context.Context, id string, repositoryId string, rev string, issueId int, params *RepositoriesRemoveRelatedIssueParams, reqEditors ...RequestEditorFn) (*RepositoriesRemoveRelatedIssueResponse, error)

	// ProjectsUnarchivePostWithResponse request
	ProjectsUnarchivePostWithResponse(ctx context.Context, id string, params *ProjectsUnarchivePostParams, reqEditors ...RequestEditorFn) (*ProjectsUnarchivePostResponse, error)

	// ProjectsUnarchivePutWithResponse request
	ProjectsUnarchivePutWithResponse(ctx context.Context, id string, params *ProjectsUnarchivePutParams, reqEditors ...RequestEditorFn) (*ProjectsUnarchivePutResponse, error)

	// FilesIndexWithResponse request
	FilesIndexWithResponse(ctx context.Context, projectId string, params *FilesIndexParams, reqEditors ...RequestEditorFn) (*FilesIndexResponse, error)

	// FilesCreateWithBodyWithResponse request with any body
	FilesCreateWithBodyWithResponse(ctx context.Context, projectId string, params *FilesCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FilesCreateResponse, error)

	FilesCreateWithResponse(ctx context.Context, projectId string, params *FilesCreateParams, body FilesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*FilesCreateResponse, error)

	// IssueCategoriesIndexWithResponse request
	IssueCategoriesIndexWithResponse(ctx context.Context, projectId string, params *IssueCategoriesIndexParams, reqEditors ...RequestEditorFn) (*IssueCategoriesIndexResponse, error)

	// IssueCategoriesCreateWithBodyWithResponse request with any body
	IssueCategoriesCreateWithBodyWithResponse(ctx context.Context, projectId string, params *IssueCategoriesCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IssueCategoriesCreateResponse, error)

	IssueCategoriesCreateWithResponse(ctx context.Context, projectId string, params *IssueCategoriesCreateParams, body IssueCategoriesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*IssueCategoriesCreateResponse, error)

	// IssuesIndexProjectCsvWithResponse request
	IssuesIndexProjectCsvWithResponse(ctx context.Context, projectId string, params *IssuesIndexProjectCsvParams, reqEditors ...RequestEditorFn) (*IssuesIndexProjectCsvResponse, error)

	// IssuesIndexProjectWithResponse request
	IssuesIndexProjectWithResponse(ctx context.Context, projectId string, params *IssuesIndexProjectParams, reqEditors ...RequestEditorFn) (*IssuesIndexProjectResponse, error)

	// IssuesCreateProjectWithBodyWithResponse request with any body
	IssuesCreateProjectWithBodyWithResponse(ctx context.Context, projectId string, params *IssuesCreateProjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IssuesCreateProjectResponse, error)

	IssuesCreateProjectWithResponse(ctx context.Context, projectId string, params *IssuesCreateProjectParams, body IssuesCreateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*IssuesCreateProjectResponse, error)

	// IssuesIndexProjectPdfWithResponse request
	IssuesIndexProjectPdfWithResponse(ctx context.Context, projectId string, params *IssuesIndexProjectPdfParams, reqEditors ...RequestEditorFn) (*IssuesIndexProjectPdfResponse, error)

	// GanttsShowProjectPdfWithResponse request
	GanttsShowProjectPdfWithResponse(ctx context.Context, projectId string, params *GanttsShowProjectPdfParams, reqEditors ...RequestEditorFn) (*GanttsShowProjectPdfResponse, error)

	// GanttsShowProjectPngWithResponse request
	GanttsShowProjectPngWithResponse(ctx context.Context, projectId string, params *GanttsShowProjectPngParams, reqEditors ...RequestEditorFn) (*GanttsShowProjectPngResponse, error)

	// MembersIndexWithResponse request
	MembersIndexWithResponse(ctx context.Context, projectId string, params *MembersIndexParams, reqEditors ...RequestEditorFn) (*MembersIndexResponse, error)

	// MembersCreateWithBodyWithResponse request with any body
	MembersCreateWithBodyWithResponse(ctx context.Context, projectId string, params *MembersCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MembersCreateResponse, error)

	MembersCreateWithResponse(ctx context.Context, projectId string, params *MembersCreateParams, body MembersCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*MembersCreateResponse, error)

	// NewsIndexProjectWithResponse request
	NewsIndexProjectWithResponse(ctx context.Context, projectId string, params *NewsIndexProjectParams, reqEditors ...RequestEditorFn) (*NewsIndexProjectResponse, error)

	// NewsCreateProjectWithBodyWithResponse request with any body
	NewsCreateProjectWithBodyWithResponse(ctx context.Context, projectId string, params *NewsCreateProjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NewsCreateProjectResponse, error)

	NewsCreateProjectWithResponse(ctx context.Context, projectId string, params *NewsCreateProjectParams, body NewsCreateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*NewsCreateProjectResponse, error)

	// SearchIndexProjectWithResponse request
	SearchIndexProjectWithResponse(ctx context.Context, projectId string, params *SearchIndexProjectParams, reqEditors ...RequestEditorFn) (*SearchIndexProjectResponse, error)

	// TimelogIndexProjectCsvWithResponse request
	TimelogIndexProjectCsvWithResponse(ctx context.Context, projectId string, params *TimelogIndexProjectCsvParams, reqEditors ...RequestEditorFn) (*TimelogIndexProjectCsvResponse, error)

	// TimelogIndexProjectWithResponse request
	TimelogIndexProjectWithResponse(ctx context.Context, projectId string, params *TimelogIndexProjectParams, reqEditors ...RequestEditorFn) (*TimelogIndexProjectResponse, error)

	// TimelogCreateProjectWithBodyWithResponse request with any body
	TimelogCreateProjectWithBodyWithResponse(ctx context.Context, projectId string, params *TimelogCreateProjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TimelogCreateProjectResponse, error)

	TimelogCreateProjectWithResponse(ctx context.Context, projectId string, params *TimelogCreateProjectParams, body TimelogCreateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*TimelogCreateProjectResponse, error)

	// VersionsIndexWithResponse request
	VersionsIndexWithResponse(ctx context.Context, projectId string, params *VersionsIndexParams, reqEditors ...RequestEditorFn) (*VersionsIndexResponse, error)

	// VersionsCreateWithBodyWithResponse request with any body
	VersionsCreateWithBodyWithResponse(ctx context.Context, projectId string, params *VersionsCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VersionsCreateResponse, error)

	VersionsCreateWithResponse(ctx context.Context, projectId string, params *VersionsCreateParams, body VersionsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*VersionsCreateResponse, error)

	// WikiShowRootWithResponse request
	WikiShowRootWithResponse(ctx context.Context, projectId string, params *WikiShowRootParams, reqEditors ...RequestEditorFn) (*WikiShowRootResponse, error)

	// WikiIndexWithResponse request
	WikiIndexWithResponse(ctx context.Context, projectId string, params *WikiIndexParams, reqEditors ...RequestEditorFn) (*WikiIndexResponse, error)

	// WikiDestroyWithResponse request
	WikiDestroyWithResponse(ctx context.Context, projectId string, id string, params *WikiDestroyParams, reqEditors ...RequestEditorFn) (*WikiDestroyResponse, error)

	// WikiShowWithResponse request
	WikiShowWithResponse(ctx context.Context, projectId string, id string, params *WikiShowParams, reqEditors ...RequestEditorFn) (*WikiShowResponse, error)

	// WikiUpdatePatchWithBodyWithResponse request with any body
	WikiUpdatePatchWithBodyWithResponse(ctx context.Context, projectId string, id string, params *WikiUpdatePatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WikiUpdatePatchResponse, error)

	WikiUpdatePatchWithResponse(ctx context.Context, projectId string, id string, params *WikiUpdatePatchParams, body WikiUpdatePatchJSONRequestBody, reqEditors ...RequestEditorFn) (*WikiUpdatePatchResponse, error)

	// WikiUpdatePutWithBodyWithResponse request with any body
	WikiUpdatePutWithBodyWithResponse(ctx context.Context, projectId string, id string, params *WikiUpdatePutParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WikiUpdatePutResponse, error)

	WikiUpdatePutWithResponse(ctx context.Context, projectId string, id string, params *WikiUpdatePutParams, body WikiUpdatePutJSONRequestBody, reqEditors ...RequestEditorFn) (*WikiUpdatePutResponse, error)

	// WikiShowPdfWithResponse request
	WikiShowPdfWithResponse(ctx context.Context, projectId string, id string, params *WikiShowPdfParams, reqEditors ...RequestEditorFn) (*WikiShowPdfResponse, error)

	// WikiShowTxtWithResponse request
	WikiShowTxtWithResponse(ctx context.Context, projectId string, id string, params *WikiShowTxtParams, reqEditors ...RequestEditorFn) (*WikiShowTxtResponse, error)

	// WikiShowVersionWithResponse request
	WikiShowVersionWithResponse(ctx context.Context, projectId string, id string, version int, params *WikiShowVersionParams, reqEditors ...RequestEditorFn) (*WikiShowVersionResponse, error)

	// WikiShowVersionPdfWithResponse request
	WikiShowVersionPdfWithResponse(ctx context.Context, projectId string, id string, version int, params *WikiShowVersionPdfParams, reqEditors ...RequestEditorFn) (*WikiShowVersionPdfResponse, error)

	// WikiShowVersionTxtWithResponse request
	WikiShowVersionTxtWithResponse(ctx context.Context, projectId string, id string, version int, params *WikiShowVersionTxtParams, reqEditors ...RequestEditorFn) (*WikiShowVersionTxtResponse, error)

	// QueriesIndexWithResponse request
	QueriesIndexWithResponse(ctx context.Context, params *QueriesIndexParams, reqEditors ...RequestEditorFn) (*QueriesIndexResponse, error)

	// IssueRelationsDestroyWithResponse request
	IssueRelationsDestroyWithResponse(ctx context.Context, id int, params *IssueRelationsDestroyParams, reqEditors ...RequestEditorFn) (*IssueRelationsDestroyResponse, error)

	// IssueRelationsShowWithResponse request
	IssueRelationsShowWithResponse(ctx context.Context, id int, params *IssueRelationsShowParams, reqEditors ...RequestEditorFn) (*IssueRelationsShowResponse, error)

	// RolesIndexWithResponse request
	RolesIndexWithResponse(ctx context.Context, params *RolesIndexParams, reqEditors ...RequestEditorFn) (*RolesIndexResponse, error)

	// RolesShowWithResponse request
	RolesShowWithResponse(ctx context.Context, id int, params *RolesShowParams, reqEditors ...RequestEditorFn) (*RolesShowResponse, error)

	// SearchIndexWithResponse request
	SearchIndexWithResponse(ctx context.Context, params *SearchIndexParams, reqEditors ...RequestEditorFn) (*SearchIndexResponse, error)

	// TimelogIndexCsvWithResponse request
	TimelogIndexCsvWithResponse(ctx context.Context, params *TimelogIndexCsvParams, reqEditors ...RequestEditorFn) (*TimelogIndexCsvResponse, error)

	// TimelogIndexWithResponse request
	TimelogIndexWithResponse(ctx context.Context, params *TimelogIndexParams, reqEditors ...RequestEditorFn) (*TimelogIndexResponse, error)

	// TimelogCreateWithBodyWithResponse request with any body
	TimelogCreateWithBodyWithResponse(ctx context.Context, params *TimelogCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TimelogCreateResponse, error)

	TimelogCreateWithResponse(ctx context.Context, params *TimelogCreateParams, body TimelogCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*TimelogCreateResponse, error)

	// TimelogDestroyWithResponse request
	TimelogDestroyWithResponse(ctx context.Context, id int, params *TimelogDestroyParams, reqEditors ...RequestEditorFn) (*TimelogDestroyResponse, error)

	// TimelogShowWithResponse request
	TimelogShowWithResponse(ctx context.Context, id int, params *TimelogShowParams, reqEditors ...RequestEditorFn) (*TimelogShowResponse, error)

	// TimelogUpdatePatchWithBodyWithResponse request with any body
	TimelogUpdatePatchWithBodyWithResponse(ctx context.Context, id int, params *TimelogUpdatePatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TimelogUpdatePatchResponse, error)

	TimelogUpdatePatchWithResponse(ctx context.Context, id int, params *TimelogUpdatePatchParams, body TimelogUpdatePatchJSONRequestBody, reqEditors ...RequestEditorFn) (*TimelogUpdatePatchResponse, error)

	// TimelogUpdatePutWithBodyWithResponse request with any body
	TimelogUpdatePutWithBodyWithResponse(ctx context.Context, id int, params *TimelogUpdatePutParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TimelogUpdatePutResponse, error)

	TimelogUpdatePutWithResponse(ctx context.Context, id int, params *TimelogUpdatePutParams, body TimelogUpdatePutJSONRequestBody, reqEditors ...RequestEditorFn) (*TimelogUpdatePutResponse, error)

	// TrackersIndexWithResponse request
	TrackersIndexWithResponse(ctx context.Context, params *TrackersIndexParams, reqEditors ...RequestEditorFn) (*TrackersIndexResponse, error)

	// AttachmentsUploadWithBodyWithResponse request with any body
	AttachmentsUploadWithBodyWithResponse(ctx context.Context, params *AttachmentsUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachmentsUploadResponse, error)

	// UsersIndexCsvWithResponse request
	UsersIndexCsvWithResponse(ctx context.Context, params *UsersIndexCsvParams, reqEditors ...RequestEditorFn) (*UsersIndexCsvResponse, error)

	// UsersIndexWithResponse request
	UsersIndexWithResponse(ctx context.Context, params *UsersIndexParams, reqEditors ...RequestEditorFn) (*UsersIndexResponse, error)

	// UsersCreateWithBodyWithResponse request with any body
	UsersCreateWithBodyWithResponse(ctx context.Context, params *UsersCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UsersCreateResponse, error)

	UsersCreateWithResponse(ctx context.Context, params *UsersCreateParams, body UsersCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*UsersCreateResponse, error)

	// UsersDestroyWithResponse request
	UsersDestroyWithResponse(ctx context.Context, id string, params *UsersDestroyParams, reqEditors ...RequestEditorFn) (*UsersDestroyResponse, error)

	// UsersShowWithResponse request
	UsersShowWithResponse(ctx context.Context, id string, params *UsersShowParams, reqEditors ...RequestEditorFn) (*UsersShowResponse, error)

	// UsersUpdatePatchWithBodyWithResponse request with any body
	UsersUpdatePatchWithBodyWithResponse(ctx context.Context, id string, params *UsersUpdatePatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UsersUpdatePatchResponse, error)

	UsersUpdatePatchWithResponse(ctx context.Context, id string, params *UsersUpdatePatchParams, body UsersUpdatePatchJSONRequestBody, reqEditors ...RequestEditorFn) (*UsersUpdatePatchResponse, error)

	// UsersUpdatePutWithBodyWithResponse request with any body
	UsersUpdatePutWithBodyWithResponse(ctx context.Context, id string, params *UsersUpdatePutParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UsersUpdatePutResponse, error)

	UsersUpdatePutWithResponse(ctx context.Context, id string, params *UsersUpdatePutParams, body UsersUpdatePutJSONRequestBody, reqEditors ...RequestEditorFn) (*UsersUpdatePutResponse, error)

	// VersionsDestroyWithResponse request
	VersionsDestroyWithResponse(ctx context.Context, id int, params *VersionsDestroyParams, reqEditors ...RequestEditorFn) (*VersionsDestroyResponse, error)

	// VersionsShowWithResponse request
	VersionsShowWithResponse(ctx context.Context, id int, params *VersionsShowParams, reqEditors ...RequestEditorFn) (*VersionsShowResponse, error)

	// VersionsUpdatePatchWithBodyWithResponse request with any body
	VersionsUpdatePatchWithBodyWithResponse(ctx context.Context, id int, params *VersionsUpdatePatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VersionsUpdatePatchResponse, error)

	VersionsUpdatePatchWithResponse(ctx context.Context, id int, params *VersionsUpdatePatchParams, body VersionsUpdatePatchJSONRequestBody, reqEditors ...RequestEditorFn) (*VersionsUpdatePatchResponse, error)

	// VersionsUpdatePutWithBodyWithResponse request with any body
	VersionsUpdatePutWithBodyWithResponse(ctx context.Context, id int, params *VersionsUpdatePutParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VersionsUpdatePutResponse, error)

	VersionsUpdatePutWithResponse(ctx context.Context, id int, params *VersionsUpdatePutParams, body VersionsUpdatePutJSONRequestBody, reqEditors ...RequestEditorFn) (*VersionsUpdatePutResponse, error)

	// VersionsShowTxtWithResponse request
	VersionsShowTxtWithResponse(ctx context.Context, id int, params *VersionsShowTxtParams, reqEditors ...RequestEditorFn) (*VersionsShowTxtResponse, error)

	// WatchersDestroyWithResponse request
	WatchersDestroyWithResponse(ctx context.Context, params *WatchersDestroyParams, reqEditors ...RequestEditorFn) (*WatchersDestroyResponse, error)

	// WatchersCreateWithBodyWithResponse request with any body
	WatchersCreateWithBodyWithResponse(ctx context.Context, params *WatchersCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WatchersCreateResponse, error)

	WatchersCreateWithResponse(ctx context.Context, params *WatchersCreateParams, body WatchersCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*WatchersCreateResponse, error)
}

type AttachmentsDownloadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AttachmentsDownloadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AttachmentsDownloadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AttachmentsThumbnailResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AttachmentsThumbnailResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AttachmentsThumbnailResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AttachmentsThumbnailSizeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AttachmentsThumbnailSizeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AttachmentsThumbnailSizeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AttachmentsDestroyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AttachmentsDestroyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AttachmentsDestroyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AttachmentsShowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Attachment *AttachmentsShow_200_Attachment `json:"attachment,omitempty"`
	}
}
type AttachmentsShow_200_Attachment struct {
	Author *struct {
		// Id The ID of the author.
		Id *int `json:"id,omitempty"`

		// Name The name of the author.
		Name *string `json:"name,omitempty"`
	} `json:"author,omitempty"`

	// ContentType The content type of the attachment.
	ContentType *string `json:"content_type,omitempty"`

	// ContentUrl The content URL of the attachment.
	ContentUrl *string `json:"content_url,omitempty"`

	// CreatedOn The date and time when the attachment was created.
	CreatedOn *time.Time `json:"created_on,omitempty"`

	// Description The description of the attachment.
	Description *string `json:"description,omitempty"`

	// Filename The filename of the attachment.
	Filename *string `json:"filename,omitempty"`

	// Filesize The filesize of the attachment.
	Filesize *int `json:"filesize,omitempty"`

	// Id The ID of the attachment.
	Id *int `json:"id,omitempty"`

	// ThumbnailUrl The thumbnail URL of the attachment.
	ThumbnailUrl         *string                `json:"thumbnail_url,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Status returns HTTPResponse.Status
func (r AttachmentsShowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AttachmentsShowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AttachmentsUpdatePatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *struct {
		Errors *[]string `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AttachmentsUpdatePatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AttachmentsUpdatePatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AttachmentsUpdatePutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *struct {
		Errors *[]string `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AttachmentsUpdatePutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AttachmentsUpdatePutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AttachmentsDownloadAllResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AttachmentsDownloadAllResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AttachmentsDownloadAllResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CustomFieldsIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		CustomFields *[]struct {
			// CustomizedType The type of object this custom field is associated with.
			CustomizedType *string `json:"customized_type,omitempty"`

			// DefaultValue The default value for the custom field.
			DefaultValue *string `json:"default_value,omitempty"`

			// Description A description of the custom field.
			Description *string `json:"description,omitempty"`

			// Editable The editable of the custom field.
			Editable *bool `json:"editable,omitempty"`

			// FieldFormat The format of the custom field.
			// Possible values are:
			// - `string`
			// - `text`
			// - `link`
			// - `int`
			// - `float`
			// - `date`
			// - `list`
			// - `bool`
			// - `enumeration`
			// - `user`
			// - `version`
			// - `attachement`
			FieldFormat *string `json:"field_format,omitempty"`

			// Id The unique identifier of the custom field.
			Id *int `json:"id,omitempty"`

			// IsFilter Whether the custom field can be used as a filter.
			IsFilter *bool `json:"is_filter,omitempty"`

			// IsRequired Whether the custom field is required.
			IsRequired *bool `json:"is_required,omitempty"`

			// MaxLength The maximum length allowed for the custom field value.
			MaxLength *int `json:"max_length,omitempty"`

			// MinLength The minimum length allowed for the custom field value.
			MinLength *int `json:"min_length,omitempty"`

			// Multiple Whether the custom field allows multiple values.
			Multiple *bool `json:"multiple,omitempty"`

			// Name The name of the custom field.
			Name *string `json:"name,omitempty"`

			// PossibleValues The possible values of the custom field.
			PossibleValues *[]struct {
				// Label The label of the possible value.
				Label *string `json:"label,omitempty"`

				// Value The value of the possible value.
				Value *string `json:"value,omitempty"`
			} `json:"possible_values,omitempty"`

			// Regexp The regular expression pattern for the custom field value.
			Regexp *string `json:"regexp,omitempty"`
			Roles  *[]struct {
				// Id The id of the role.
				Id *int `json:"id,omitempty"`

				// Name The name of the role.
				Name *string `json:"name,omitempty"`
			} `json:"roles,omitempty"`

			// Searchable Whether the custom field is searchable.
			Searchable *bool `json:"searchable,omitempty"`
			Trackers   *[]struct {
				// Id The id of the tracker.
				Id *int `json:"id,omitempty"`

				// Name The name of the tracker.
				Name *string `json:"name,omitempty"`
			} `json:"trackers,omitempty"`

			// Visible Whether the custom field is visible.
			Visible *bool `json:"visible,omitempty"`
		} `json:"custom_fields,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CustomFieldsIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CustomFieldsIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnumerationsIndexDocumentCategoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		DocumentCategories *[]struct {
			// Active The active of the enumeration.
			Active       *bool `json:"active,omitempty"`
			CustomFields *[]struct {
				// Id The ID of the custom field.
				Id *int `json:"id,omitempty"`

				// Multiple Whether the custom field can have multiple values.
				Multiple *bool `json:"multiple,omitempty"`

				// Name The name of the custom field.
				Name  *string      `json:"name,omitempty"`
				Value *interface{} `json:"value,omitempty"`
			} `json:"custom_fields,omitempty"`

			// Id The unique identifier of the enumeration.
			Id *int `json:"id,omitempty"`

			// IsDefault The default of the enumeration.
			IsDefault *bool `json:"is_default,omitempty"`

			// Name The name of the enumeration.
			Name *string `json:"name,omitempty"`
		} `json:"document_categories,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r EnumerationsIndexDocumentCategoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnumerationsIndexDocumentCategoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnumerationsIndexIssuePriorityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IssuePriorities *[]struct {
			// Active The active of the enumeration.
			Active       *bool `json:"active,omitempty"`
			CustomFields *[]struct {
				// Id The ID of the custom field.
				Id *int `json:"id,omitempty"`

				// Multiple Whether the custom field can have multiple values.
				Multiple *bool `json:"multiple,omitempty"`

				// Name The name of the custom field.
				Name  *string      `json:"name,omitempty"`
				Value *interface{} `json:"value,omitempty"`
			} `json:"custom_fields,omitempty"`

			// Id The unique identifier of the enumeration.
			Id *int `json:"id,omitempty"`

			// IsDefault The default of the enumeration.
			IsDefault *bool `json:"is_default,omitempty"`

			// Name The name of the enumeration.
			Name *string `json:"name,omitempty"`
		} `json:"issue_priorities,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r EnumerationsIndexIssuePriorityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnumerationsIndexIssuePriorityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnumerationsIndexTimeEntryActivityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		TimeEntryActivities *[]struct {
			// Active The active of the enumeration.
			Active       *bool `json:"active,omitempty"`
			CustomFields *[]struct {
				// Id The ID of the custom field.
				Id *int `json:"id,omitempty"`

				// Multiple Whether the custom field can have multiple values.
				Multiple *bool `json:"multiple,omitempty"`

				// Name The name of the custom field.
				Name  *string      `json:"name,omitempty"`
				Value *interface{} `json:"value,omitempty"`
			} `json:"custom_fields,omitempty"`

			// Id The unique identifier of the enumeration.
			Id *int `json:"id,omitempty"`

			// IsDefault The default of the enumeration.
			IsDefault *bool `json:"is_default,omitempty"`

			// Name The name of the enumeration.
			Name *string `json:"name,omitempty"`
		} `json:"time_entry_activities,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r EnumerationsIndexTimeEntryActivityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnumerationsIndexTimeEntryActivityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GroupsIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Groups *[]struct {
			// Builtin The builtin type of the group.
			Builtin      *string `json:"builtin,omitempty"`
			CustomFields *[]struct {
				// Id The ID of the custom field.
				Id *int `json:"id,omitempty"`

				// Multiple Whether the custom field can have multiple values.
				Multiple *bool `json:"multiple,omitempty"`

				// Name The name of the custom field.
				Name  *string      `json:"name,omitempty"`
				Value *interface{} `json:"value,omitempty"`
			} `json:"custom_fields,omitempty"`

			// Id The ID of the group.
			Id *int `json:"id,omitempty"`

			// Name The name of the group.
			Name *string `json:"name,omitempty"`
		} `json:"groups,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GroupsIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GroupsIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GroupsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Group A single group.
		Group *struct {
			// Builtin The builtin type of the group.
			Builtin      *string `json:"builtin,omitempty"`
			CustomFields *[]struct {
				// Id The ID of the custom field.
				Id *int `json:"id,omitempty"`

				// Multiple Whether the custom field can have multiple values.
				Multiple *bool `json:"multiple,omitempty"`

				// Name The name of the custom field.
				Name  *string      `json:"name,omitempty"`
				Value *interface{} `json:"value,omitempty"`
			} `json:"custom_fields,omitempty"`

			// Id The ID of the group.
			Id          *int `json:"id,omitempty"`
			Memberships *[]struct {
				// Id The ID of the mebership.
				Id      *int `json:"id,omitempty"`
				Project *struct {
					// Id The ID of the project.
					Id *int `json:"id,omitempty"`

					// Name The name of the project.
					Name *string `json:"name,omitempty"`
				} `json:"project,omitempty"`
				Roles *[]struct {
					// Id The ID of the role.
					Id *int `json:"id,omitempty"`

					// Inherited Whether the role is inherited from a parent project.
					Inherited *bool `json:"inherited,omitempty"`

					// Name The name of the role.
					Name *string `json:"name,omitempty"`
				} `json:"roles,omitempty"`
			} `json:"memberships,omitempty"`

			// Name The name of the group.
			Name  *string `json:"name,omitempty"`
			Users *[]struct {
				// Id The ID of the user.
				Id *int `json:"id,omitempty"`

				// Name The name of the user.
				Name *string `json:"name,omitempty"`
			} `json:"users,omitempty"`
		} `json:"group,omitempty"`
	}
	JSON422 *struct {
		Errors *[]string `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GroupsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GroupsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GroupsDestroyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GroupsDestroyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GroupsDestroyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GroupsShowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Group A single group.
		Group *struct {
			// Builtin The builtin type of the group.
			Builtin      *string `json:"builtin,omitempty"`
			CustomFields *[]struct {
				// Id The ID of the custom field.
				Id *int `json:"id,omitempty"`

				// Multiple Whether the custom field can have multiple values.
				Multiple *bool `json:"multiple,omitempty"`

				// Name The name of the custom field.
				Name  *string      `json:"name,omitempty"`
				Value *interface{} `json:"value,omitempty"`
			} `json:"custom_fields,omitempty"`

			// Id The ID of the group.
			Id          *int `json:"id,omitempty"`
			Memberships *[]struct {
				// Id The ID of the mebership.
				Id      *int `json:"id,omitempty"`
				Project *struct {
					// Id The ID of the project.
					Id *int `json:"id,omitempty"`

					// Name The name of the project.
					Name *string `json:"name,omitempty"`
				} `json:"project,omitempty"`
				Roles *[]struct {
					// Id The ID of the role.
					Id *int `json:"id,omitempty"`

					// Inherited Whether the role is inherited from a parent project.
					Inherited *bool `json:"inherited,omitempty"`

					// Name The name of the role.
					Name *string `json:"name,omitempty"`
				} `json:"roles,omitempty"`
			} `json:"memberships,omitempty"`

			// Name The name of the group.
			Name  *string `json:"name,omitempty"`
			Users *[]struct {
				// Id The ID of the user.
				Id *int `json:"id,omitempty"`

				// Name The name of the user.
				Name *string `json:"name,omitempty"`
			} `json:"users,omitempty"`
		} `json:"group,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GroupsShowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GroupsShowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GroupsUpdatePatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *struct {
		Errors *[]string `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GroupsUpdatePatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GroupsUpdatePatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GroupsUpdatePutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *struct {
		Errors *[]string `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GroupsUpdatePutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GroupsUpdatePutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GroupsAddUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *struct {
		Errors *[]string `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GroupsAddUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GroupsAddUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GroupsRemoveUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GroupsRemoveUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GroupsRemoveUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssueCategoriesDestroyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r IssueCategoriesDestroyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssueCategoriesDestroyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssueCategoriesShowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// IssueCategory A single issue category.
		IssueCategory *struct {
			AssignedTo *struct {
				// Id The ID of the assigned to.
				Id *int `json:"id,omitempty"`

				// Name The name of the assigned to.
				Name *string `json:"name,omitempty"`
			} `json:"assigned_to,omitempty"`

			// Id The ID of the issue category.
			Id *int `json:"id,omitempty"`

			// Name The name of the issue category.
			Name    *string `json:"name,omitempty"`
			Project *struct {
				// Id The ID of the project.
				Id *int `json:"id,omitempty"`

				// Name The name of the project.
				Name *string `json:"name,omitempty"`
			} `json:"project,omitempty"`
		} `json:"issue_category,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r IssueCategoriesShowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssueCategoriesShowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssueCategoriesUpdatePatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *struct {
		Errors *[]string `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r IssueCategoriesUpdatePatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssueCategoriesUpdatePatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssueCategoriesUpdatePutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *struct {
		Errors *[]string `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r IssueCategoriesUpdatePutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssueCategoriesUpdatePutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssueStatusesIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IssueStatuses *[]struct {
			// Description A description of the issue status.
			Description *string `json:"description,omitempty"`

			// Id The unique identifier of the issue status.
			Id *int `json:"id,omitempty"`

			// IsClosed Whether the issue status is closed.
			IsClosed *bool `json:"is_closed,omitempty"`

			// Name The name of the issue status.
			Name *string `json:"name,omitempty"`
		} `json:"issue_statuses,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r IssueStatusesIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssueStatusesIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssuesIndexCsvResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *struct {
		Errors *[]string `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r IssuesIndexCsvResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssuesIndexCsvResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssuesIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Issues *[]struct {
			AssignedTo *struct {
				// Id The ID of the assigned member.
				Id *int `json:"id,omitempty"`

				// Name The name of the assigned member.
				Name *string `json:"name,omitempty"`
			} `json:"assigned_to,omitempty"`
			Attachments *[]IssuesIndex_200_Issues_Attachments_Item `json:"attachments,omitempty"`
			Author      *struct {
				// Id The ID of the author.
				Id *int `json:"id,omitempty"`

				// Name The name of the author.
				Name *string `json:"name,omitempty"`
			} `json:"author,omitempty"`
			Category *struct {
				// Id The ID of the category.
				Id *int `json:"id,omitempty"`

				// Name The name of the category.
				Name *string `json:"name,omitempty"`
			} `json:"category,omitempty"`

			// ClosedOn The date and time when the issue was closed.
			ClosedOn *time.Time `json:"closed_on,omitempty"`

			// CreatedOn The date and time when the issue was created.
			CreatedOn    *time.Time `json:"created_on,omitempty"`
			CustomFields *[]struct {
				// Id The ID of the custom field.
				Id *int `json:"id,omitempty"`

				// Multiple Whether the custom field can have multiple values.
				Multiple *bool `json:"multiple,omitempty"`

				// Name The name of the custom field.
				Name  *string      `json:"name,omitempty"`
				Value *interface{} `json:"value,omitempty"`
			} `json:"custom_fields,omitempty"`

			// Description The description of the issue.
			Description *string `json:"description,omitempty"`

			// DoneRatio The done ratio of the issue.
			DoneRatio *int `json:"done_ratio,omitempty"`

			// DueDate The due date of the issue.
			DueDate *openapi_types.Date `json:"due_date,omitempty"`

			// EstimatedHours The estimated hours of the issue.
			EstimatedHours *float32 `json:"estimated_hours,omitempty"`
			FixedVersion   *struct {
				// Id The ID of the fixed version.
				Id *int `json:"id,omitempty"`

				// Name The name of the fixed version.
				Name *string `json:"name,omitempty"`
			} `json:"fixed_version,omitempty"`

			// Id The ID of the issue.
			Id *int `json:"id,omitempty"`

			// IsPrivate The private of the issue.
			IsPrivate *bool `json:"is_private,omitempty"`
			Parent    *struct {
				// Id The ID of the parent issue.
				Id *int `json:"id,omitempty"`
			} `json:"parent,omitempty"`
			Priority *struct {
				// Id The ID of the priority.
				Id *int `json:"id,omitempty"`

				// Name The name of the priority.
				Name *string `json:"name,omitempty"`
			} `json:"priority,omitempty"`
			Project *struct {
				// Id The ID of the project.
				Id *int `json:"id,omitempty"`

				// Name The name of the project.
				Name *string `json:"name,omitempty"`
			} `json:"project,omitempty"`
			Relations *[]struct {
				// Delay The delay of the relation.
				Delay *int `json:"delay,omitempty"`

				// Id The ID of the relation.
				Id *int `json:"id,omitempty"`

				// IssueId The ID of the issue.
				IssueId *int `json:"issue_id,omitempty"`

				// IssueToId The ID of the issue.
				IssueToId *int `json:"issue_to_id,omitempty"`

				// RelationType The type of the relation.
				RelationType *string `json:"relation_type,omitempty"`
			} `json:"relations,omitempty"`

			// SpentHours The spent hours of the issue.
			SpentHours *float32 `json:"spent_hours,omitempty"`

			// StartDate The start date of the issue.
			StartDate *openapi_types.Date `json:"start_date,omitempty"`
			Status    *struct {
				// Id The ID of the status.
				Id *int `json:"id,omitempty"`

				// IsClosed The closed of the status.
				IsClosed *bool `json:"is_closed,omitempty"`

				// Name The name of the status.
				Name *string `json:"name,omitempty"`
			} `json:"status,omitempty"`

			// Subject The subject of the issue.
			Subject *string `json:"subject,omitempty"`

			// TotalEstimatedHours The total estimated hours of the issue.
			TotalEstimatedHours *float32 `json:"total_estimated_hours,omitempty"`

			// TotalSpentHours The total spent hours of the issue.
			TotalSpentHours *float32 `json:"total_spent_hours,omitempty"`
			Tracker         *struct {
				// Id The ID of the tracker.
				Id *int `json:"id,omitempty"`

				// Name The name of the tracker.
				Name *string `json:"name,omitempty"`
			} `json:"tracker,omitempty"`

			// UpdatedOn The date and time when the issue was updated.
			UpdatedOn *time.Time `json:"updated_on,omitempty"`
		} `json:"issues,omitempty"`

		// Limit The maximum number of issues returned in the list.
		Limit *int `json:"limit,omitempty"`

		// Offset The offset of the first issue in the list.
		Offset *int `json:"offset,omitempty"`

		// TotalCount The total number of issues.
		TotalCount *int `json:"total_count,omitempty"`
	}
	JSON422 *struct {
		Errors *[]string `json:"errors,omitempty"`
	}
}
type IssuesIndex_200_Issues_Attachments_Item struct {
	Author *struct {
		// Id The ID of the author.
		Id *int `json:"id,omitempty"`

		// Name The name of the author.
		Name *string `json:"name,omitempty"`
	} `json:"author,omitempty"`

	// ContentType The content type of the attachment.
	ContentType *string `json:"content_type,omitempty"`

	// ContentUrl The content URL of the attachment.
	ContentUrl *string `json:"content_url,omitempty"`

	// CreatedOn The date and time when the attachment was created.
	CreatedOn *time.Time `json:"created_on,omitempty"`

	// Description The description of the attachment.
	Description *string `json:"description,omitempty"`

	// Filename The filename of the attachment.
	Filename *string `json:"filename,omitempty"`

	// Filesize The filesize of the attachment.
	Filesize *int `json:"filesize,omitempty"`

	// Id The ID of the attachment.
	Id *int `json:"id,omitempty"`

	// ThumbnailUrl The thumbnail URL of the attachment.
	ThumbnailUrl         *string                `json:"thumbnail_url,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Status returns HTTPResponse.Status
func (r IssuesIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssuesIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssuesCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Issue A single issue.
		Issue *struct {
			AllowedStatuses *[]struct {
				// Id The ID of the allowed statuse.
				Id *int `json:"id,omitempty"`

				// IsClosed The closed of the allowed status.
				IsClosed *bool `json:"is_closed,omitempty"`

				// Name The name of the allowed statuse.
				Name *string `json:"name,omitempty"`
			} `json:"allowed_statuses,omitempty"`
			AssignedTo *struct {
				// Id The ID of the assigned member.
				Id *int `json:"id,omitempty"`

				// Name The name of the assigned member.
				Name *string `json:"name,omitempty"`
			} `json:"assigned_to,omitempty"`
			Attachments *[]IssuesCreate_201_Issue_Attachments_Item `json:"attachments,omitempty"`
			Author      *struct {
				// Id The ID of the author.
				Id *int `json:"id,omitempty"`

				// Name The name of the author.
				Name *string `json:"name,omitempty"`
			} `json:"author,omitempty"`
			Category *struct {
				// Id The ID of the category.
				Id *int `json:"id,omitempty"`

				// Name The name of the category.
				Name *string `json:"name,omitempty"`
			} `json:"category,omitempty"`
			Changesets *[]struct {
				// Comments The comments of the changeset.
				Comments *string `json:"comments,omitempty"`

				// CommittedOn The date and time when the changeset was committed.
				CommittedOn *time.Time `json:"committed_on,omitempty"`

				// Revision The revision of the changeset.
				Revision *string `json:"revision,omitempty"`
				User     *struct {
					// Id The ID of the user.
					Id *int `json:"id,omitempty"`

					// Name The name of the user.
					Name *string `json:"name,omitempty"`
				} `json:"user,omitempty"`
			} `json:"changesets,omitempty"`
			Children *[]struct {
				Children *[]interface{} `json:"children,omitempty"`

				// Id The ID of the issue.
				Id *int `json:"id,omitempty"`

				// Subject The subject of the issue.
				Subject *string `json:"subject,omitempty"`
				Tracker *struct {
					// Id The ID of the tracker.
					Id *int `json:"id,omitempty"`

					// Name The name of the tracker.
					Name *string `json:"name,omitempty"`
				} `json:"tracker,omitempty"`
			} `json:"children,omitempty"`

			// ClosedOn The date and time when the issue was closed.
			ClosedOn *time.Time `json:"closed_on,omitempty"`

			// CreatedOn The date and time when the issue was created.
			CreatedOn    *time.Time `json:"created_on,omitempty"`
			CustomFields *[]struct {
				// Id The ID of the custom field.
				Id *int `json:"id,omitempty"`

				// Multiple Whether the custom field can have multiple values.
				Multiple *bool `json:"multiple,omitempty"`

				// Name The name of the custom field.
				Name  *string      `json:"name,omitempty"`
				Value *interface{} `json:"value,omitempty"`
			} `json:"custom_fields,omitempty"`

			// Description The description of the issue.
			Description *string `json:"description,omitempty"`

			// DoneRatio The done ratio of the issue.
			DoneRatio *int `json:"done_ratio,omitempty"`

			// DueDate The due date of the issue.
			DueDate *openapi_types.Date `json:"due_date,omitempty"`

			// EstimatedHours The estimated hours of the issue.
			EstimatedHours *float32 `json:"estimated_hours,omitempty"`
			FixedVersion   *struct {
				// Id The ID of the fixed version.
				Id *int `json:"id,omitempty"`

				// Name The name of the fixed version.
				Name *string `json:"name,omitempty"`
			} `json:"fixed_version,omitempty"`

			// Id The ID of the issue.
			Id *int `json:"id,omitempty"`

			// IsPrivate The private of the issue.
			IsPrivate *bool `json:"is_private,omitempty"`
			Journals  *[]struct {
				// CreatedOn The date and time when the journal was created.
				CreatedOn *time.Time `json:"created_on,omitempty"`
				Details   *[]struct {
					// Name The name of the detail.
					Name *string `json:"name,omitempty"`

					// NewValue The new value of the detail.
					NewValue *string `json:"new_value,omitempty"`

					// OldValue The old value of the detail.
					OldValue *string `json:"old_value,omitempty"`

					// Property The property of the detail.
					Property *string `json:"property,omitempty"`
				} `json:"details,omitempty"`

				// Id The ID of the journal.
				Id *int `json:"id,omitempty"`

				// Notes The notes of the journal.
				Notes *string `json:"notes,omitempty"`

				// PrivateNotes The private of the journal.
				PrivateNotes *bool `json:"private_notes,omitempty"`
				UpdatedBy    *struct {
					// Id The ID of the updated.
					Id *int `json:"id,omitempty"`

					// Name The name of the updated.
					Name *string `json:"name,omitempty"`
				} `json:"updated_by,omitempty"`

				// UpdatedOn The date and time when the journal was updated.
				UpdatedOn *time.Time `json:"updated_on,omitempty"`
				User      *struct {
					// Id The ID of the user.
					Id *int `json:"id,omitempty"`

					// Name The name of the user.
					Name *string `json:"name,omitempty"`
				} `json:"user,omitempty"`
			} `json:"journals,omitempty"`
			Parent *struct {
				// Id The ID of the parent issue.
				Id *int `json:"id,omitempty"`
			} `json:"parent,omitempty"`
			Priority *struct {
				// Id The ID of the priority.
				Id *int `json:"id,omitempty"`

				// Name The name of the priority.
				Name *string `json:"name,omitempty"`
			} `json:"priority,omitempty"`
			Project *struct {
				// Id The ID of the project.
				Id *int `json:"id,omitempty"`

				// Name The name of the project.
				Name *string `json:"name,omitempty"`
			} `json:"project,omitempty"`
			Relations *[]struct {
				// Delay The delay of the relation.
				Delay *int `json:"delay,omitempty"`

				// Id The ID of the relation.
				Id *int `json:"id,omitempty"`

				// IssueId The ID of the issue.
				IssueId *int `json:"issue_id,omitempty"`

				// IssueToId The ID of the issue.
				IssueToId *int `json:"issue_to_id,omitempty"`

				// RelationType The type of the relation.
				RelationType *string `json:"relation_type,omitempty"`
			} `json:"relations,omitempty"`

			// SpentHours The spent hours of the issue.
			SpentHours *float32 `json:"spent_hours,omitempty"`

			// StartDate The start date of the issue.
			StartDate *openapi_types.Date `json:"start_date,omitempty"`
			Status    *struct {
				// Id The ID of the status.
				Id *int `json:"id,omitempty"`

				// IsClosed The closed of the status.
				IsClosed *bool `json:"is_closed,omitempty"`

				// Name The name of the status.
				Name *string `json:"name,omitempty"`
			} `json:"status,omitempty"`

			// Subject The subject of the issue.
			Subject *string `json:"subject,omitempty"`

			// TotalEstimatedHours The total estimated hours of the issue.
			TotalEstimatedHours *float32 `json:"total_estimated_hours,omitempty"`

			// TotalSpentHours The total spent hours of the issue.
			TotalSpentHours *float32 `json:"total_spent_hours,omitempty"`
			Tracker         *struct {
				// Id The ID of the tracker.
				Id *int `json:"id,omitempty"`

				// Name The name of the tracker.
				Name *string `json:"name,omitempty"`
			} `json:"tracker,omitempty"`

			// UpdatedOn The date and time when the issue was updated.
			UpdatedOn *time.Time `json:"updated_on,omitempty"`
			Watchers  *[]struct {
				// Id The ID of the watcher.
				Id *int `json:"id,omitempty"`

				// Name The name of the watcher.
				Name *string `json:"name,omitempty"`
			} `json:"watchers,omitempty"`
		} `json:"issue,omitempty"`
	}
	JSON422 *struct {
		Errors *[]string `json:"errors,omitempty"`
	}
}
type IssuesCreate_201_Issue_Attachments_Item struct {
	Author *struct {
		// Id The ID of the author.
		Id *int `json:"id,omitempty"`

		// Name The name of the author.
		Name *string `json:"name,omitempty"`
	} `json:"author,omitempty"`

	// ContentType The content type of the attachment.
	ContentType *string `json:"content_type,omitempty"`

	// ContentUrl The content URL of the attachment.
	ContentUrl *string `json:"content_url,omitempty"`

	// CreatedOn The date and time when the attachment was created.
	CreatedOn *time.Time `json:"created_on,omitempty"`

	// Description The description of the attachment.
	Description *string `json:"description,omitempty"`

	// Filename The filename of the attachment.
	Filename *string `json:"filename,omitempty"`

	// Filesize The filesize of the attachment.
	Filesize *int `json:"filesize,omitempty"`

	// Id The ID of the attachment.
	Id *int `json:"id,omitempty"`

	// ThumbnailUrl The thumbnail URL of the attachment.
	ThumbnailUrl         *string                `json:"thumbnail_url,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Status returns HTTPResponse.Status
func (r IssuesCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssuesCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssuesIndexPdfResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *struct {
		Errors *[]string `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r IssuesIndexPdfResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssuesIndexPdfResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GanttsShowPdfResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GanttsShowPdfResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GanttsShowPdfResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GanttsShowPngResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GanttsShowPngResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GanttsShowPngResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssuesDestroyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *struct {
		Errors *[]string `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r IssuesDestroyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssuesDestroyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssuesShowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Issue A single issue.
		Issue *struct {
			AllowedStatuses *[]struct {
				// Id The ID of the allowed statuse.
				Id *int `json:"id,omitempty"`

				// IsClosed The closed of the allowed status.
				IsClosed *bool `json:"is_closed,omitempty"`

				// Name The name of the allowed statuse.
				Name *string `json:"name,omitempty"`
			} `json:"allowed_statuses,omitempty"`
			AssignedTo *struct {
				// Id The ID of the assigned member.
				Id *int `json:"id,omitempty"`

				// Name The name of the assigned member.
				Name *string `json:"name,omitempty"`
			} `json:"assigned_to,omitempty"`
			Attachments *[]IssuesShow_200_Issue_Attachments_Item `json:"attachments,omitempty"`
			Author      *struct {
				// Id The ID of the author.
				Id *int `json:"id,omitempty"`

				// Name The name of the author.
				Name *string `json:"name,omitempty"`
			} `json:"author,omitempty"`
			Category *struct {
				// Id The ID of the category.
				Id *int `json:"id,omitempty"`

				// Name The name of the category.
				Name *string `json:"name,omitempty"`
			} `json:"category,omitempty"`
			Changesets *[]struct {
				// Comments The comments of the changeset.
				Comments *string `json:"comments,omitempty"`

				// CommittedOn The date and time when the changeset was committed.
				CommittedOn *time.Time `json:"committed_on,omitempty"`

				// Revision The revision of the changeset.
				Revision *string `json:"revision,omitempty"`
				User     *struct {
					// Id The ID of the user.
					Id *int `json:"id,omitempty"`

					// Name The name of the user.
					Name *string `json:"name,omitempty"`
				} `json:"user,omitempty"`
			} `json:"changesets,omitempty"`
			Children *[]struct {
				Children *[]interface{} `json:"children,omitempty"`

				// Id The ID of the issue.
				Id *int `json:"id,omitempty"`

				// Subject The subject of the issue.
				Subject *string `json:"subject,omitempty"`
				Tracker *struct {
					// Id The ID of the tracker.
					Id *int `json:"id,omitempty"`

					// Name The name of the tracker.
					Name *string `json:"name,omitempty"`
				} `json:"tracker,omitempty"`
			} `json:"children,omitempty"`

			// ClosedOn The date and time when the issue was closed.
			ClosedOn *time.Time `json:"closed_on,omitempty"`

			// CreatedOn The date and time when the issue was created.
			CreatedOn    *time.Time `json:"created_on,omitempty"`
			CustomFields *[]struct {
				// Id The ID of the custom field.
				Id *int `json:"id,omitempty"`

				// Multiple Whether the custom field can have multiple values.
				Multiple *bool `json:"multiple,omitempty"`

				// Name The name of the custom field.
				Name  *string      `json:"name,omitempty"`
				Value *interface{} `json:"value,omitempty"`
			} `json:"custom_fields,omitempty"`

			// Description The description of the issue.
			Description *string `json:"description,omitempty"`

			// DoneRatio The done ratio of the issue.
			DoneRatio *int `json:"done_ratio,omitempty"`

			// DueDate The due date of the issue.
			DueDate *openapi_types.Date `json:"due_date,omitempty"`

			// EstimatedHours The estimated hours of the issue.
			EstimatedHours *float32 `json:"estimated_hours,omitempty"`
			FixedVersion   *struct {
				// Id The ID of the fixed version.
				Id *int `json:"id,omitempty"`

				// Name The name of the fixed version.
				Name *string `json:"name,omitempty"`
			} `json:"fixed_version,omitempty"`

			// Id The ID of the issue.
			Id *int `json:"id,omitempty"`

			// IsPrivate The private of the issue.
			IsPrivate *bool `json:"is_private,omitempty"`
			Journals  *[]struct {
				// CreatedOn The date and time when the journal was created.
				CreatedOn *time.Time `json:"created_on,omitempty"`
				Details   *[]struct {
					// Name The name of the detail.
					Name *string `json:"name,omitempty"`

					// NewValue The new value of the detail.
					NewValue *string `json:"new_value,omitempty"`

					// OldValue The old value of the detail.
					OldValue *string `json:"old_value,omitempty"`

					// Property The property of the detail.
					Property *string `json:"property,omitempty"`
				} `json:"details,omitempty"`

				// Id The ID of the journal.
				Id *int `json:"id,omitempty"`

				// Notes The notes of the journal.
				Notes *string `json:"notes,omitempty"`

				// PrivateNotes The private of the journal.
				PrivateNotes *bool `json:"private_notes,omitempty"`
				UpdatedBy    *struct {
					// Id The ID of the updated.
					Id *int `json:"id,omitempty"`

					// Name The name of the updated.
					Name *string `json:"name,omitempty"`
				} `json:"updated_by,omitempty"`

				// UpdatedOn The date and time when the journal was updated.
				UpdatedOn *time.Time `json:"updated_on,omitempty"`
				User      *struct {
					// Id The ID of the user.
					Id *int `json:"id,omitempty"`

					// Name The name of the user.
					Name *string `json:"name,omitempty"`
				} `json:"user,omitempty"`
			} `json:"journals,omitempty"`
			Parent *struct {
				// Id The ID of the parent issue.
				Id *int `json:"id,omitempty"`
			} `json:"parent,omitempty"`
			Priority *struct {
				// Id The ID of the priority.
				Id *int `json:"id,omitempty"`

				// Name The name of the priority.
				Name *string `json:"name,omitempty"`
			} `json:"priority,omitempty"`
			Project *struct {
				// Id The ID of the project.
				Id *int `json:"id,omitempty"`

				// Name The name of the project.
				Name *string `json:"name,omitempty"`
			} `json:"project,omitempty"`
			Relations *[]struct {
				// Delay The delay of the relation.
				Delay *int `json:"delay,omitempty"`

				// Id The ID of the relation.
				Id *int `json:"id,omitempty"`

				// IssueId The ID of the issue.
				IssueId *int `json:"issue_id,omitempty"`

				// IssueToId The ID of the issue.
				IssueToId *int `json:"issue_to_id,omitempty"`

				// RelationType The type of the relation.
				RelationType *string `json:"relation_type,omitempty"`
			} `json:"relations,omitempty"`

			// SpentHours The spent hours of the issue.
			SpentHours *float32 `json:"spent_hours,omitempty"`

			// StartDate The start date of the issue.
			StartDate *openapi_types.Date `json:"start_date,omitempty"`
			Status    *struct {
				// Id The ID of the status.
				Id *int `json:"id,omitempty"`

				// IsClosed The closed of the status.
				IsClosed *bool `json:"is_closed,omitempty"`

				// Name The name of the status.
				Name *string `json:"name,omitempty"`
			} `json:"status,omitempty"`

			// Subject The subject of the issue.
			Subject *string `json:"subject,omitempty"`

			// TotalEstimatedHours The total estimated hours of the issue.
			TotalEstimatedHours *float32 `json:"total_estimated_hours,omitempty"`

			// TotalSpentHours The total spent hours of the issue.
			TotalSpentHours *float32 `json:"total_spent_hours,omitempty"`
			Tracker         *struct {
				// Id The ID of the tracker.
				Id *int `json:"id,omitempty"`

				// Name The name of the tracker.
				Name *string `json:"name,omitempty"`
			} `json:"tracker,omitempty"`

			// UpdatedOn The date and time when the issue was updated.
			UpdatedOn *time.Time `json:"updated_on,omitempty"`
			Watchers  *[]struct {
				// Id The ID of the watcher.
				Id *int `json:"id,omitempty"`

				// Name The name of the watcher.
				Name *string `json:"name,omitempty"`
			} `json:"watchers,omitempty"`
		} `json:"issue,omitempty"`
	}
}
type IssuesShow_200_Issue_Attachments_Item struct {
	Author *struct {
		// Id The ID of the author.
		Id *int `json:"id,omitempty"`

		// Name The name of the author.
		Name *string `json:"name,omitempty"`
	} `json:"author,omitempty"`

	// ContentType The content type of the attachment.
	ContentType *string `json:"content_type,omitempty"`

	// ContentUrl The content URL of the attachment.
	ContentUrl *string `json:"content_url,omitempty"`

	// CreatedOn The date and time when the attachment was created.
	CreatedOn *time.Time `json:"created_on,omitempty"`

	// Description The description of the attachment.
	Description *string `json:"description,omitempty"`

	// Filename The filename of the attachment.
	Filename *string `json:"filename,omitempty"`

	// Filesize The filesize of the attachment.
	Filesize *int `json:"filesize,omitempty"`

	// Id The ID of the attachment.
	Id *int `json:"id,omitempty"`

	// ThumbnailUrl The thumbnail URL of the attachment.
	ThumbnailUrl         *string                `json:"thumbnail_url,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Status returns HTTPResponse.Status
func (r IssuesShowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssuesShowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssuesUpdatePatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *struct {
		Errors *[]string `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r IssuesUpdatePatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssuesUpdatePatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssuesUpdatePutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *struct {
		Errors *[]string `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r IssuesUpdatePutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssuesUpdatePutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssuesShowPdfResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r IssuesShowPdfResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssuesShowPdfResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssueRelationsIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Relations *[]struct {
			// Delay The delay of the relation.
			Delay *int `json:"delay,omitempty"`

			// Id The ID of the relation.
			Id *int `json:"id,omitempty"`

			// IssueId The ID of the issue.
			IssueId *int `json:"issue_id,omitempty"`

			// IssueToId The ID of the issue to.
			IssueToId *int `json:"issue_to_id,omitempty"`

			// RelationType The relation type of the relation.
			RelationType *string `json:"relation_type,omitempty"`
		} `json:"relations,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r IssueRelationsIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssueRelationsIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssueRelationsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Relation Represents a single issue relation.
		Relation *struct {
			// Delay The delay of the relation.
			Delay *int `json:"delay,omitempty"`

			// Id The ID of the relation.
			Id *int `json:"id,omitempty"`

			// IssueId The ID of the issue.
			IssueId *int `json:"issue_id,omitempty"`

			// IssueToId The ID of the issue to.
			IssueToId *int `json:"issue_to_id,omitempty"`

			// RelationType The relation type of the relation.
			RelationType *string `json:"relation_type,omitempty"`
		} `json:"relation,omitempty"`
	}
	JSON422 *struct {
		Errors *[]string `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r IssueRelationsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssueRelationsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TimelogCreateIssueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// TimeEntry A single time entry.
		TimeEntry *struct {
			Activity *struct {
				// Id The ID of the activity.
				Id *int `json:"id,omitempty"`

				// Name The name of the activity.
				Name *string `json:"name,omitempty"`
			} `json:"activity,omitempty"`

			// Comments The comments of the time entry.
			Comments *string `json:"comments,omitempty"`

			// CreatedOn The date and time when the time entry was created.
			CreatedOn    *time.Time `json:"created_on,omitempty"`
			CustomFields *[]struct {
				// Id The ID of the custom field.
				Id *int `json:"id,omitempty"`

				// Multiple Whether the custom field can have multiple values.
				Multiple *bool `json:"multiple,omitempty"`

				// Name The name of the custom field.
				Name  *string      `json:"name,omitempty"`
				Value *interface{} `json:"value,omitempty"`
			} `json:"custom_fields,omitempty"`

			// Hours The hours of the time entry.
			Hours *float32 `json:"hours,omitempty"`

			// Id The ID of the time entry.
			Id    *int `json:"id,omitempty"`
			Issue *struct {
				// Id The ID of the issue.
				Id *int `json:"id,omitempty"`
			} `json:"issue,omitempty"`
			Project *struct {
				// Id The ID of the project.
				Id *int `json:"id,omitempty"`

				// Name The name of the project.
				Name *string `json:"name,omitempty"`
			} `json:"project,omitempty"`

			// SpentOn The date when the time entry was spent.
			SpentOn *openapi_types.Date `json:"spent_on,omitempty"`

			// UpdatedOn The date and time when the time entry was last updated.
			UpdatedOn *time.Time `json:"updated_on,omitempty"`
			User      *struct {
				// Id The ID of the user.
				Id *int `json:"id,omitempty"`

				// Name The name of the user.
				Name *string `json:"name,omitempty"`
			} `json:"user,omitempty"`
		} `json:"time_entry,omitempty"`
	}
	JSON422 *struct {
		Errors *[]string `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TimelogCreateIssueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TimelogCreateIssueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WatchersCreateIssueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r WatchersCreateIssueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WatchersCreateIssueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WatchersDestroyIssueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r WatchersDestroyIssueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WatchersDestroyIssueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type JournalsUpdatePatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *struct {
		Errors *[]string `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r JournalsUpdatePatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r JournalsUpdatePatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type JournalsUpdatePutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *struct {
		Errors *[]string `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r JournalsUpdatePutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r JournalsUpdatePutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MembersDestroyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *struct {
		Errors *[]string `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r MembersDestroyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MembersDestroyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MembersShowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Membership A single membership.
		Membership *struct {
			Group *struct {
				// Id The ID of the group.
				Id *int `json:"id,omitempty"`

				// Name The name of the group.
				Name *string `json:"name,omitempty"`
			} `json:"group,omitempty"`

			// Id The ID of the membership.
			Id      *int `json:"id,omitempty"`
			Project *struct {
				// Id The ID of the project.
				Id *int `json:"id,omitempty"`

				// Name The name of the project.
				Name *string `json:"name,omitempty"`
			} `json:"project,omitempty"`
			Roles *[]struct {
				// Id The ID of the role.
				Id *int `json:"id,omitempty"`

				// Inherited Whether the role is inherited from a parent project.
				Inherited *bool `json:"inherited,omitempty"`

				// Name The name of the role.
				Name *string `json:"name,omitempty"`
			} `json:"roles,omitempty"`
			User *struct {
				// Id The ID of the user.
				Id *int `json:"id,omitempty"`

				// Name The name of the user.
				Name *string `json:"name,omitempty"`
			} `json:"user,omitempty"`
		} `json:"membership,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r MembersShowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MembersShowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MembersUpdatePatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *struct {
		Errors *[]string `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r MembersUpdatePatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MembersUpdatePatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MembersUpdatePutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *struct {
		Errors *[]string `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r MembersUpdatePutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MembersUpdatePutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MyAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// User Represents a single user.
		User *struct {
			// Admin Whether the user has administrative privileges.
			Admin *bool `json:"admin,omitempty"`

			// ApiKey The API key for the user.
			ApiKey *string `json:"api_key,omitempty"`

			// CreatedOn The date and time when the user account was created.
			CreatedOn    *time.Time `json:"created_on,omitempty"`
			CustomFields *[]struct {
				// Id The ID of the custom field.
				Id *int `json:"id,omitempty"`

				// Multiple Whether the custom field can have multiple values.
				Multiple *bool `json:"multiple,omitempty"`

				// Name The name of the custom field.
				Name  *string      `json:"name,omitempty"`
				Value *interface{} `json:"value,omitempty"`
			} `json:"custom_fields,omitempty"`

			// Firstname The first name of the user.
			Firstname *string `json:"firstname,omitempty"`

			// Id The unique identifier of the user.
			Id *int `json:"id,omitempty"`

			// LastLoginOn The date and time when the user last logged in.
			LastLoginOn *time.Time `json:"last_login_on,omitempty"`

			// Lastname The last name of the user.
			Lastname *string `json:"lastname,omitempty"`

			// Login The login name of the user.
			Login *string `json:"login,omitempty"`

			// Mail The email address of the user.
			Mail *string `json:"mail,omitempty"`
		} `json:"user,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r MyAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MyAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MyAccountPutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *struct {
		Errors *[]string `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r MyAccountPutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MyAccountPutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NewsIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Limit The maximum number of news returned in the list.
		Limit *int `json:"limit,omitempty"`
		News  *[]struct {
			Author *struct {
				// Id The ID of the author.
				Id *int `json:"id,omitempty"`

				// Name The name of the author.
				Name *string `json:"name,omitempty"`
			} `json:"author,omitempty"`

			// CreatedOn The date and time when the news was created.
			CreatedOn *time.Time `json:"created_on,omitempty"`

			// Description The description of the news.
			Description *string `json:"description,omitempty"`

			// Id The ID of the news.
			Id      *int `json:"id,omitempty"`
			Project *struct {
				// Id The ID of the project.
				Id *int `json:"id,omitempty"`

				// Name The name of the project.
				Name *string `json:"name,omitempty"`
			} `json:"project,omitempty"`

			// Summary The summary of the news.
			Summary *string `json:"summary,omitempty"`

			// Title The title of the news.
			Title *string `json:"title,omitempty"`
		} `json:"news,omitempty"`

		// Offset The offset of the first news in the list.
		Offset *int `json:"offset,omitempty"`

		// TotalCount The total number of news.
		TotalCount *int `json:"total_count,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r NewsIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NewsIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NewsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *struct {
		Errors *[]string `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r NewsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NewsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NewsDestroyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NewsDestroyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NewsDestroyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NewsShowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// News A single news.
		News *struct {
			Attachments *[]NewsShow_200_News_Attachments_Item `json:"attachments,omitempty"`
			Author      *struct {
				// Id The ID of the author.
				Id *int `json:"id,omitempty"`

				// Name The name of the author.
				Name *string `json:"name,omitempty"`
			} `json:"author,omitempty"`
			Comments *[]struct {
				Author *struct {
					// Id The ID of the author.
					Id *int `json:"id,omitempty"`

					// Name The name of the author.
					Name *string `json:"name,omitempty"`
				} `json:"author,omitempty"`
				Content *string `json:"content,omitempty"`

				// Id The ID of the comment.
				Id *int `json:"id,omitempty"`
			} `json:"comments,omitempty"`

			// CreatedOn The date and time when the news was created.
			CreatedOn *time.Time `json:"created_on,omitempty"`

			// Description The description of the news.
			Description *string `json:"description,omitempty"`

			// Id The ID of the news.
			Id      *int `json:"id,omitempty"`
			Project *struct {
				// Id The ID of the project.
				Id *int `json:"id,omitempty"`

				// Name The name of the project.
				Name *string `json:"name,omitempty"`
			} `json:"project,omitempty"`

			// Summary The summary of the news.
			Summary *string `json:"summary,omitempty"`

			// Title The title of the news.
			Title *string `json:"title,omitempty"`
		} `json:"news,omitempty"`
	}
}
type NewsShow_200_News_Attachments_Item struct {
	Author *struct {
		// Id The ID of the author.
		Id *int `json:"id,omitempty"`

		// Name The name of the author.
		Name *string `json:"name,omitempty"`
	} `json:"author,omitempty"`

	// ContentType The content type of the attachment.
	ContentType *string `json:"content_type,omitempty"`

	// ContentUrl The content URL of the attachment.
	ContentUrl *string `json:"content_url,omitempty"`

	// CreatedOn The date and time when the attachment was created.
	CreatedOn *time.Time `json:"created_on,omitempty"`

	// Description The description of the attachment.
	Description *string `json:"description,omitempty"`

	// Filename The filename of the attachment.
	Filename *string `json:"filename,omitempty"`

	// Filesize The filesize of the attachment.
	Filesize *int `json:"filesize,omitempty"`

	// Id The ID of the attachment.
	Id *int `json:"id,omitempty"`

	// ThumbnailUrl The thumbnail URL of the attachment.
	ThumbnailUrl         *string                `json:"thumbnail_url,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Status returns HTTPResponse.Status
func (r NewsShowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NewsShowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NewsUpdatePatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *struct {
		Errors *[]string `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r NewsUpdatePatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NewsUpdatePatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NewsUpdatePutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *struct {
		Errors *[]string `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r NewsUpdatePutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NewsUpdatePutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectsIndexCsvResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ProjectsIndexCsvResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectsIndexCsvResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectsIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Limit The maximum number of projects returned in the list.
		Limit *int `json:"limit,omitempty"`

		// Offset The offset of the first project in the list.
		Offset   *int `json:"offset,omitempty"`
		Projects *[]struct {
			// CreatedOn The date and time when the project was created.
			CreatedOn    *time.Time `json:"created_on,omitempty"`
			CustomFields *[]struct {
				// Id The ID of the custom field.
				Id *int `json:"id,omitempty"`

				// Multiple Whether the custom field can have multiple values.
				Multiple *bool `json:"multiple,omitempty"`

				// Name The name of the custom field.
				Name  *string      `json:"name,omitempty"`
				Value *interface{} `json:"value,omitempty"`
			} `json:"custom_fields,omitempty"`

			// Description The description of the project.
			Description    *string `json:"description,omitempty"`
			EnabledModules *[]struct {
				// Id The ID of the enabled module.
				Id *int `json:"id,omitempty"`

				// Name The name of the enabled module.
				Name *string `json:"name,omitempty"`
			} `json:"enabled_modules,omitempty"`

			// Homepage The homepage URL of the project.
			Homepage *string `json:"homepage,omitempty"`

			// Id The ID of the project.
			Id *int `json:"id,omitempty"`

			// Identifier The identifier of the project.
			Identifier *string `json:"identifier,omitempty"`

			// InheritMembers Whether the project inherits members from its parent project. `true` if it does, `false` if it does not.
			InheritMembers *bool `json:"inherit_members,omitempty"`

			// IsPublic The visibility of the project. `true` if the project is public, `false` if it is private.
			IsPublic        *bool `json:"is_public,omitempty"`
			IssueCategories *[]struct {
				// Id The ID of the issue category.
				Id *int `json:"id,omitempty"`

				// Name The name of the issue category.
				Name *string `json:"name,omitempty"`
			} `json:"issue_categories,omitempty"`
			IssueCustomFields *[]struct {
				// Id The ID of the issue custom field.
				Id *int `json:"id,omitempty"`

				// Name The name of the issue custom field.
				Name *string `json:"name,omitempty"`
			} `json:"issue_custom_fields,omitempty"`

			// Name The name of the project.
			Name *string `json:"name,omitempty"`

			// Parent The parent project of the project. If the project has no parent, this will be `null`.
			Parent *struct {
				// Id The ID of the parent project.
				Id *int `json:"id,omitempty"`

				// Name The name of the parent project.
				Name *string `json:"name,omitempty"`
			} `json:"parent,omitempty"`

			// Status The status of the project. Possible values are:
			// - `1`: active
			// - `5`: closed
			// - `9`: archived
			// - `10`: scheduled for deletion
			Status              *int `json:"status,omitempty"`
			TimeEntryActivities *[]struct {
				// Id The ID of the time entry activity.
				Id *int `json:"id,omitempty"`

				// Name The name of the time entry activity.
				Name *string `json:"name,omitempty"`
			} `json:"time_entry_activities,omitempty"`
			Trackers *[]struct {
				// Id The ID of the tracker.
				Id *int `json:"id,omitempty"`

				// Name The name of the tracker.
				Name *string `json:"name,omitempty"`
			} `json:"trackers,omitempty"`

			// UpdatedOn The date and time when the project was last updated.
			UpdatedOn *time.Time `json:"updated_on,omitempty"`
		} `json:"projects,omitempty"`

		// TotalCount The total number of projects.
		TotalCount *int `json:"total_count,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ProjectsIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectsIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Project A single project.
		Project *struct {
			// CreatedOn The date and time when the project was created.
			CreatedOn    *time.Time `json:"created_on,omitempty"`
			CustomFields *[]struct {
				// Id The ID of the custom field.
				Id *int `json:"id,omitempty"`

				// Multiple Whether the custom field can have multiple values.
				Multiple *bool `json:"multiple,omitempty"`

				// Name The name of the custom field.
				Name  *string      `json:"name,omitempty"`
				Value *interface{} `json:"value,omitempty"`
			} `json:"custom_fields,omitempty"`

			// DefaultAssignee The default assignee of the project. If the project has no default assignee, this will be `null`.
			DefaultAssignee *struct {
				// Id The ID of the default assignee.
				Id *int `json:"id,omitempty"`

				// Name The name of the default assignee.
				Name *string `json:"name,omitempty"`
			} `json:"default_assignee,omitempty"`

			// DefaultVersion The default version of the project. If the project has no default version, this will be `null`.
			DefaultVersion *struct {
				// Id The ID of the default version.
				Id *int `json:"id,omitempty"`

				// Name The name of the default version.
				Name *string `json:"name,omitempty"`
			} `json:"default_version,omitempty"`

			// Description The description of the project.
			Description    *string `json:"description,omitempty"`
			EnabledModules *[]struct {
				// Id The ID of the enabled module.
				Id *int `json:"id,omitempty"`

				// Name The name of the enabled module.
				Name *string `json:"name,omitempty"`
			} `json:"enabled_modules,omitempty"`

			// Homepage The homepage URL of the project.
			Homepage *string `json:"homepage,omitempty"`

			// Id The ID of the project.
			Id *int `json:"id,omitempty"`

			// Identifier The identifier of the project.
			Identifier *string `json:"identifier,omitempty"`

			// InheritMembers Whether the project inherits members from its parent project. `true` if it does, `false` if it does not.
			InheritMembers *bool `json:"inherit_members,omitempty"`

			// IsPublic The visibility of the project. `true` if the project is public, `false` if it is private.
			IsPublic        *bool `json:"is_public,omitempty"`
			IssueCategories *[]struct {
				// Id The ID of the issue category.
				Id *int `json:"id,omitempty"`

				// Name The name of the issue category.
				Name *string `json:"name,omitempty"`
			} `json:"issue_categories,omitempty"`
			IssueCustomFields *[]struct {
				// Id The ID of the issue custom field.
				Id *int `json:"id,omitempty"`

				// Name The name of the issue custom field.
				Name *string `json:"name,omitempty"`
			} `json:"issue_custom_fields,omitempty"`

			// Name The name of the project.
			Name *string `json:"name,omitempty"`

			// Parent The parent project of the project. If the project has no parent, this will be `null`.
			Parent *struct {
				// Id The ID of the parent project.
				Id *int `json:"id,omitempty"`

				// Name The name of the parent project.
				Name *string `json:"name,omitempty"`
			} `json:"parent,omitempty"`

			// Status The status of the project. Possible values are:
			// - `1`: active
			// - `5`: closed
			// - `9`: archived
			// - `10`: scheduled for deletion
			Status              *int `json:"status,omitempty"`
			TimeEntryActivities *[]struct {
				// Id The ID of the time entry activity.
				Id *int `json:"id,omitempty"`

				// Name The name of the time entry activity.
				Name *string `json:"name,omitempty"`
			} `json:"time_entry_activities,omitempty"`
			Trackers *[]struct {
				// Id The ID of the tracker.
				Id *int `json:"id,omitempty"`

				// Name The name of the tracker.
				Name *string `json:"name,omitempty"`
			} `json:"trackers,omitempty"`

			// UpdatedOn The date and time when the project was last updated.
			UpdatedOn *time.Time `json:"updated_on,omitempty"`
		} `json:"project,omitempty"`
	}
	JSON422 *struct {
		Errors *[]string `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ProjectsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectsDestroyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ProjectsDestroyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectsDestroyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectsShowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Project A single project.
		Project *struct {
			// CreatedOn The date and time when the project was created.
			CreatedOn    *time.Time `json:"created_on,omitempty"`
			CustomFields *[]struct {
				// Id The ID of the custom field.
				Id *int `json:"id,omitempty"`

				// Multiple Whether the custom field can have multiple values.
				Multiple *bool `json:"multiple,omitempty"`

				// Name The name of the custom field.
				Name  *string      `json:"name,omitempty"`
				Value *interface{} `json:"value,omitempty"`
			} `json:"custom_fields,omitempty"`

			// DefaultAssignee The default assignee of the project. If the project has no default assignee, this will be `null`.
			DefaultAssignee *struct {
				// Id The ID of the default assignee.
				Id *int `json:"id,omitempty"`

				// Name The name of the default assignee.
				Name *string `json:"name,omitempty"`
			} `json:"default_assignee,omitempty"`

			// DefaultVersion The default version of the project. If the project has no default version, this will be `null`.
			DefaultVersion *struct {
				// Id The ID of the default version.
				Id *int `json:"id,omitempty"`

				// Name The name of the default version.
				Name *string `json:"name,omitempty"`
			} `json:"default_version,omitempty"`

			// Description The description of the project.
			Description    *string `json:"description,omitempty"`
			EnabledModules *[]struct {
				// Id The ID of the enabled module.
				Id *int `json:"id,omitempty"`

				// Name The name of the enabled module.
				Name *string `json:"name,omitempty"`
			} `json:"enabled_modules,omitempty"`

			// Homepage The homepage URL of the project.
			Homepage *string `json:"homepage,omitempty"`

			// Id The ID of the project.
			Id *int `json:"id,omitempty"`

			// Identifier The identifier of the project.
			Identifier *string `json:"identifier,omitempty"`

			// InheritMembers Whether the project inherits members from its parent project. `true` if it does, `false` if it does not.
			InheritMembers *bool `json:"inherit_members,omitempty"`

			// IsPublic The visibility of the project. `true` if the project is public, `false` if it is private.
			IsPublic        *bool `json:"is_public,omitempty"`
			IssueCategories *[]struct {
				// Id The ID of the issue category.
				Id *int `json:"id,omitempty"`

				// Name The name of the issue category.
				Name *string `json:"name,omitempty"`
			} `json:"issue_categories,omitempty"`
			IssueCustomFields *[]struct {
				// Id The ID of the issue custom field.
				Id *int `json:"id,omitempty"`

				// Name The name of the issue custom field.
				Name *string `json:"name,omitempty"`
			} `json:"issue_custom_fields,omitempty"`

			// Name The name of the project.
			Name *string `json:"name,omitempty"`

			// Parent The parent project of the project. If the project has no parent, this will be `null`.
			Parent *struct {
				// Id The ID of the parent project.
				Id *int `json:"id,omitempty"`

				// Name The name of the parent project.
				Name *string `json:"name,omitempty"`
			} `json:"parent,omitempty"`

			// Status The status of the project. Possible values are:
			// - `1`: active
			// - `5`: closed
			// - `9`: archived
			// - `10`: scheduled for deletion
			Status              *int `json:"status,omitempty"`
			TimeEntryActivities *[]struct {
				// Id The ID of the time entry activity.
				Id *int `json:"id,omitempty"`

				// Name The name of the time entry activity.
				Name *string `json:"name,omitempty"`
			} `json:"time_entry_activities,omitempty"`
			Trackers *[]struct {
				// Id The ID of the tracker.
				Id *int `json:"id,omitempty"`

				// Name The name of the tracker.
				Name *string `json:"name,omitempty"`
			} `json:"trackers,omitempty"`

			// UpdatedOn The date and time when the project was last updated.
			UpdatedOn *time.Time `json:"updated_on,omitempty"`
		} `json:"project,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ProjectsShowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectsShowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectsUpdatePatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *struct {
		Errors *[]string `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ProjectsUpdatePatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectsUpdatePatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectsUpdatePutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *struct {
		Errors *[]string `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ProjectsUpdatePutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectsUpdatePutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectsArchivePostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *struct {
		Errors *[]string `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ProjectsArchivePostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectsArchivePostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectsArchivePutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *struct {
		Errors *[]string `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ProjectsArchivePutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectsArchivePutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RepositoriesAddRelatedIssueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *struct {
		Errors *[]string `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r RepositoriesAddRelatedIssueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RepositoriesAddRelatedIssueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RepositoriesRemoveRelatedIssueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RepositoriesRemoveRelatedIssueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RepositoriesRemoveRelatedIssueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectsUnarchivePostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ProjectsUnarchivePostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectsUnarchivePostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectsUnarchivePutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ProjectsUnarchivePutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectsUnarchivePutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FilesIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Files *[]FilesIndex_200_Files_Item `json:"files,omitempty"`
	}
}
type FilesIndex_200_Files_Item struct {
	Author *struct {
		// Id The ID of the author.
		Id *int `json:"id,omitempty"`

		// Name The name of the author.
		Name *string `json:"name,omitempty"`
	} `json:"author,omitempty"`

	// ContentType The content type of the attachment.
	ContentType *string `json:"content_type,omitempty"`

	// ContentUrl The content URL of the attachment.
	ContentUrl *string `json:"content_url,omitempty"`

	// CreatedOn The date and time when the attachment was created.
	CreatedOn *time.Time `json:"created_on,omitempty"`

	// Description The description of the attachment.
	Description *string `json:"description,omitempty"`

	// Digest The digest of the file.
	Digest *string `json:"digest,omitempty"`

	// Downloads The downloads of the file.
	Downloads *int `json:"downloads,omitempty"`

	// Filename The filename of the attachment.
	Filename *string `json:"filename,omitempty"`

	// Filesize The filesize of the attachment.
	Filesize *int `json:"filesize,omitempty"`

	// Id The ID of the attachment.
	Id *int `json:"id,omitempty"`

	// ThumbnailUrl The thumbnail URL of the attachment.
	ThumbnailUrl *string `json:"thumbnail_url,omitempty"`
	Version      *struct {
		// Id The ID of the version.
		Id *int `json:"id,omitempty"`

		// Name The name of the version.
		Name *string `json:"name,omitempty"`
	} `json:"version,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Status returns HTTPResponse.Status
func (r FilesIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FilesIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FilesCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r FilesCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FilesCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssueCategoriesIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IssueCategories *[]struct {
			AssignedTo *struct {
				// Id The ID of the assigned to.
				Id *int `json:"id,omitempty"`

				// Name The name of the assigned to.
				Name *string `json:"name,omitempty"`
			} `json:"assigned_to,omitempty"`

			// Id The ID of the issue category.
			Id *int `json:"id,omitempty"`

			// Name The name of the issue category.
			Name    *string `json:"name,omitempty"`
			Project *struct {
				// Id The ID of the project.
				Id *int `json:"id,omitempty"`

				// Name The name of the project.
				Name *string `json:"name,omitempty"`
			} `json:"project,omitempty"`
		} `json:"issue_categories,omitempty"`

		// TotalCount The total number of issue categories.
		TotalCount *int `json:"total_count,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r IssueCategoriesIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssueCategoriesIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssueCategoriesCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// IssueCategory A single issue category.
		IssueCategory *struct {
			AssignedTo *struct {
				// Id The ID of the assigned to.
				Id *int `json:"id,omitempty"`

				// Name The name of the assigned to.
				Name *string `json:"name,omitempty"`
			} `json:"assigned_to,omitempty"`

			// Id The ID of the issue category.
			Id *int `json:"id,omitempty"`

			// Name The name of the issue category.
			Name    *string `json:"name,omitempty"`
			Project *struct {
				// Id The ID of the project.
				Id *int `json:"id,omitempty"`

				// Name The name of the project.
				Name *string `json:"name,omitempty"`
			} `json:"project,omitempty"`
		} `json:"issue_category,omitempty"`
	}
	JSON422 *struct {
		Errors *[]string `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r IssueCategoriesCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssueCategoriesCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssuesIndexProjectCsvResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *struct {
		Errors *[]string `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r IssuesIndexProjectCsvResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssuesIndexProjectCsvResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssuesIndexProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Issues *[]struct {
			AssignedTo *struct {
				// Id The ID of the assigned member.
				Id *int `json:"id,omitempty"`

				// Name The name of the assigned member.
				Name *string `json:"name,omitempty"`
			} `json:"assigned_to,omitempty"`
			Attachments *[]IssuesIndexProject_200_Issues_Attachments_Item `json:"attachments,omitempty"`
			Author      *struct {
				// Id The ID of the author.
				Id *int `json:"id,omitempty"`

				// Name The name of the author.
				Name *string `json:"name,omitempty"`
			} `json:"author,omitempty"`
			Category *struct {
				// Id The ID of the category.
				Id *int `json:"id,omitempty"`

				// Name The name of the category.
				Name *string `json:"name,omitempty"`
			} `json:"category,omitempty"`

			// ClosedOn The date and time when the issue was closed.
			ClosedOn *time.Time `json:"closed_on,omitempty"`

			// CreatedOn The date and time when the issue was created.
			CreatedOn    *time.Time `json:"created_on,omitempty"`
			CustomFields *[]struct {
				// Id The ID of the custom field.
				Id *int `json:"id,omitempty"`

				// Multiple Whether the custom field can have multiple values.
				Multiple *bool `json:"multiple,omitempty"`

				// Name The name of the custom field.
				Name  *string      `json:"name,omitempty"`
				Value *interface{} `json:"value,omitempty"`
			} `json:"custom_fields,omitempty"`

			// Description The description of the issue.
			Description *string `json:"description,omitempty"`

			// DoneRatio The done ratio of the issue.
			DoneRatio *int `json:"done_ratio,omitempty"`

			// DueDate The due date of the issue.
			DueDate *openapi_types.Date `json:"due_date,omitempty"`

			// EstimatedHours The estimated hours of the issue.
			EstimatedHours *float32 `json:"estimated_hours,omitempty"`
			FixedVersion   *struct {
				// Id The ID of the fixed version.
				Id *int `json:"id,omitempty"`

				// Name The name of the fixed version.
				Name *string `json:"name,omitempty"`
			} `json:"fixed_version,omitempty"`

			// Id The ID of the issue.
			Id *int `json:"id,omitempty"`

			// IsPrivate The private of the issue.
			IsPrivate *bool `json:"is_private,omitempty"`
			Parent    *struct {
				// Id The ID of the parent issue.
				Id *int `json:"id,omitempty"`
			} `json:"parent,omitempty"`
			Priority *struct {
				// Id The ID of the priority.
				Id *int `json:"id,omitempty"`

				// Name The name of the priority.
				Name *string `json:"name,omitempty"`
			} `json:"priority,omitempty"`
			Project *struct {
				// Id The ID of the project.
				Id *int `json:"id,omitempty"`

				// Name The name of the project.
				Name *string `json:"name,omitempty"`
			} `json:"project,omitempty"`
			Relations *[]struct {
				// Delay The delay of the relation.
				Delay *int `json:"delay,omitempty"`

				// Id The ID of the relation.
				Id *int `json:"id,omitempty"`

				// IssueId The ID of the issue.
				IssueId *int `json:"issue_id,omitempty"`

				// IssueToId The ID of the issue.
				IssueToId *int `json:"issue_to_id,omitempty"`

				// RelationType The type of the relation.
				RelationType *string `json:"relation_type,omitempty"`
			} `json:"relations,omitempty"`

			// SpentHours The spent hours of the issue.
			SpentHours *float32 `json:"spent_hours,omitempty"`

			// StartDate The start date of the issue.
			StartDate *openapi_types.Date `json:"start_date,omitempty"`
			Status    *struct {
				// Id The ID of the status.
				Id *int `json:"id,omitempty"`

				// IsClosed The closed of the status.
				IsClosed *bool `json:"is_closed,omitempty"`

				// Name The name of the status.
				Name *string `json:"name,omitempty"`
			} `json:"status,omitempty"`

			// Subject The subject of the issue.
			Subject *string `json:"subject,omitempty"`

			// TotalEstimatedHours The total estimated hours of the issue.
			TotalEstimatedHours *float32 `json:"total_estimated_hours,omitempty"`

			// TotalSpentHours The total spent hours of the issue.
			TotalSpentHours *float32 `json:"total_spent_hours,omitempty"`
			Tracker         *struct {
				// Id The ID of the tracker.
				Id *int `json:"id,omitempty"`

				// Name The name of the tracker.
				Name *string `json:"name,omitempty"`
			} `json:"tracker,omitempty"`

			// UpdatedOn The date and time when the issue was updated.
			UpdatedOn *time.Time `json:"updated_on,omitempty"`
		} `json:"issues,omitempty"`

		// Limit The maximum number of issues returned in the list.
		Limit *int `json:"limit,omitempty"`

		// Offset The offset of the first issue in the list.
		Offset *int `json:"offset,omitempty"`

		// TotalCount The total number of issues.
		TotalCount *int `json:"total_count,omitempty"`
	}
	JSON422 *struct {
		Errors *[]string `json:"errors,omitempty"`
	}
}
type IssuesIndexProject_200_Issues_Attachments_Item struct {
	Author *struct {
		// Id The ID of the author.
		Id *int `json:"id,omitempty"`

		// Name The name of the author.
		Name *string `json:"name,omitempty"`
	} `json:"author,omitempty"`

	// ContentType The content type of the attachment.
	ContentType *string `json:"content_type,omitempty"`

	// ContentUrl The content URL of the attachment.
	ContentUrl *string `json:"content_url,omitempty"`

	// CreatedOn The date and time when the attachment was created.
	CreatedOn *time.Time `json:"created_on,omitempty"`

	// Description The description of the attachment.
	Description *string `json:"description,omitempty"`

	// Filename The filename of the attachment.
	Filename *string `json:"filename,omitempty"`

	// Filesize The filesize of the attachment.
	Filesize *int `json:"filesize,omitempty"`

	// Id The ID of the attachment.
	Id *int `json:"id,omitempty"`

	// ThumbnailUrl The thumbnail URL of the attachment.
	ThumbnailUrl         *string                `json:"thumbnail_url,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Status returns HTTPResponse.Status
func (r IssuesIndexProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssuesIndexProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssuesCreateProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Issue A single issue.
		Issue *struct {
			AllowedStatuses *[]struct {
				// Id The ID of the allowed statuse.
				Id *int `json:"id,omitempty"`

				// IsClosed The closed of the allowed status.
				IsClosed *bool `json:"is_closed,omitempty"`

				// Name The name of the allowed statuse.
				Name *string `json:"name,omitempty"`
			} `json:"allowed_statuses,omitempty"`
			AssignedTo *struct {
				// Id The ID of the assigned member.
				Id *int `json:"id,omitempty"`

				// Name The name of the assigned member.
				Name *string `json:"name,omitempty"`
			} `json:"assigned_to,omitempty"`
			Attachments *[]IssuesCreateProject_201_Issue_Attachments_Item `json:"attachments,omitempty"`
			Author      *struct {
				// Id The ID of the author.
				Id *int `json:"id,omitempty"`

				// Name The name of the author.
				Name *string `json:"name,omitempty"`
			} `json:"author,omitempty"`
			Category *struct {
				// Id The ID of the category.
				Id *int `json:"id,omitempty"`

				// Name The name of the category.
				Name *string `json:"name,omitempty"`
			} `json:"category,omitempty"`
			Changesets *[]struct {
				// Comments The comments of the changeset.
				Comments *string `json:"comments,omitempty"`

				// CommittedOn The date and time when the changeset was committed.
				CommittedOn *time.Time `json:"committed_on,omitempty"`

				// Revision The revision of the changeset.
				Revision *string `json:"revision,omitempty"`
				User     *struct {
					// Id The ID of the user.
					Id *int `json:"id,omitempty"`

					// Name The name of the user.
					Name *string `json:"name,omitempty"`
				} `json:"user,omitempty"`
			} `json:"changesets,omitempty"`
			Children *[]struct {
				Children *[]interface{} `json:"children,omitempty"`

				// Id The ID of the issue.
				Id *int `json:"id,omitempty"`

				// Subject The subject of the issue.
				Subject *string `json:"subject,omitempty"`
				Tracker *struct {
					// Id The ID of the tracker.
					Id *int `json:"id,omitempty"`

					// Name The name of the tracker.
					Name *string `json:"name,omitempty"`
				} `json:"tracker,omitempty"`
			} `json:"children,omitempty"`

			// ClosedOn The date and time when the issue was closed.
			ClosedOn *time.Time `json:"closed_on,omitempty"`

			// CreatedOn The date and time when the issue was created.
			CreatedOn    *time.Time `json:"created_on,omitempty"`
			CustomFields *[]struct {
				// Id The ID of the custom field.
				Id *int `json:"id,omitempty"`

				// Multiple Whether the custom field can have multiple values.
				Multiple *bool `json:"multiple,omitempty"`

				// Name The name of the custom field.
				Name  *string      `json:"name,omitempty"`
				Value *interface{} `json:"value,omitempty"`
			} `json:"custom_fields,omitempty"`

			// Description The description of the issue.
			Description *string `json:"description,omitempty"`

			// DoneRatio The done ratio of the issue.
			DoneRatio *int `json:"done_ratio,omitempty"`

			// DueDate The due date of the issue.
			DueDate *openapi_types.Date `json:"due_date,omitempty"`

			// EstimatedHours The estimated hours of the issue.
			EstimatedHours *float32 `json:"estimated_hours,omitempty"`
			FixedVersion   *struct {
				// Id The ID of the fixed version.
				Id *int `json:"id,omitempty"`

				// Name The name of the fixed version.
				Name *string `json:"name,omitempty"`
			} `json:"fixed_version,omitempty"`

			// Id The ID of the issue.
			Id *int `json:"id,omitempty"`

			// IsPrivate The private of the issue.
			IsPrivate *bool `json:"is_private,omitempty"`
			Journals  *[]struct {
				// CreatedOn The date and time when the journal was created.
				CreatedOn *time.Time `json:"created_on,omitempty"`
				Details   *[]struct {
					// Name The name of the detail.
					Name *string `json:"name,omitempty"`

					// NewValue The new value of the detail.
					NewValue *string `json:"new_value,omitempty"`

					// OldValue The old value of the detail.
					OldValue *string `json:"old_value,omitempty"`

					// Property The property of the detail.
					Property *string `json:"property,omitempty"`
				} `json:"details,omitempty"`

				// Id The ID of the journal.
				Id *int `json:"id,omitempty"`

				// Notes The notes of the journal.
				Notes *string `json:"notes,omitempty"`

				// PrivateNotes The private of the journal.
				PrivateNotes *bool `json:"private_notes,omitempty"`
				UpdatedBy    *struct {
					// Id The ID of the updated.
					Id *int `json:"id,omitempty"`

					// Name The name of the updated.
					Name *string `json:"name,omitempty"`
				} `json:"updated_by,omitempty"`

				// UpdatedOn The date and time when the journal was updated.
				UpdatedOn *time.Time `json:"updated_on,omitempty"`
				User      *struct {
					// Id The ID of the user.
					Id *int `json:"id,omitempty"`

					// Name The name of the user.
					Name *string `json:"name,omitempty"`
				} `json:"user,omitempty"`
			} `json:"journals,omitempty"`
			Parent *struct {
				// Id The ID of the parent issue.
				Id *int `json:"id,omitempty"`
			} `json:"parent,omitempty"`
			Priority *struct {
				// Id The ID of the priority.
				Id *int `json:"id,omitempty"`

				// Name The name of the priority.
				Name *string `json:"name,omitempty"`
			} `json:"priority,omitempty"`
			Project *struct {
				// Id The ID of the project.
				Id *int `json:"id,omitempty"`

				// Name The name of the project.
				Name *string `json:"name,omitempty"`
			} `json:"project,omitempty"`
			Relations *[]struct {
				// Delay The delay of the relation.
				Delay *int `json:"delay,omitempty"`

				// Id The ID of the relation.
				Id *int `json:"id,omitempty"`

				// IssueId The ID of the issue.
				IssueId *int `json:"issue_id,omitempty"`

				// IssueToId The ID of the issue.
				IssueToId *int `json:"issue_to_id,omitempty"`

				// RelationType The type of the relation.
				RelationType *string `json:"relation_type,omitempty"`
			} `json:"relations,omitempty"`

			// SpentHours The spent hours of the issue.
			SpentHours *float32 `json:"spent_hours,omitempty"`

			// StartDate The start date of the issue.
			StartDate *openapi_types.Date `json:"start_date,omitempty"`
			Status    *struct {
				// Id The ID of the status.
				Id *int `json:"id,omitempty"`

				// IsClosed The closed of the status.
				IsClosed *bool `json:"is_closed,omitempty"`

				// Name The name of the status.
				Name *string `json:"name,omitempty"`
			} `json:"status,omitempty"`

			// Subject The subject of the issue.
			Subject *string `json:"subject,omitempty"`

			// TotalEstimatedHours The total estimated hours of the issue.
			TotalEstimatedHours *float32 `json:"total_estimated_hours,omitempty"`

			// TotalSpentHours The total spent hours of the issue.
			TotalSpentHours *float32 `json:"total_spent_hours,omitempty"`
			Tracker         *struct {
				// Id The ID of the tracker.
				Id *int `json:"id,omitempty"`

				// Name The name of the tracker.
				Name *string `json:"name,omitempty"`
			} `json:"tracker,omitempty"`

			// UpdatedOn The date and time when the issue was updated.
			UpdatedOn *time.Time `json:"updated_on,omitempty"`
			Watchers  *[]struct {
				// Id The ID of the watcher.
				Id *int `json:"id,omitempty"`

				// Name The name of the watcher.
				Name *string `json:"name,omitempty"`
			} `json:"watchers,omitempty"`
		} `json:"issue,omitempty"`
	}
	JSON422 *struct {
		Errors *[]string `json:"errors,omitempty"`
	}
}
type IssuesCreateProject_201_Issue_Attachments_Item struct {
	Author *struct {
		// Id The ID of the author.
		Id *int `json:"id,omitempty"`

		// Name The name of the author.
		Name *string `json:"name,omitempty"`
	} `json:"author,omitempty"`

	// ContentType The content type of the attachment.
	ContentType *string `json:"content_type,omitempty"`

	// ContentUrl The content URL of the attachment.
	ContentUrl *string `json:"content_url,omitempty"`

	// CreatedOn The date and time when the attachment was created.
	CreatedOn *time.Time `json:"created_on,omitempty"`

	// Description The description of the attachment.
	Description *string `json:"description,omitempty"`

	// Filename The filename of the attachment.
	Filename *string `json:"filename,omitempty"`

	// Filesize The filesize of the attachment.
	Filesize *int `json:"filesize,omitempty"`

	// Id The ID of the attachment.
	Id *int `json:"id,omitempty"`

	// ThumbnailUrl The thumbnail URL of the attachment.
	ThumbnailUrl         *string                `json:"thumbnail_url,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Status returns HTTPResponse.Status
func (r IssuesCreateProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssuesCreateProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssuesIndexProjectPdfResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *struct {
		Errors *[]string `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r IssuesIndexProjectPdfResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssuesIndexProjectPdfResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GanttsShowProjectPdfResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GanttsShowProjectPdfResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GanttsShowProjectPdfResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GanttsShowProjectPngResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GanttsShowProjectPngResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GanttsShowProjectPngResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MembersIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Limit The maximum number of memberships returned in the list.
		Limit       *int `json:"limit,omitempty"`
		Memberships *[]struct {
			Group *struct {
				// Id The ID of the group.
				Id *int `json:"id,omitempty"`

				// Name The name of the group.
				Name *string `json:"name,omitempty"`
			} `json:"group,omitempty"`

			// Id The ID of the membership.
			Id      *int `json:"id,omitempty"`
			Project *struct {
				// Id The ID of the project.
				Id *int `json:"id,omitempty"`

				// Name The name of the project.
				Name *string `json:"name,omitempty"`
			} `json:"project,omitempty"`
			Roles *[]struct {
				// Id The ID of the role.
				Id *int `json:"id,omitempty"`

				// Inherited Whether the role is inherited from a parent project.
				Inherited *bool `json:"inherited,omitempty"`

				// Name The name of the role.
				Name *string `json:"name,omitempty"`
			} `json:"roles,omitempty"`
			User *struct {
				// Id The ID of the user.
				Id *int `json:"id,omitempty"`

				// Name The name of the user.
				Name *string `json:"name,omitempty"`
			} `json:"user,omitempty"`
		} `json:"memberships,omitempty"`

		// Offset The offset of the first membership in the list.
		Offset *int `json:"offset,omitempty"`

		// TotalCount The total number of memberships.
		TotalCount *int `json:"total_count,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r MembersIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MembersIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MembersCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Membership A single membership.
		Membership *struct {
			Group *struct {
				// Id The ID of the group.
				Id *int `json:"id,omitempty"`

				// Name The name of the group.
				Name *string `json:"name,omitempty"`
			} `json:"group,omitempty"`

			// Id The ID of the membership.
			Id      *int `json:"id,omitempty"`
			Project *struct {
				// Id The ID of the project.
				Id *int `json:"id,omitempty"`

				// Name The name of the project.
				Name *string `json:"name,omitempty"`
			} `json:"project,omitempty"`
			Roles *[]struct {
				// Id The ID of the role.
				Id *int `json:"id,omitempty"`

				// Inherited Whether the role is inherited from a parent project.
				Inherited *bool `json:"inherited,omitempty"`

				// Name The name of the role.
				Name *string `json:"name,omitempty"`
			} `json:"roles,omitempty"`
			User *struct {
				// Id The ID of the user.
				Id *int `json:"id,omitempty"`

				// Name The name of the user.
				Name *string `json:"name,omitempty"`
			} `json:"user,omitempty"`
		} `json:"membership,omitempty"`
	}
	JSON422 *struct {
		Errors *[]string `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r MembersCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MembersCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NewsIndexProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Limit The maximum number of news returned in the list.
		Limit *int `json:"limit,omitempty"`
		News  *[]struct {
			Author *struct {
				// Id The ID of the author.
				Id *int `json:"id,omitempty"`

				// Name The name of the author.
				Name *string `json:"name,omitempty"`
			} `json:"author,omitempty"`

			// CreatedOn The date and time when the news was created.
			CreatedOn *time.Time `json:"created_on,omitempty"`

			// Description The description of the news.
			Description *string `json:"description,omitempty"`

			// Id The ID of the news.
			Id      *int `json:"id,omitempty"`
			Project *struct {
				// Id The ID of the project.
				Id *int `json:"id,omitempty"`

				// Name The name of the project.
				Name *string `json:"name,omitempty"`
			} `json:"project,omitempty"`

			// Summary The summary of the news.
			Summary *string `json:"summary,omitempty"`

			// Title The title of the news.
			Title *string `json:"title,omitempty"`
		} `json:"news,omitempty"`

		// Offset The offset of the first news in the list.
		Offset *int `json:"offset,omitempty"`

		// TotalCount The total number of news.
		TotalCount *int `json:"total_count,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r NewsIndexProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NewsIndexProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NewsCreateProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *struct {
		Errors *[]string `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r NewsCreateProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NewsCreateProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchIndexProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Limit The maximum number of search results returned in the list.
		Limit *int `json:"limit,omitempty"`

		// Offset The offset of the first search result in the list.
		Offset  *int `json:"offset,omitempty"`
		Results *[]struct {
			// Datetime The date and time when the search result was created.
			Datetime *time.Time `json:"datetime,omitempty"`

			// Description The description of the search result.
			Description *string `json:"description,omitempty"`

			// Id The ID of the search result.
			Id *int `json:"id,omitempty"`

			// Title The title of the search result.
			Title *string `json:"title,omitempty"`

			// Type The type of the search result.
			Type *string `json:"type,omitempty"`

			// Url The url of the search result.
			Url *string `json:"url,omitempty"`
		} `json:"results,omitempty"`

		// TotalCount The total number of search results.
		TotalCount *int `json:"total_count,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SearchIndexProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchIndexProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TimelogIndexProjectCsvResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TimelogIndexProjectCsvResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TimelogIndexProjectCsvResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TimelogIndexProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Limit The maximum number of time entries returned in the list.
		Limit *int `json:"limit,omitempty"`

		// Offset The offset of the first time entry in the list.
		Offset      *int `json:"offset,omitempty"`
		TimeEntries *[]struct {
			Activity *struct {
				// Id The ID of the activity.
				Id *int `json:"id,omitempty"`

				// Name The name of the activity.
				Name *string `json:"name,omitempty"`
			} `json:"activity,omitempty"`

			// Comments The comments of the time entry.
			Comments *string `json:"comments,omitempty"`

			// CreatedOn The date and time when the time entry was created.
			CreatedOn    *time.Time `json:"created_on,omitempty"`
			CustomFields *[]struct {
				// Id The ID of the custom field.
				Id *int `json:"id,omitempty"`

				// Multiple Whether the custom field can have multiple values.
				Multiple *bool `json:"multiple,omitempty"`

				// Name The name of the custom field.
				Name  *string      `json:"name,omitempty"`
				Value *interface{} `json:"value,omitempty"`
			} `json:"custom_fields,omitempty"`

			// Hours The hours of the time entry.
			Hours *float32 `json:"hours,omitempty"`

			// Id The ID of the time entry.
			Id    *int `json:"id,omitempty"`
			Issue *struct {
				// Id The ID of the issue.
				Id *int `json:"id,omitempty"`
			} `json:"issue,omitempty"`
			Project *struct {
				// Id The ID of the project.
				Id *int `json:"id,omitempty"`

				// Name The name of the project.
				Name *string `json:"name,omitempty"`
			} `json:"project,omitempty"`

			// SpentOn The date when the time entry was spent.
			SpentOn *openapi_types.Date `json:"spent_on,omitempty"`

			// UpdatedOn The date and time when the time entry was last updated.
			UpdatedOn *time.Time `json:"updated_on,omitempty"`
			User      *struct {
				// Id The ID of the user.
				Id *int `json:"id,omitempty"`

				// Name The name of the user.
				Name *string `json:"name,omitempty"`
			} `json:"user,omitempty"`
		} `json:"time_entries,omitempty"`

		// TotalCount The total number of time entries.
		TotalCount *int `json:"total_count,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TimelogIndexProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TimelogIndexProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TimelogCreateProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// TimeEntry A single time entry.
		TimeEntry *struct {
			Activity *struct {
				// Id The ID of the activity.
				Id *int `json:"id,omitempty"`

				// Name The name of the activity.
				Name *string `json:"name,omitempty"`
			} `json:"activity,omitempty"`

			// Comments The comments of the time entry.
			Comments *string `json:"comments,omitempty"`

			// CreatedOn The date and time when the time entry was created.
			CreatedOn    *time.Time `json:"created_on,omitempty"`
			CustomFields *[]struct {
				// Id The ID of the custom field.
				Id *int `json:"id,omitempty"`

				// Multiple Whether the custom field can have multiple values.
				Multiple *bool `json:"multiple,omitempty"`

				// Name The name of the custom field.
				Name  *string      `json:"name,omitempty"`
				Value *interface{} `json:"value,omitempty"`
			} `json:"custom_fields,omitempty"`

			// Hours The hours of the time entry.
			Hours *float32 `json:"hours,omitempty"`

			// Id The ID of the time entry.
			Id    *int `json:"id,omitempty"`
			Issue *struct {
				// Id The ID of the issue.
				Id *int `json:"id,omitempty"`
			} `json:"issue,omitempty"`
			Project *struct {
				// Id The ID of the project.
				Id *int `json:"id,omitempty"`

				// Name The name of the project.
				Name *string `json:"name,omitempty"`
			} `json:"project,omitempty"`

			// SpentOn The date when the time entry was spent.
			SpentOn *openapi_types.Date `json:"spent_on,omitempty"`

			// UpdatedOn The date and time when the time entry was last updated.
			UpdatedOn *time.Time `json:"updated_on,omitempty"`
			User      *struct {
				// Id The ID of the user.
				Id *int `json:"id,omitempty"`

				// Name The name of the user.
				Name *string `json:"name,omitempty"`
			} `json:"user,omitempty"`
		} `json:"time_entry,omitempty"`
	}
	JSON422 *struct {
		Errors *[]string `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TimelogCreateProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TimelogCreateProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VersionsIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// TotalCount The total number of versions.
		TotalCount *int `json:"total_count,omitempty"`
		Versions   *[]struct {
			// CreatedOn The date and time when the version was created.
			CreatedOn    *time.Time `json:"created_on,omitempty"`
			CustomFields *[]struct {
				// Id The ID of the custom field.
				Id *int `json:"id,omitempty"`

				// Multiple Whether the custom field can have multiple values.
				Multiple *bool `json:"multiple,omitempty"`

				// Name The name of the custom field.
				Name  *string      `json:"name,omitempty"`
				Value *interface{} `json:"value,omitempty"`
			} `json:"custom_fields,omitempty"`

			// Description The description of the version.
			Description *string `json:"description,omitempty"`

			// DueDate The date when the version was expired.
			DueDate *openapi_types.Date `json:"due_date,omitempty"`

			// Id The ID of the version.
			Id *int `json:"id,omitempty"`

			// Name The name of the version.
			Name    *string `json:"name,omitempty"`
			Project *struct {
				// Id The ID of the project.
				Id *int `json:"id,omitempty"`

				// Name The name of the project.
				Name *string `json:"name,omitempty"`
			} `json:"project,omitempty"`

			// Sharing The sharing of the version.
			Sharing *string `json:"sharing,omitempty"`

			// Status The status of the version.
			Status *string `json:"status,omitempty"`

			// UpdatedOn The date and time when the version was last updated.
			UpdatedOn *time.Time `json:"updated_on,omitempty"`

			// WikiPageTitle The wiki page title of the version.
			WikiPageTitle *string `json:"wiki_page_title,omitempty"`
		} `json:"versions,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r VersionsIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VersionsIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VersionsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Version A single version.
		Version *struct {
			// CreatedOn The date and time when the version was created.
			CreatedOn    *time.Time `json:"created_on,omitempty"`
			CustomFields *[]struct {
				// Id The ID of the custom field.
				Id *int `json:"id,omitempty"`

				// Multiple Whether the custom field can have multiple values.
				Multiple *bool `json:"multiple,omitempty"`

				// Name The name of the custom field.
				Name  *string      `json:"name,omitempty"`
				Value *interface{} `json:"value,omitempty"`
			} `json:"custom_fields,omitempty"`

			// Description The description of the version.
			Description *string `json:"description,omitempty"`

			// DueDate The date when the version was expired.
			DueDate *openapi_types.Date `json:"due_date,omitempty"`

			// EstimatedHours The estimated hours of the version.
			EstimatedHours *float32 `json:"estimated_hours,omitempty"`

			// Id The ID of the version.
			Id *int `json:"id,omitempty"`

			// Name The name of the version.
			Name    *string `json:"name,omitempty"`
			Project *struct {
				// Id The ID of the project.
				Id *int `json:"id,omitempty"`

				// Name The name of the project.
				Name *string `json:"name,omitempty"`
			} `json:"project,omitempty"`

			// Sharing The sharing of the version.
			Sharing *string `json:"sharing,omitempty"`

			// SpentHours The spent hours of the version.
			SpentHours *float32 `json:"spent_hours,omitempty"`

			// Status The status of the version.
			Status *string `json:"status,omitempty"`

			// UpdatedOn The date and time when the version was last updated.
			UpdatedOn *time.Time `json:"updated_on,omitempty"`

			// WikiPageTitle The wiki page title of the version.
			WikiPageTitle *string `json:"wiki_page_title,omitempty"`
		} `json:"version,omitempty"`
	}
	JSON422 *struct {
		Errors *[]string `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r VersionsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VersionsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WikiShowRootResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// WikiPage A single wiki.
		WikiPage *struct {
			Attachments *[]WikiShowRoot_200_WikiPage_Attachments_Item `json:"attachments,omitempty"`
			Author      *struct {
				// Id The ID of the author.
				Id *int `json:"id,omitempty"`

				// Name The name of the author.
				Name *string `json:"name,omitempty"`
			} `json:"author,omitempty"`

			// Comments The comments of the wiki.
			Comments *string `json:"comments,omitempty"`

			// CreatedOn The date and time when the wiki was created.
			CreatedOn *time.Time `json:"created_on,omitempty"`
			Parent    *struct {
				// Title The parent title of the wiki.
				Title *string `json:"title,omitempty"`
			} `json:"parent,omitempty"`

			// Text The text of the wiki.
			Text *string `json:"text,omitempty"`

			// Title The title of the wiki.
			Title *string `json:"title,omitempty"`

			// UpdatedOn The date and time when the wiki was last updated.
			UpdatedOn *time.Time `json:"updated_on,omitempty"`

			// Version The version of the wiki.
			Version *int `json:"version,omitempty"`
		} `json:"wiki_page,omitempty"`
	}
}
type WikiShowRoot_200_WikiPage_Attachments_Item struct {
	Author *struct {
		// Id The ID of the author.
		Id *int `json:"id,omitempty"`

		// Name The name of the author.
		Name *string `json:"name,omitempty"`
	} `json:"author,omitempty"`

	// ContentType The content type of the attachment.
	ContentType *string `json:"content_type,omitempty"`

	// ContentUrl The content URL of the attachment.
	ContentUrl *string `json:"content_url,omitempty"`

	// CreatedOn The date and time when the attachment was created.
	CreatedOn *time.Time `json:"created_on,omitempty"`

	// Description The description of the attachment.
	Description *string `json:"description,omitempty"`

	// Filename The filename of the attachment.
	Filename *string `json:"filename,omitempty"`

	// Filesize The filesize of the attachment.
	Filesize *int `json:"filesize,omitempty"`

	// Id The ID of the attachment.
	Id *int `json:"id,omitempty"`

	// ThumbnailUrl The thumbnail URL of the attachment.
	ThumbnailUrl         *string                `json:"thumbnail_url,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Status returns HTTPResponse.Status
func (r WikiShowRootResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WikiShowRootResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WikiIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		WikiPages *[]struct {
			// CreatedOn The date and time when the wiki was created.
			CreatedOn *time.Time `json:"created_on,omitempty"`
			Parent    *struct {
				// Title The parent title of the wiki.
				Title *string `json:"title,omitempty"`
			} `json:"parent,omitempty"`

			// Title The title of the wiki.
			Title *string `json:"title,omitempty"`

			// UpdatedOn The date and time when the wiki was last updated.
			UpdatedOn *time.Time `json:"updated_on,omitempty"`

			// Version The version of the wiki.
			Version *int `json:"version,omitempty"`
		} `json:"wiki_pages,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r WikiIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WikiIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WikiDestroyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r WikiDestroyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WikiDestroyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WikiShowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// WikiPage A single wiki.
		WikiPage *struct {
			Attachments *[]WikiShow_200_WikiPage_Attachments_Item `json:"attachments,omitempty"`
			Author      *struct {
				// Id The ID of the author.
				Id *int `json:"id,omitempty"`

				// Name The name of the author.
				Name *string `json:"name,omitempty"`
			} `json:"author,omitempty"`

			// Comments The comments of the wiki.
			Comments *string `json:"comments,omitempty"`

			// CreatedOn The date and time when the wiki was created.
			CreatedOn *time.Time `json:"created_on,omitempty"`
			Parent    *struct {
				// Title The parent title of the wiki.
				Title *string `json:"title,omitempty"`
			} `json:"parent,omitempty"`

			// Text The text of the wiki.
			Text *string `json:"text,omitempty"`

			// Title The title of the wiki.
			Title *string `json:"title,omitempty"`

			// UpdatedOn The date and time when the wiki was last updated.
			UpdatedOn *time.Time `json:"updated_on,omitempty"`

			// Version The version of the wiki.
			Version *int `json:"version,omitempty"`
		} `json:"wiki_page,omitempty"`
	}
}
type WikiShow_200_WikiPage_Attachments_Item struct {
	Author *struct {
		// Id The ID of the author.
		Id *int `json:"id,omitempty"`

		// Name The name of the author.
		Name *string `json:"name,omitempty"`
	} `json:"author,omitempty"`

	// ContentType The content type of the attachment.
	ContentType *string `json:"content_type,omitempty"`

	// ContentUrl The content URL of the attachment.
	ContentUrl *string `json:"content_url,omitempty"`

	// CreatedOn The date and time when the attachment was created.
	CreatedOn *time.Time `json:"created_on,omitempty"`

	// Description The description of the attachment.
	Description *string `json:"description,omitempty"`

	// Filename The filename of the attachment.
	Filename *string `json:"filename,omitempty"`

	// Filesize The filesize of the attachment.
	Filesize *int `json:"filesize,omitempty"`

	// Id The ID of the attachment.
	Id *int `json:"id,omitempty"`

	// ThumbnailUrl The thumbnail URL of the attachment.
	ThumbnailUrl         *string                `json:"thumbnail_url,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Status returns HTTPResponse.Status
func (r WikiShowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WikiShowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WikiUpdatePatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// WikiPage A single wiki.
		WikiPage *struct {
			Attachments *[]WikiUpdatePatch_201_WikiPage_Attachments_Item `json:"attachments,omitempty"`
			Author      *struct {
				// Id The ID of the author.
				Id *int `json:"id,omitempty"`

				// Name The name of the author.
				Name *string `json:"name,omitempty"`
			} `json:"author,omitempty"`

			// Comments The comments of the wiki.
			Comments *string `json:"comments,omitempty"`

			// CreatedOn The date and time when the wiki was created.
			CreatedOn *time.Time `json:"created_on,omitempty"`
			Parent    *struct {
				// Title The parent title of the wiki.
				Title *string `json:"title,omitempty"`
			} `json:"parent,omitempty"`

			// Text The text of the wiki.
			Text *string `json:"text,omitempty"`

			// Title The title of the wiki.
			Title *string `json:"title,omitempty"`

			// UpdatedOn The date and time when the wiki was last updated.
			UpdatedOn *time.Time `json:"updated_on,omitempty"`

			// Version The version of the wiki.
			Version *int `json:"version,omitempty"`
		} `json:"wiki_page,omitempty"`
	}
	JSON422 *struct {
		Errors *[]string `json:"errors,omitempty"`
	}
}
type WikiUpdatePatch_201_WikiPage_Attachments_Item struct {
	Author *struct {
		// Id The ID of the author.
		Id *int `json:"id,omitempty"`

		// Name The name of the author.
		Name *string `json:"name,omitempty"`
	} `json:"author,omitempty"`

	// ContentType The content type of the attachment.
	ContentType *string `json:"content_type,omitempty"`

	// ContentUrl The content URL of the attachment.
	ContentUrl *string `json:"content_url,omitempty"`

	// CreatedOn The date and time when the attachment was created.
	CreatedOn *time.Time `json:"created_on,omitempty"`

	// Description The description of the attachment.
	Description *string `json:"description,omitempty"`

	// Filename The filename of the attachment.
	Filename *string `json:"filename,omitempty"`

	// Filesize The filesize of the attachment.
	Filesize *int `json:"filesize,omitempty"`

	// Id The ID of the attachment.
	Id *int `json:"id,omitempty"`

	// ThumbnailUrl The thumbnail URL of the attachment.
	ThumbnailUrl         *string                `json:"thumbnail_url,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Status returns HTTPResponse.Status
func (r WikiUpdatePatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WikiUpdatePatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WikiUpdatePutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// WikiPage A single wiki.
		WikiPage *struct {
			Attachments *[]WikiUpdatePut_201_WikiPage_Attachments_Item `json:"attachments,omitempty"`
			Author      *struct {
				// Id The ID of the author.
				Id *int `json:"id,omitempty"`

				// Name The name of the author.
				Name *string `json:"name,omitempty"`
			} `json:"author,omitempty"`

			// Comments The comments of the wiki.
			Comments *string `json:"comments,omitempty"`

			// CreatedOn The date and time when the wiki was created.
			CreatedOn *time.Time `json:"created_on,omitempty"`
			Parent    *struct {
				// Title The parent title of the wiki.
				Title *string `json:"title,omitempty"`
			} `json:"parent,omitempty"`

			// Text The text of the wiki.
			Text *string `json:"text,omitempty"`

			// Title The title of the wiki.
			Title *string `json:"title,omitempty"`

			// UpdatedOn The date and time when the wiki was last updated.
			UpdatedOn *time.Time `json:"updated_on,omitempty"`

			// Version The version of the wiki.
			Version *int `json:"version,omitempty"`
		} `json:"wiki_page,omitempty"`
	}
	JSON422 *struct {
		Errors *[]string `json:"errors,omitempty"`
	}
}
type WikiUpdatePut_201_WikiPage_Attachments_Item struct {
	Author *struct {
		// Id The ID of the author.
		Id *int `json:"id,omitempty"`

		// Name The name of the author.
		Name *string `json:"name,omitempty"`
	} `json:"author,omitempty"`

	// ContentType The content type of the attachment.
	ContentType *string `json:"content_type,omitempty"`

	// ContentUrl The content URL of the attachment.
	ContentUrl *string `json:"content_url,omitempty"`

	// CreatedOn The date and time when the attachment was created.
	CreatedOn *time.Time `json:"created_on,omitempty"`

	// Description The description of the attachment.
	Description *string `json:"description,omitempty"`

	// Filename The filename of the attachment.
	Filename *string `json:"filename,omitempty"`

	// Filesize The filesize of the attachment.
	Filesize *int `json:"filesize,omitempty"`

	// Id The ID of the attachment.
	Id *int `json:"id,omitempty"`

	// ThumbnailUrl The thumbnail URL of the attachment.
	ThumbnailUrl         *string                `json:"thumbnail_url,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Status returns HTTPResponse.Status
func (r WikiUpdatePutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WikiUpdatePutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WikiShowPdfResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r WikiShowPdfResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WikiShowPdfResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WikiShowTxtResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r WikiShowTxtResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WikiShowTxtResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WikiShowVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// WikiPage A single wiki.
		WikiPage *struct {
			Attachments *[]WikiShowVersion_200_WikiPage_Attachments_Item `json:"attachments,omitempty"`
			Author      *struct {
				// Id The ID of the author.
				Id *int `json:"id,omitempty"`

				// Name The name of the author.
				Name *string `json:"name,omitempty"`
			} `json:"author,omitempty"`

			// Comments The comments of the wiki.
			Comments *string `json:"comments,omitempty"`

			// CreatedOn The date and time when the wiki was created.
			CreatedOn *time.Time `json:"created_on,omitempty"`
			Parent    *struct {
				// Title The parent title of the wiki.
				Title *string `json:"title,omitempty"`
			} `json:"parent,omitempty"`

			// Text The text of the wiki.
			Text *string `json:"text,omitempty"`

			// Title The title of the wiki.
			Title *string `json:"title,omitempty"`

			// UpdatedOn The date and time when the wiki was last updated.
			UpdatedOn *time.Time `json:"updated_on,omitempty"`

			// Version The version of the wiki.
			Version *int `json:"version,omitempty"`
		} `json:"wiki_page,omitempty"`
	}
}
type WikiShowVersion_200_WikiPage_Attachments_Item struct {
	Author *struct {
		// Id The ID of the author.
		Id *int `json:"id,omitempty"`

		// Name The name of the author.
		Name *string `json:"name,omitempty"`
	} `json:"author,omitempty"`

	// ContentType The content type of the attachment.
	ContentType *string `json:"content_type,omitempty"`

	// ContentUrl The content URL of the attachment.
	ContentUrl *string `json:"content_url,omitempty"`

	// CreatedOn The date and time when the attachment was created.
	CreatedOn *time.Time `json:"created_on,omitempty"`

	// Description The description of the attachment.
	Description *string `json:"description,omitempty"`

	// Filename The filename of the attachment.
	Filename *string `json:"filename,omitempty"`

	// Filesize The filesize of the attachment.
	Filesize *int `json:"filesize,omitempty"`

	// Id The ID of the attachment.
	Id *int `json:"id,omitempty"`

	// ThumbnailUrl The thumbnail URL of the attachment.
	ThumbnailUrl         *string                `json:"thumbnail_url,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Status returns HTTPResponse.Status
func (r WikiShowVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WikiShowVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WikiShowVersionPdfResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r WikiShowVersionPdfResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WikiShowVersionPdfResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WikiShowVersionTxtResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r WikiShowVersionTxtResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WikiShowVersionTxtResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type QueriesIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Limit The maximum number of queries returned in the result set.
		Limit *int `json:"limit,omitempty"`

		// Offset The offset of the first query in the result set.
		Offset  *int `json:"offset,omitempty"`
		Queries *[]struct {
			// Id The unique identifier of the query.
			Id *int `json:"id,omitempty"`

			// IsPublic Whether the query is public.
			IsPublic *bool `json:"is_public,omitempty"`

			// Name The name of the query.
			Name *string `json:"name,omitempty"`

			// ProjectId The unique identifier of the project.
			ProjectId *int `json:"project_id,omitempty"`
		} `json:"queries,omitempty"`

		// TotalCount The total number of queries returned.
		TotalCount *int `json:"total_count,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r QueriesIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r QueriesIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssueRelationsDestroyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r IssueRelationsDestroyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssueRelationsDestroyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssueRelationsShowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Relation Represents a single issue relation.
		Relation *struct {
			// Delay The delay of the relation.
			Delay *int `json:"delay,omitempty"`

			// Id The ID of the relation.
			Id *int `json:"id,omitempty"`

			// IssueId The ID of the issue.
			IssueId *int `json:"issue_id,omitempty"`

			// IssueToId The ID of the issue to.
			IssueToId *int `json:"issue_to_id,omitempty"`

			// RelationType The relation type of the relation.
			RelationType *string `json:"relation_type,omitempty"`
		} `json:"relation,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r IssueRelationsShowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssueRelationsShowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RolesIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Roles *[]struct {
			// Id The unique identifier of the role.
			Id *int `json:"id,omitempty"`

			// Name The name of the role.
			Name *string `json:"name,omitempty"`
		} `json:"roles,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r RolesIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RolesIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RolesShowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Role Represents a single role with additional details.
		Role *struct {
			// Assignable Whether the role is assignable.
			Assignable *bool `json:"assignable,omitempty"`

			// Id The unique identifier of the role.
			Id *int `json:"id,omitempty"`

			// IssuesVisibility The visibility of issues for this role.
			IssuesVisibility *string `json:"issues_visibility,omitempty"`

			// Name The name of the role.
			Name        *string   `json:"name,omitempty"`
			Permissions *[]string `json:"permissions,omitempty"`

			// TimeEntriesVisibility The time entries visibility of the role.
			TimeEntriesVisibility *string `json:"time_entries_visibility,omitempty"`

			// UsersVisibility The users visibility of the role.
			UsersVisibility *string `json:"users_visibility,omitempty"`
		} `json:"role,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r RolesShowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RolesShowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Limit The maximum number of search results returned in the list.
		Limit *int `json:"limit,omitempty"`

		// Offset The offset of the first search result in the list.
		Offset  *int `json:"offset,omitempty"`
		Results *[]struct {
			// Datetime The date and time when the search result was created.
			Datetime *time.Time `json:"datetime,omitempty"`

			// Description The description of the search result.
			Description *string `json:"description,omitempty"`

			// Id The ID of the search result.
			Id *int `json:"id,omitempty"`

			// Title The title of the search result.
			Title *string `json:"title,omitempty"`

			// Type The type of the search result.
			Type *string `json:"type,omitempty"`

			// Url The url of the search result.
			Url *string `json:"url,omitempty"`
		} `json:"results,omitempty"`

		// TotalCount The total number of search results.
		TotalCount *int `json:"total_count,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SearchIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TimelogIndexCsvResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TimelogIndexCsvResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TimelogIndexCsvResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TimelogIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Limit The maximum number of time entries returned in the list.
		Limit *int `json:"limit,omitempty"`

		// Offset The offset of the first time entry in the list.
		Offset      *int `json:"offset,omitempty"`
		TimeEntries *[]struct {
			Activity *struct {
				// Id The ID of the activity.
				Id *int `json:"id,omitempty"`

				// Name The name of the activity.
				Name *string `json:"name,omitempty"`
			} `json:"activity,omitempty"`

			// Comments The comments of the time entry.
			Comments *string `json:"comments,omitempty"`

			// CreatedOn The date and time when the time entry was created.
			CreatedOn    *time.Time `json:"created_on,omitempty"`
			CustomFields *[]struct {
				// Id The ID of the custom field.
				Id *int `json:"id,omitempty"`

				// Multiple Whether the custom field can have multiple values.
				Multiple *bool `json:"multiple,omitempty"`

				// Name The name of the custom field.
				Name  *string      `json:"name,omitempty"`
				Value *interface{} `json:"value,omitempty"`
			} `json:"custom_fields,omitempty"`

			// Hours The hours of the time entry.
			Hours *float32 `json:"hours,omitempty"`

			// Id The ID of the time entry.
			Id    *int `json:"id,omitempty"`
			Issue *struct {
				// Id The ID of the issue.
				Id *int `json:"id,omitempty"`
			} `json:"issue,omitempty"`
			Project *struct {
				// Id The ID of the project.
				Id *int `json:"id,omitempty"`

				// Name The name of the project.
				Name *string `json:"name,omitempty"`
			} `json:"project,omitempty"`

			// SpentOn The date when the time entry was spent.
			SpentOn *openapi_types.Date `json:"spent_on,omitempty"`

			// UpdatedOn The date and time when the time entry was last updated.
			UpdatedOn *time.Time `json:"updated_on,omitempty"`
			User      *struct {
				// Id The ID of the user.
				Id *int `json:"id,omitempty"`

				// Name The name of the user.
				Name *string `json:"name,omitempty"`
			} `json:"user,omitempty"`
		} `json:"time_entries,omitempty"`

		// TotalCount The total number of time entries.
		TotalCount *int `json:"total_count,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TimelogIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TimelogIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TimelogCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// TimeEntry A single time entry.
		TimeEntry *struct {
			Activity *struct {
				// Id The ID of the activity.
				Id *int `json:"id,omitempty"`

				// Name The name of the activity.
				Name *string `json:"name,omitempty"`
			} `json:"activity,omitempty"`

			// Comments The comments of the time entry.
			Comments *string `json:"comments,omitempty"`

			// CreatedOn The date and time when the time entry was created.
			CreatedOn    *time.Time `json:"created_on,omitempty"`
			CustomFields *[]struct {
				// Id The ID of the custom field.
				Id *int `json:"id,omitempty"`

				// Multiple Whether the custom field can have multiple values.
				Multiple *bool `json:"multiple,omitempty"`

				// Name The name of the custom field.
				Name  *string      `json:"name,omitempty"`
				Value *interface{} `json:"value,omitempty"`
			} `json:"custom_fields,omitempty"`

			// Hours The hours of the time entry.
			Hours *float32 `json:"hours,omitempty"`

			// Id The ID of the time entry.
			Id    *int `json:"id,omitempty"`
			Issue *struct {
				// Id The ID of the issue.
				Id *int `json:"id,omitempty"`
			} `json:"issue,omitempty"`
			Project *struct {
				// Id The ID of the project.
				Id *int `json:"id,omitempty"`

				// Name The name of the project.
				Name *string `json:"name,omitempty"`
			} `json:"project,omitempty"`

			// SpentOn The date when the time entry was spent.
			SpentOn *openapi_types.Date `json:"spent_on,omitempty"`

			// UpdatedOn The date and time when the time entry was last updated.
			UpdatedOn *time.Time `json:"updated_on,omitempty"`
			User      *struct {
				// Id The ID of the user.
				Id *int `json:"id,omitempty"`

				// Name The name of the user.
				Name *string `json:"name,omitempty"`
			} `json:"user,omitempty"`
		} `json:"time_entry,omitempty"`
	}
	JSON422 *struct {
		Errors *[]string `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TimelogCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TimelogCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TimelogDestroyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *struct {
		Errors *[]string `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TimelogDestroyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TimelogDestroyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TimelogShowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// TimeEntry A single time entry.
		TimeEntry *struct {
			Activity *struct {
				// Id The ID of the activity.
				Id *int `json:"id,omitempty"`

				// Name The name of the activity.
				Name *string `json:"name,omitempty"`
			} `json:"activity,omitempty"`

			// Comments The comments of the time entry.
			Comments *string `json:"comments,omitempty"`

			// CreatedOn The date and time when the time entry was created.
			CreatedOn    *time.Time `json:"created_on,omitempty"`
			CustomFields *[]struct {
				// Id The ID of the custom field.
				Id *int `json:"id,omitempty"`

				// Multiple Whether the custom field can have multiple values.
				Multiple *bool `json:"multiple,omitempty"`

				// Name The name of the custom field.
				Name  *string      `json:"name,omitempty"`
				Value *interface{} `json:"value,omitempty"`
			} `json:"custom_fields,omitempty"`

			// Hours The hours of the time entry.
			Hours *float32 `json:"hours,omitempty"`

			// Id The ID of the time entry.
			Id    *int `json:"id,omitempty"`
			Issue *struct {
				// Id The ID of the issue.
				Id *int `json:"id,omitempty"`
			} `json:"issue,omitempty"`
			Project *struct {
				// Id The ID of the project.
				Id *int `json:"id,omitempty"`

				// Name The name of the project.
				Name *string `json:"name,omitempty"`
			} `json:"project,omitempty"`

			// SpentOn The date when the time entry was spent.
			SpentOn *openapi_types.Date `json:"spent_on,omitempty"`

			// UpdatedOn The date and time when the time entry was last updated.
			UpdatedOn *time.Time `json:"updated_on,omitempty"`
			User      *struct {
				// Id The ID of the user.
				Id *int `json:"id,omitempty"`

				// Name The name of the user.
				Name *string `json:"name,omitempty"`
			} `json:"user,omitempty"`
		} `json:"time_entry,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TimelogShowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TimelogShowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TimelogUpdatePatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *struct {
		Errors *[]string `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TimelogUpdatePatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TimelogUpdatePatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TimelogUpdatePutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *struct {
		Errors *[]string `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TimelogUpdatePutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TimelogUpdatePutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TrackersIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Trackers *[]struct {
			DefaultStatus *struct {
				// Id The unique identifier of the default status.
				Id *int `json:"id,omitempty"`

				// Name The name of the default status.
				Name *string `json:"name,omitempty"`
			} `json:"default_status,omitempty"`

			// Description A description of the tracker.
			Description           *string   `json:"description,omitempty"`
			EnabledStandardFields *[]string `json:"enabled_standard_fields,omitempty"`

			// Id The unique identifier of the tracker.
			Id *int `json:"id,omitempty"`

			// Name The name of the tracker.
			Name *string `json:"name,omitempty"`
		} `json:"trackers,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TrackersIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TrackersIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AttachmentsUploadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Upload *struct {
			// Id The ID of the attachment.
			Id *int `json:"id,omitempty"`

			// Token The token of the attachment.
			Token *string `json:"token,omitempty"`
		} `json:"upload,omitempty"`
	}
	JSON422 *struct {
		Errors *[]string `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AttachmentsUploadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AttachmentsUploadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsersIndexCsvResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UsersIndexCsvResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsersIndexCsvResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsersIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Limit The maximum number of users returned in the list.
		Limit *int `json:"limit,omitempty"`

		// Offset The offset of the first user in the list.
		Offset *int `json:"offset,omitempty"`

		// TotalCount The total number of users.
		TotalCount *int `json:"total_count,omitempty"`
		Users      *[]struct {
			// Admin The administrative of the user.
			Admin      *bool `json:"admin,omitempty"`
			AuthSource *struct {
				// Id The ID of the auth source.
				Id *int `json:"id,omitempty"`

				// Name The name of the auth source.
				Name *string `json:"name,omitempty"`
			} `json:"auth_source,omitempty"`

			// AvatarUrl The avatar URL of the user.
			AvatarUrl *string `json:"avatar_url,omitempty"`

			// CreatedOn The date and time when the user was created.
			CreatedOn    *time.Time `json:"created_on,omitempty"`
			CustomFields *[]struct {
				// Id The ID of the custom field.
				Id *int `json:"id,omitempty"`

				// Multiple Whether the custom field can have multiple values.
				Multiple *bool `json:"multiple,omitempty"`

				// Name The name of the custom field.
				Name  *string      `json:"name,omitempty"`
				Value *interface{} `json:"value,omitempty"`
			} `json:"custom_fields,omitempty"`

			// Firstname The firstname of the user.
			Firstname *string `json:"firstname,omitempty"`

			// Id The ID of the user.
			Id *int `json:"id,omitempty"`

			// LastLoginOn The date and time when the user was last logon.
			LastLoginOn *time.Time `json:"last_login_on,omitempty"`

			// Lastname The lastname of the user.
			Lastname *string `json:"lastname,omitempty"`

			// Login The login of the user.
			Login *string `json:"login,omitempty"`

			// Mail The mail of the user.
			Mail *string `json:"mail,omitempty"`

			// PasswdChangedOn The date and time when the user was change password.
			PasswdChangedOn *time.Time `json:"passwd_changed_on,omitempty"`

			// Status The status of the user. Possible values are:
			// - `0`: anonymous
			// - `1`: active
			// - `2`: registered
			// - `3`: locked
			Status *int `json:"status,omitempty"`

			// TwofaScheme The 2FA scheme of the user.
			TwofaScheme *string `json:"twofa_scheme,omitempty"`

			// UpdatedOn The date and time when the user was last updated.
			UpdatedOn *time.Time `json:"updated_on,omitempty"`
		} `json:"users,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UsersIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsersIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsersCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// User A single user.
		User *struct {
			// Admin The administrative of the user.
			Admin *bool `json:"admin,omitempty"`

			// ApiKey The API key of the user.
			ApiKey     *string `json:"api_key,omitempty"`
			AuthSource *struct {
				// Id The ID of the auth source.
				Id *int `json:"id,omitempty"`

				// Name The name of the auth source.
				Name *string `json:"name,omitempty"`
			} `json:"auth_source,omitempty"`

			// AvatarUrl The avatar URL of the user.
			AvatarUrl *string `json:"avatar_url,omitempty"`

			// CreatedOn The date and time when the user was created.
			CreatedOn    *time.Time `json:"created_on,omitempty"`
			CustomFields *[]struct {
				// Id The ID of the custom field.
				Id *int `json:"id,omitempty"`

				// Multiple Whether the custom field can have multiple values.
				Multiple *bool `json:"multiple,omitempty"`

				// Name The name of the custom field.
				Name  *string      `json:"name,omitempty"`
				Value *interface{} `json:"value,omitempty"`
			} `json:"custom_fields,omitempty"`

			// Firstname The firstname of the user.
			Firstname *string `json:"firstname,omitempty"`
			Groups    *[]struct {
				// Id The ID of the group.
				Id *int `json:"id,omitempty"`

				// Name The name of the group.
				Name *string `json:"name,omitempty"`
			} `json:"groups,omitempty"`

			// Id The ID of the user.
			Id *int `json:"id,omitempty"`

			// LastLoginOn The date and time when the user was last logon.
			LastLoginOn *time.Time `json:"last_login_on,omitempty"`

			// Lastname The lastname of the user.
			Lastname *string `json:"lastname,omitempty"`

			// Login The login of the user.
			Login *string `json:"login,omitempty"`

			// Mail The mail of the user.
			Mail        *string `json:"mail,omitempty"`
			Memberships *[]struct {
				// Id The ID of the mebership.
				Id      *int `json:"id,omitempty"`
				Project *struct {
					// Id The ID of the project.
					Id *int `json:"id,omitempty"`

					// Name The name of the project.
					Name *string `json:"name,omitempty"`
				} `json:"project,omitempty"`
				Roles *[]struct {
					// Id The ID of the role.
					Id *int `json:"id,omitempty"`

					// Inherited Whether the role is inherited from a parent project.
					Inherited *bool `json:"inherited,omitempty"`

					// Name The name of the role.
					Name *string `json:"name,omitempty"`
				} `json:"roles,omitempty"`
			} `json:"memberships,omitempty"`

			// PasswdChangedOn The date and time when the user was change password.
			PasswdChangedOn *time.Time `json:"passwd_changed_on,omitempty"`

			// Status The status of the user. Possible values are:
			// - `0`: anonymous
			// - `1`: active
			// - `2`: registered
			// - `3`: locked
			Status *int `json:"status,omitempty"`

			// TwofaScheme The 2FA scheme of the user.
			TwofaScheme *string `json:"twofa_scheme,omitempty"`

			// UpdatedOn The date and time when the user was last updated.
			UpdatedOn *time.Time `json:"updated_on,omitempty"`
		} `json:"user,omitempty"`
	}
	JSON422 *struct {
		Errors *[]string `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UsersCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsersCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsersDestroyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *struct {
		Errors *[]string `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UsersDestroyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsersDestroyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsersShowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// User A single user.
		User *struct {
			// Admin The administrative of the user.
			Admin *bool `json:"admin,omitempty"`

			// ApiKey The API key of the user.
			ApiKey     *string `json:"api_key,omitempty"`
			AuthSource *struct {
				// Id The ID of the auth source.
				Id *int `json:"id,omitempty"`

				// Name The name of the auth source.
				Name *string `json:"name,omitempty"`
			} `json:"auth_source,omitempty"`

			// AvatarUrl The avatar URL of the user.
			AvatarUrl *string `json:"avatar_url,omitempty"`

			// CreatedOn The date and time when the user was created.
			CreatedOn    *time.Time `json:"created_on,omitempty"`
			CustomFields *[]struct {
				// Id The ID of the custom field.
				Id *int `json:"id,omitempty"`

				// Multiple Whether the custom field can have multiple values.
				Multiple *bool `json:"multiple,omitempty"`

				// Name The name of the custom field.
				Name  *string      `json:"name,omitempty"`
				Value *interface{} `json:"value,omitempty"`
			} `json:"custom_fields,omitempty"`

			// Firstname The firstname of the user.
			Firstname *string `json:"firstname,omitempty"`
			Groups    *[]struct {
				// Id The ID of the group.
				Id *int `json:"id,omitempty"`

				// Name The name of the group.
				Name *string `json:"name,omitempty"`
			} `json:"groups,omitempty"`

			// Id The ID of the user.
			Id *int `json:"id,omitempty"`

			// LastLoginOn The date and time when the user was last logon.
			LastLoginOn *time.Time `json:"last_login_on,omitempty"`

			// Lastname The lastname of the user.
			Lastname *string `json:"lastname,omitempty"`

			// Login The login of the user.
			Login *string `json:"login,omitempty"`

			// Mail The mail of the user.
			Mail        *string `json:"mail,omitempty"`
			Memberships *[]struct {
				// Id The ID of the mebership.
				Id      *int `json:"id,omitempty"`
				Project *struct {
					// Id The ID of the project.
					Id *int `json:"id,omitempty"`

					// Name The name of the project.
					Name *string `json:"name,omitempty"`
				} `json:"project,omitempty"`
				Roles *[]struct {
					// Id The ID of the role.
					Id *int `json:"id,omitempty"`

					// Inherited Whether the role is inherited from a parent project.
					Inherited *bool `json:"inherited,omitempty"`

					// Name The name of the role.
					Name *string `json:"name,omitempty"`
				} `json:"roles,omitempty"`
			} `json:"memberships,omitempty"`

			// PasswdChangedOn The date and time when the user was change password.
			PasswdChangedOn *time.Time `json:"passwd_changed_on,omitempty"`

			// Status The status of the user. Possible values are:
			// - `0`: anonymous
			// - `1`: active
			// - `2`: registered
			// - `3`: locked
			Status *int `json:"status,omitempty"`

			// TwofaScheme The 2FA scheme of the user.
			TwofaScheme *string `json:"twofa_scheme,omitempty"`

			// UpdatedOn The date and time when the user was last updated.
			UpdatedOn *time.Time `json:"updated_on,omitempty"`
		} `json:"user,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UsersShowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsersShowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsersUpdatePatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *struct {
		Errors *[]string `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UsersUpdatePatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsersUpdatePatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsersUpdatePutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *struct {
		Errors *[]string `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UsersUpdatePutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsersUpdatePutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VersionsDestroyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r VersionsDestroyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VersionsDestroyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VersionsShowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Version A single version.
		Version *struct {
			// CreatedOn The date and time when the version was created.
			CreatedOn    *time.Time `json:"created_on,omitempty"`
			CustomFields *[]struct {
				// Id The ID of the custom field.
				Id *int `json:"id,omitempty"`

				// Multiple Whether the custom field can have multiple values.
				Multiple *bool `json:"multiple,omitempty"`

				// Name The name of the custom field.
				Name  *string      `json:"name,omitempty"`
				Value *interface{} `json:"value,omitempty"`
			} `json:"custom_fields,omitempty"`

			// Description The description of the version.
			Description *string `json:"description,omitempty"`

			// DueDate The date when the version was expired.
			DueDate *openapi_types.Date `json:"due_date,omitempty"`

			// EstimatedHours The estimated hours of the version.
			EstimatedHours *float32 `json:"estimated_hours,omitempty"`

			// Id The ID of the version.
			Id *int `json:"id,omitempty"`

			// Name The name of the version.
			Name    *string `json:"name,omitempty"`
			Project *struct {
				// Id The ID of the project.
				Id *int `json:"id,omitempty"`

				// Name The name of the project.
				Name *string `json:"name,omitempty"`
			} `json:"project,omitempty"`

			// Sharing The sharing of the version.
			Sharing *string `json:"sharing,omitempty"`

			// SpentHours The spent hours of the version.
			SpentHours *float32 `json:"spent_hours,omitempty"`

			// Status The status of the version.
			Status *string `json:"status,omitempty"`

			// UpdatedOn The date and time when the version was last updated.
			UpdatedOn *time.Time `json:"updated_on,omitempty"`

			// WikiPageTitle The wiki page title of the version.
			WikiPageTitle *string `json:"wiki_page_title,omitempty"`
		} `json:"version,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r VersionsShowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VersionsShowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VersionsUpdatePatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *struct {
		Errors *[]string `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r VersionsUpdatePatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VersionsUpdatePatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VersionsUpdatePutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *struct {
		Errors *[]string `json:"errors,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r VersionsUpdatePutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VersionsUpdatePutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VersionsShowTxtResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r VersionsShowTxtResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VersionsShowTxtResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WatchersDestroyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r WatchersDestroyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WatchersDestroyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WatchersCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r WatchersCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WatchersCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// AttachmentsDownloadWithResponse request returning *AttachmentsDownloadResponse
func (c *ClientWithResponses) AttachmentsDownloadWithResponse(ctx context.Context, id int, params *AttachmentsDownloadParams, reqEditors ...RequestEditorFn) (*AttachmentsDownloadResponse, error) {
	rsp, err := c.AttachmentsDownload(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachmentsDownloadResponse(rsp)
}

// AttachmentsThumbnailWithResponse request returning *AttachmentsThumbnailResponse
func (c *ClientWithResponses) AttachmentsThumbnailWithResponse(ctx context.Context, id int, params *AttachmentsThumbnailParams, reqEditors ...RequestEditorFn) (*AttachmentsThumbnailResponse, error) {
	rsp, err := c.AttachmentsThumbnail(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachmentsThumbnailResponse(rsp)
}

// AttachmentsThumbnailSizeWithResponse request returning *AttachmentsThumbnailSizeResponse
func (c *ClientWithResponses) AttachmentsThumbnailSizeWithResponse(ctx context.Context, id int, size int, params *AttachmentsThumbnailSizeParams, reqEditors ...RequestEditorFn) (*AttachmentsThumbnailSizeResponse, error) {
	rsp, err := c.AttachmentsThumbnailSize(ctx, id, size, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachmentsThumbnailSizeResponse(rsp)
}

// AttachmentsDestroyWithResponse request returning *AttachmentsDestroyResponse
func (c *ClientWithResponses) AttachmentsDestroyWithResponse(ctx context.Context, id int, params *AttachmentsDestroyParams, reqEditors ...RequestEditorFn) (*AttachmentsDestroyResponse, error) {
	rsp, err := c.AttachmentsDestroy(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachmentsDestroyResponse(rsp)
}

// AttachmentsShowWithResponse request returning *AttachmentsShowResponse
func (c *ClientWithResponses) AttachmentsShowWithResponse(ctx context.Context, id int, params *AttachmentsShowParams, reqEditors ...RequestEditorFn) (*AttachmentsShowResponse, error) {
	rsp, err := c.AttachmentsShow(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachmentsShowResponse(rsp)
}

// AttachmentsUpdatePatchWithBodyWithResponse request with arbitrary body returning *AttachmentsUpdatePatchResponse
func (c *ClientWithResponses) AttachmentsUpdatePatchWithBodyWithResponse(ctx context.Context, id int, params *AttachmentsUpdatePatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachmentsUpdatePatchResponse, error) {
	rsp, err := c.AttachmentsUpdatePatchWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachmentsUpdatePatchResponse(rsp)
}

func (c *ClientWithResponses) AttachmentsUpdatePatchWithResponse(ctx context.Context, id int, params *AttachmentsUpdatePatchParams, body AttachmentsUpdatePatchJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachmentsUpdatePatchResponse, error) {
	rsp, err := c.AttachmentsUpdatePatch(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachmentsUpdatePatchResponse(rsp)
}

// AttachmentsUpdatePutWithBodyWithResponse request with arbitrary body returning *AttachmentsUpdatePutResponse
func (c *ClientWithResponses) AttachmentsUpdatePutWithBodyWithResponse(ctx context.Context, id int, params *AttachmentsUpdatePutParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachmentsUpdatePutResponse, error) {
	rsp, err := c.AttachmentsUpdatePutWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachmentsUpdatePutResponse(rsp)
}

func (c *ClientWithResponses) AttachmentsUpdatePutWithResponse(ctx context.Context, id int, params *AttachmentsUpdatePutParams, body AttachmentsUpdatePutJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachmentsUpdatePutResponse, error) {
	rsp, err := c.AttachmentsUpdatePut(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachmentsUpdatePutResponse(rsp)
}

// AttachmentsDownloadAllWithResponse request returning *AttachmentsDownloadAllResponse
func (c *ClientWithResponses) AttachmentsDownloadAllWithResponse(ctx context.Context, objectType string, objectId int, params *AttachmentsDownloadAllParams, reqEditors ...RequestEditorFn) (*AttachmentsDownloadAllResponse, error) {
	rsp, err := c.AttachmentsDownloadAll(ctx, objectType, objectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachmentsDownloadAllResponse(rsp)
}

// CustomFieldsIndexWithResponse request returning *CustomFieldsIndexResponse
func (c *ClientWithResponses) CustomFieldsIndexWithResponse(ctx context.Context, params *CustomFieldsIndexParams, reqEditors ...RequestEditorFn) (*CustomFieldsIndexResponse, error) {
	rsp, err := c.CustomFieldsIndex(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCustomFieldsIndexResponse(rsp)
}

// EnumerationsIndexDocumentCategoryWithResponse request returning *EnumerationsIndexDocumentCategoryResponse
func (c *ClientWithResponses) EnumerationsIndexDocumentCategoryWithResponse(ctx context.Context, params *EnumerationsIndexDocumentCategoryParams, reqEditors ...RequestEditorFn) (*EnumerationsIndexDocumentCategoryResponse, error) {
	rsp, err := c.EnumerationsIndexDocumentCategory(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnumerationsIndexDocumentCategoryResponse(rsp)
}

// EnumerationsIndexIssuePriorityWithResponse request returning *EnumerationsIndexIssuePriorityResponse
func (c *ClientWithResponses) EnumerationsIndexIssuePriorityWithResponse(ctx context.Context, params *EnumerationsIndexIssuePriorityParams, reqEditors ...RequestEditorFn) (*EnumerationsIndexIssuePriorityResponse, error) {
	rsp, err := c.EnumerationsIndexIssuePriority(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnumerationsIndexIssuePriorityResponse(rsp)
}

// EnumerationsIndexTimeEntryActivityWithResponse request returning *EnumerationsIndexTimeEntryActivityResponse
func (c *ClientWithResponses) EnumerationsIndexTimeEntryActivityWithResponse(ctx context.Context, params *EnumerationsIndexTimeEntryActivityParams, reqEditors ...RequestEditorFn) (*EnumerationsIndexTimeEntryActivityResponse, error) {
	rsp, err := c.EnumerationsIndexTimeEntryActivity(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnumerationsIndexTimeEntryActivityResponse(rsp)
}

// GroupsIndexWithResponse request returning *GroupsIndexResponse
func (c *ClientWithResponses) GroupsIndexWithResponse(ctx context.Context, params *GroupsIndexParams, reqEditors ...RequestEditorFn) (*GroupsIndexResponse, error) {
	rsp, err := c.GroupsIndex(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGroupsIndexResponse(rsp)
}

// GroupsCreateWithBodyWithResponse request with arbitrary body returning *GroupsCreateResponse
func (c *ClientWithResponses) GroupsCreateWithBodyWithResponse(ctx context.Context, params *GroupsCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GroupsCreateResponse, error) {
	rsp, err := c.GroupsCreateWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGroupsCreateResponse(rsp)
}

func (c *ClientWithResponses) GroupsCreateWithResponse(ctx context.Context, params *GroupsCreateParams, body GroupsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*GroupsCreateResponse, error) {
	rsp, err := c.GroupsCreate(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGroupsCreateResponse(rsp)
}

// GroupsDestroyWithResponse request returning *GroupsDestroyResponse
func (c *ClientWithResponses) GroupsDestroyWithResponse(ctx context.Context, id int, params *GroupsDestroyParams, reqEditors ...RequestEditorFn) (*GroupsDestroyResponse, error) {
	rsp, err := c.GroupsDestroy(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGroupsDestroyResponse(rsp)
}

// GroupsShowWithResponse request returning *GroupsShowResponse
func (c *ClientWithResponses) GroupsShowWithResponse(ctx context.Context, id int, params *GroupsShowParams, reqEditors ...RequestEditorFn) (*GroupsShowResponse, error) {
	rsp, err := c.GroupsShow(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGroupsShowResponse(rsp)
}

// GroupsUpdatePatchWithBodyWithResponse request with arbitrary body returning *GroupsUpdatePatchResponse
func (c *ClientWithResponses) GroupsUpdatePatchWithBodyWithResponse(ctx context.Context, id int, params *GroupsUpdatePatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GroupsUpdatePatchResponse, error) {
	rsp, err := c.GroupsUpdatePatchWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGroupsUpdatePatchResponse(rsp)
}

func (c *ClientWithResponses) GroupsUpdatePatchWithResponse(ctx context.Context, id int, params *GroupsUpdatePatchParams, body GroupsUpdatePatchJSONRequestBody, reqEditors ...RequestEditorFn) (*GroupsUpdatePatchResponse, error) {
	rsp, err := c.GroupsUpdatePatch(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGroupsUpdatePatchResponse(rsp)
}

// GroupsUpdatePutWithBodyWithResponse request with arbitrary body returning *GroupsUpdatePutResponse
func (c *ClientWithResponses) GroupsUpdatePutWithBodyWithResponse(ctx context.Context, id int, params *GroupsUpdatePutParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GroupsUpdatePutResponse, error) {
	rsp, err := c.GroupsUpdatePutWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGroupsUpdatePutResponse(rsp)
}

func (c *ClientWithResponses) GroupsUpdatePutWithResponse(ctx context.Context, id int, params *GroupsUpdatePutParams, body GroupsUpdatePutJSONRequestBody, reqEditors ...RequestEditorFn) (*GroupsUpdatePutResponse, error) {
	rsp, err := c.GroupsUpdatePut(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGroupsUpdatePutResponse(rsp)
}

// GroupsAddUsersWithBodyWithResponse request with arbitrary body returning *GroupsAddUsersResponse
func (c *ClientWithResponses) GroupsAddUsersWithBodyWithResponse(ctx context.Context, id int, params *GroupsAddUsersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GroupsAddUsersResponse, error) {
	rsp, err := c.GroupsAddUsersWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGroupsAddUsersResponse(rsp)
}

func (c *ClientWithResponses) GroupsAddUsersWithResponse(ctx context.Context, id int, params *GroupsAddUsersParams, body GroupsAddUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*GroupsAddUsersResponse, error) {
	rsp, err := c.GroupsAddUsers(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGroupsAddUsersResponse(rsp)
}

// GroupsRemoveUserWithResponse request returning *GroupsRemoveUserResponse
func (c *ClientWithResponses) GroupsRemoveUserWithResponse(ctx context.Context, id int, userId int, params *GroupsRemoveUserParams, reqEditors ...RequestEditorFn) (*GroupsRemoveUserResponse, error) {
	rsp, err := c.GroupsRemoveUser(ctx, id, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGroupsRemoveUserResponse(rsp)
}

// IssueCategoriesDestroyWithResponse request returning *IssueCategoriesDestroyResponse
func (c *ClientWithResponses) IssueCategoriesDestroyWithResponse(ctx context.Context, id int, params *IssueCategoriesDestroyParams, reqEditors ...RequestEditorFn) (*IssueCategoriesDestroyResponse, error) {
	rsp, err := c.IssueCategoriesDestroy(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssueCategoriesDestroyResponse(rsp)
}

// IssueCategoriesShowWithResponse request returning *IssueCategoriesShowResponse
func (c *ClientWithResponses) IssueCategoriesShowWithResponse(ctx context.Context, id int, params *IssueCategoriesShowParams, reqEditors ...RequestEditorFn) (*IssueCategoriesShowResponse, error) {
	rsp, err := c.IssueCategoriesShow(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssueCategoriesShowResponse(rsp)
}

// IssueCategoriesUpdatePatchWithBodyWithResponse request with arbitrary body returning *IssueCategoriesUpdatePatchResponse
func (c *ClientWithResponses) IssueCategoriesUpdatePatchWithBodyWithResponse(ctx context.Context, id int, params *IssueCategoriesUpdatePatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IssueCategoriesUpdatePatchResponse, error) {
	rsp, err := c.IssueCategoriesUpdatePatchWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssueCategoriesUpdatePatchResponse(rsp)
}

func (c *ClientWithResponses) IssueCategoriesUpdatePatchWithResponse(ctx context.Context, id int, params *IssueCategoriesUpdatePatchParams, body IssueCategoriesUpdatePatchJSONRequestBody, reqEditors ...RequestEditorFn) (*IssueCategoriesUpdatePatchResponse, error) {
	rsp, err := c.IssueCategoriesUpdatePatch(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssueCategoriesUpdatePatchResponse(rsp)
}

// IssueCategoriesUpdatePutWithBodyWithResponse request with arbitrary body returning *IssueCategoriesUpdatePutResponse
func (c *ClientWithResponses) IssueCategoriesUpdatePutWithBodyWithResponse(ctx context.Context, id int, params *IssueCategoriesUpdatePutParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IssueCategoriesUpdatePutResponse, error) {
	rsp, err := c.IssueCategoriesUpdatePutWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssueCategoriesUpdatePutResponse(rsp)
}

func (c *ClientWithResponses) IssueCategoriesUpdatePutWithResponse(ctx context.Context, id int, params *IssueCategoriesUpdatePutParams, body IssueCategoriesUpdatePutJSONRequestBody, reqEditors ...RequestEditorFn) (*IssueCategoriesUpdatePutResponse, error) {
	rsp, err := c.IssueCategoriesUpdatePut(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssueCategoriesUpdatePutResponse(rsp)
}

// IssueStatusesIndexWithResponse request returning *IssueStatusesIndexResponse
func (c *ClientWithResponses) IssueStatusesIndexWithResponse(ctx context.Context, params *IssueStatusesIndexParams, reqEditors ...RequestEditorFn) (*IssueStatusesIndexResponse, error) {
	rsp, err := c.IssueStatusesIndex(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssueStatusesIndexResponse(rsp)
}

// IssuesIndexCsvWithResponse request returning *IssuesIndexCsvResponse
func (c *ClientWithResponses) IssuesIndexCsvWithResponse(ctx context.Context, params *IssuesIndexCsvParams, reqEditors ...RequestEditorFn) (*IssuesIndexCsvResponse, error) {
	rsp, err := c.IssuesIndexCsv(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssuesIndexCsvResponse(rsp)
}

// IssuesIndexWithResponse request returning *IssuesIndexResponse
func (c *ClientWithResponses) IssuesIndexWithResponse(ctx context.Context, params *IssuesIndexParams, reqEditors ...RequestEditorFn) (*IssuesIndexResponse, error) {
	rsp, err := c.IssuesIndex(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssuesIndexResponse(rsp)
}

// IssuesCreateWithBodyWithResponse request with arbitrary body returning *IssuesCreateResponse
func (c *ClientWithResponses) IssuesCreateWithBodyWithResponse(ctx context.Context, params *IssuesCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IssuesCreateResponse, error) {
	rsp, err := c.IssuesCreateWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssuesCreateResponse(rsp)
}

func (c *ClientWithResponses) IssuesCreateWithResponse(ctx context.Context, params *IssuesCreateParams, body IssuesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*IssuesCreateResponse, error) {
	rsp, err := c.IssuesCreate(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssuesCreateResponse(rsp)
}

// IssuesIndexPdfWithResponse request returning *IssuesIndexPdfResponse
func (c *ClientWithResponses) IssuesIndexPdfWithResponse(ctx context.Context, params *IssuesIndexPdfParams, reqEditors ...RequestEditorFn) (*IssuesIndexPdfResponse, error) {
	rsp, err := c.IssuesIndexPdf(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssuesIndexPdfResponse(rsp)
}

// GanttsShowPdfWithResponse request returning *GanttsShowPdfResponse
func (c *ClientWithResponses) GanttsShowPdfWithResponse(ctx context.Context, params *GanttsShowPdfParams, reqEditors ...RequestEditorFn) (*GanttsShowPdfResponse, error) {
	rsp, err := c.GanttsShowPdf(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGanttsShowPdfResponse(rsp)
}

// GanttsShowPngWithResponse request returning *GanttsShowPngResponse
func (c *ClientWithResponses) GanttsShowPngWithResponse(ctx context.Context, params *GanttsShowPngParams, reqEditors ...RequestEditorFn) (*GanttsShowPngResponse, error) {
	rsp, err := c.GanttsShowPng(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGanttsShowPngResponse(rsp)
}

// IssuesDestroyWithResponse request returning *IssuesDestroyResponse
func (c *ClientWithResponses) IssuesDestroyWithResponse(ctx context.Context, id int, params *IssuesDestroyParams, reqEditors ...RequestEditorFn) (*IssuesDestroyResponse, error) {
	rsp, err := c.IssuesDestroy(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssuesDestroyResponse(rsp)
}

// IssuesShowWithResponse request returning *IssuesShowResponse
func (c *ClientWithResponses) IssuesShowWithResponse(ctx context.Context, id int, params *IssuesShowParams, reqEditors ...RequestEditorFn) (*IssuesShowResponse, error) {
	rsp, err := c.IssuesShow(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssuesShowResponse(rsp)
}

// IssuesUpdatePatchWithBodyWithResponse request with arbitrary body returning *IssuesUpdatePatchResponse
func (c *ClientWithResponses) IssuesUpdatePatchWithBodyWithResponse(ctx context.Context, id int, params *IssuesUpdatePatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IssuesUpdatePatchResponse, error) {
	rsp, err := c.IssuesUpdatePatchWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssuesUpdatePatchResponse(rsp)
}

func (c *ClientWithResponses) IssuesUpdatePatchWithResponse(ctx context.Context, id int, params *IssuesUpdatePatchParams, body IssuesUpdatePatchJSONRequestBody, reqEditors ...RequestEditorFn) (*IssuesUpdatePatchResponse, error) {
	rsp, err := c.IssuesUpdatePatch(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssuesUpdatePatchResponse(rsp)
}

// IssuesUpdatePutWithBodyWithResponse request with arbitrary body returning *IssuesUpdatePutResponse
func (c *ClientWithResponses) IssuesUpdatePutWithBodyWithResponse(ctx context.Context, id int, params *IssuesUpdatePutParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IssuesUpdatePutResponse, error) {
	rsp, err := c.IssuesUpdatePutWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssuesUpdatePutResponse(rsp)
}

func (c *ClientWithResponses) IssuesUpdatePutWithResponse(ctx context.Context, id int, params *IssuesUpdatePutParams, body IssuesUpdatePutJSONRequestBody, reqEditors ...RequestEditorFn) (*IssuesUpdatePutResponse, error) {
	rsp, err := c.IssuesUpdatePut(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssuesUpdatePutResponse(rsp)
}

// IssuesShowPdfWithResponse request returning *IssuesShowPdfResponse
func (c *ClientWithResponses) IssuesShowPdfWithResponse(ctx context.Context, id int, params *IssuesShowPdfParams, reqEditors ...RequestEditorFn) (*IssuesShowPdfResponse, error) {
	rsp, err := c.IssuesShowPdf(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssuesShowPdfResponse(rsp)
}

// IssueRelationsIndexWithResponse request returning *IssueRelationsIndexResponse
func (c *ClientWithResponses) IssueRelationsIndexWithResponse(ctx context.Context, issueId int, params *IssueRelationsIndexParams, reqEditors ...RequestEditorFn) (*IssueRelationsIndexResponse, error) {
	rsp, err := c.IssueRelationsIndex(ctx, issueId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssueRelationsIndexResponse(rsp)
}

// IssueRelationsCreateWithBodyWithResponse request with arbitrary body returning *IssueRelationsCreateResponse
func (c *ClientWithResponses) IssueRelationsCreateWithBodyWithResponse(ctx context.Context, issueId int, params *IssueRelationsCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IssueRelationsCreateResponse, error) {
	rsp, err := c.IssueRelationsCreateWithBody(ctx, issueId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssueRelationsCreateResponse(rsp)
}

func (c *ClientWithResponses) IssueRelationsCreateWithResponse(ctx context.Context, issueId int, params *IssueRelationsCreateParams, body IssueRelationsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*IssueRelationsCreateResponse, error) {
	rsp, err := c.IssueRelationsCreate(ctx, issueId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssueRelationsCreateResponse(rsp)
}

// TimelogCreateIssueWithBodyWithResponse request with arbitrary body returning *TimelogCreateIssueResponse
func (c *ClientWithResponses) TimelogCreateIssueWithBodyWithResponse(ctx context.Context, issueId int, params *TimelogCreateIssueParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TimelogCreateIssueResponse, error) {
	rsp, err := c.TimelogCreateIssueWithBody(ctx, issueId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTimelogCreateIssueResponse(rsp)
}

func (c *ClientWithResponses) TimelogCreateIssueWithResponse(ctx context.Context, issueId int, params *TimelogCreateIssueParams, body TimelogCreateIssueJSONRequestBody, reqEditors ...RequestEditorFn) (*TimelogCreateIssueResponse, error) {
	rsp, err := c.TimelogCreateIssue(ctx, issueId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTimelogCreateIssueResponse(rsp)
}

// WatchersCreateIssueWithBodyWithResponse request with arbitrary body returning *WatchersCreateIssueResponse
func (c *ClientWithResponses) WatchersCreateIssueWithBodyWithResponse(ctx context.Context, issueId int, params *WatchersCreateIssueParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WatchersCreateIssueResponse, error) {
	rsp, err := c.WatchersCreateIssueWithBody(ctx, issueId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWatchersCreateIssueResponse(rsp)
}

func (c *ClientWithResponses) WatchersCreateIssueWithResponse(ctx context.Context, issueId int, params *WatchersCreateIssueParams, body WatchersCreateIssueJSONRequestBody, reqEditors ...RequestEditorFn) (*WatchersCreateIssueResponse, error) {
	rsp, err := c.WatchersCreateIssue(ctx, issueId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWatchersCreateIssueResponse(rsp)
}

// WatchersDestroyIssueWithResponse request returning *WatchersDestroyIssueResponse
func (c *ClientWithResponses) WatchersDestroyIssueWithResponse(ctx context.Context, issueId int, userId int, params *WatchersDestroyIssueParams, reqEditors ...RequestEditorFn) (*WatchersDestroyIssueResponse, error) {
	rsp, err := c.WatchersDestroyIssue(ctx, issueId, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWatchersDestroyIssueResponse(rsp)
}

// JournalsUpdatePatchWithBodyWithResponse request with arbitrary body returning *JournalsUpdatePatchResponse
func (c *ClientWithResponses) JournalsUpdatePatchWithBodyWithResponse(ctx context.Context, id int, params *JournalsUpdatePatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*JournalsUpdatePatchResponse, error) {
	rsp, err := c.JournalsUpdatePatchWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJournalsUpdatePatchResponse(rsp)
}

func (c *ClientWithResponses) JournalsUpdatePatchWithResponse(ctx context.Context, id int, params *JournalsUpdatePatchParams, body JournalsUpdatePatchJSONRequestBody, reqEditors ...RequestEditorFn) (*JournalsUpdatePatchResponse, error) {
	rsp, err := c.JournalsUpdatePatch(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJournalsUpdatePatchResponse(rsp)
}

// JournalsUpdatePutWithBodyWithResponse request with arbitrary body returning *JournalsUpdatePutResponse
func (c *ClientWithResponses) JournalsUpdatePutWithBodyWithResponse(ctx context.Context, id int, params *JournalsUpdatePutParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*JournalsUpdatePutResponse, error) {
	rsp, err := c.JournalsUpdatePutWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJournalsUpdatePutResponse(rsp)
}

func (c *ClientWithResponses) JournalsUpdatePutWithResponse(ctx context.Context, id int, params *JournalsUpdatePutParams, body JournalsUpdatePutJSONRequestBody, reqEditors ...RequestEditorFn) (*JournalsUpdatePutResponse, error) {
	rsp, err := c.JournalsUpdatePut(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJournalsUpdatePutResponse(rsp)
}

// MembersDestroyWithResponse request returning *MembersDestroyResponse
func (c *ClientWithResponses) MembersDestroyWithResponse(ctx context.Context, id int, params *MembersDestroyParams, reqEditors ...RequestEditorFn) (*MembersDestroyResponse, error) {
	rsp, err := c.MembersDestroy(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMembersDestroyResponse(rsp)
}

// MembersShowWithResponse request returning *MembersShowResponse
func (c *ClientWithResponses) MembersShowWithResponse(ctx context.Context, id int, params *MembersShowParams, reqEditors ...RequestEditorFn) (*MembersShowResponse, error) {
	rsp, err := c.MembersShow(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMembersShowResponse(rsp)
}

// MembersUpdatePatchWithBodyWithResponse request with arbitrary body returning *MembersUpdatePatchResponse
func (c *ClientWithResponses) MembersUpdatePatchWithBodyWithResponse(ctx context.Context, id int, params *MembersUpdatePatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MembersUpdatePatchResponse, error) {
	rsp, err := c.MembersUpdatePatchWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMembersUpdatePatchResponse(rsp)
}

func (c *ClientWithResponses) MembersUpdatePatchWithResponse(ctx context.Context, id int, params *MembersUpdatePatchParams, body MembersUpdatePatchJSONRequestBody, reqEditors ...RequestEditorFn) (*MembersUpdatePatchResponse, error) {
	rsp, err := c.MembersUpdatePatch(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMembersUpdatePatchResponse(rsp)
}

// MembersUpdatePutWithBodyWithResponse request with arbitrary body returning *MembersUpdatePutResponse
func (c *ClientWithResponses) MembersUpdatePutWithBodyWithResponse(ctx context.Context, id int, params *MembersUpdatePutParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MembersUpdatePutResponse, error) {
	rsp, err := c.MembersUpdatePutWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMembersUpdatePutResponse(rsp)
}

func (c *ClientWithResponses) MembersUpdatePutWithResponse(ctx context.Context, id int, params *MembersUpdatePutParams, body MembersUpdatePutJSONRequestBody, reqEditors ...RequestEditorFn) (*MembersUpdatePutResponse, error) {
	rsp, err := c.MembersUpdatePut(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMembersUpdatePutResponse(rsp)
}

// MyAccountWithResponse request returning *MyAccountResponse
func (c *ClientWithResponses) MyAccountWithResponse(ctx context.Context, params *MyAccountParams, reqEditors ...RequestEditorFn) (*MyAccountResponse, error) {
	rsp, err := c.MyAccount(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMyAccountResponse(rsp)
}

// MyAccountPutWithBodyWithResponse request with arbitrary body returning *MyAccountPutResponse
func (c *ClientWithResponses) MyAccountPutWithBodyWithResponse(ctx context.Context, params *MyAccountPutParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MyAccountPutResponse, error) {
	rsp, err := c.MyAccountPutWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMyAccountPutResponse(rsp)
}

func (c *ClientWithResponses) MyAccountPutWithResponse(ctx context.Context, params *MyAccountPutParams, body MyAccountPutJSONRequestBody, reqEditors ...RequestEditorFn) (*MyAccountPutResponse, error) {
	rsp, err := c.MyAccountPut(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMyAccountPutResponse(rsp)
}

// NewsIndexWithResponse request returning *NewsIndexResponse
func (c *ClientWithResponses) NewsIndexWithResponse(ctx context.Context, params *NewsIndexParams, reqEditors ...RequestEditorFn) (*NewsIndexResponse, error) {
	rsp, err := c.NewsIndex(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNewsIndexResponse(rsp)
}

// NewsCreateWithBodyWithResponse request with arbitrary body returning *NewsCreateResponse
func (c *ClientWithResponses) NewsCreateWithBodyWithResponse(ctx context.Context, params *NewsCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NewsCreateResponse, error) {
	rsp, err := c.NewsCreateWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNewsCreateResponse(rsp)
}

func (c *ClientWithResponses) NewsCreateWithResponse(ctx context.Context, params *NewsCreateParams, body NewsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*NewsCreateResponse, error) {
	rsp, err := c.NewsCreate(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNewsCreateResponse(rsp)
}

// NewsDestroyWithResponse request returning *NewsDestroyResponse
func (c *ClientWithResponses) NewsDestroyWithResponse(ctx context.Context, id int, params *NewsDestroyParams, reqEditors ...RequestEditorFn) (*NewsDestroyResponse, error) {
	rsp, err := c.NewsDestroy(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNewsDestroyResponse(rsp)
}

// NewsShowWithResponse request returning *NewsShowResponse
func (c *ClientWithResponses) NewsShowWithResponse(ctx context.Context, id int, params *NewsShowParams, reqEditors ...RequestEditorFn) (*NewsShowResponse, error) {
	rsp, err := c.NewsShow(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNewsShowResponse(rsp)
}

// NewsUpdatePatchWithBodyWithResponse request with arbitrary body returning *NewsUpdatePatchResponse
func (c *ClientWithResponses) NewsUpdatePatchWithBodyWithResponse(ctx context.Context, id int, params *NewsUpdatePatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NewsUpdatePatchResponse, error) {
	rsp, err := c.NewsUpdatePatchWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNewsUpdatePatchResponse(rsp)
}

func (c *ClientWithResponses) NewsUpdatePatchWithResponse(ctx context.Context, id int, params *NewsUpdatePatchParams, body NewsUpdatePatchJSONRequestBody, reqEditors ...RequestEditorFn) (*NewsUpdatePatchResponse, error) {
	rsp, err := c.NewsUpdatePatch(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNewsUpdatePatchResponse(rsp)
}

// NewsUpdatePutWithBodyWithResponse request with arbitrary body returning *NewsUpdatePutResponse
func (c *ClientWithResponses) NewsUpdatePutWithBodyWithResponse(ctx context.Context, id int, params *NewsUpdatePutParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NewsUpdatePutResponse, error) {
	rsp, err := c.NewsUpdatePutWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNewsUpdatePutResponse(rsp)
}

func (c *ClientWithResponses) NewsUpdatePutWithResponse(ctx context.Context, id int, params *NewsUpdatePutParams, body NewsUpdatePutJSONRequestBody, reqEditors ...RequestEditorFn) (*NewsUpdatePutResponse, error) {
	rsp, err := c.NewsUpdatePut(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNewsUpdatePutResponse(rsp)
}

// ProjectsIndexCsvWithResponse request returning *ProjectsIndexCsvResponse
func (c *ClientWithResponses) ProjectsIndexCsvWithResponse(ctx context.Context, params *ProjectsIndexCsvParams, reqEditors ...RequestEditorFn) (*ProjectsIndexCsvResponse, error) {
	rsp, err := c.ProjectsIndexCsv(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectsIndexCsvResponse(rsp)
}

// ProjectsIndexWithResponse request returning *ProjectsIndexResponse
func (c *ClientWithResponses) ProjectsIndexWithResponse(ctx context.Context, params *ProjectsIndexParams, reqEditors ...RequestEditorFn) (*ProjectsIndexResponse, error) {
	rsp, err := c.ProjectsIndex(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectsIndexResponse(rsp)
}

// ProjectsCreateWithBodyWithResponse request with arbitrary body returning *ProjectsCreateResponse
func (c *ClientWithResponses) ProjectsCreateWithBodyWithResponse(ctx context.Context, params *ProjectsCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProjectsCreateResponse, error) {
	rsp, err := c.ProjectsCreateWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectsCreateResponse(rsp)
}

func (c *ClientWithResponses) ProjectsCreateWithResponse(ctx context.Context, params *ProjectsCreateParams, body ProjectsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ProjectsCreateResponse, error) {
	rsp, err := c.ProjectsCreate(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectsCreateResponse(rsp)
}

// ProjectsDestroyWithResponse request returning *ProjectsDestroyResponse
func (c *ClientWithResponses) ProjectsDestroyWithResponse(ctx context.Context, id string, params *ProjectsDestroyParams, reqEditors ...RequestEditorFn) (*ProjectsDestroyResponse, error) {
	rsp, err := c.ProjectsDestroy(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectsDestroyResponse(rsp)
}

// ProjectsShowWithResponse request returning *ProjectsShowResponse
func (c *ClientWithResponses) ProjectsShowWithResponse(ctx context.Context, id string, params *ProjectsShowParams, reqEditors ...RequestEditorFn) (*ProjectsShowResponse, error) {
	rsp, err := c.ProjectsShow(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectsShowResponse(rsp)
}

// ProjectsUpdatePatchWithBodyWithResponse request with arbitrary body returning *ProjectsUpdatePatchResponse
func (c *ClientWithResponses) ProjectsUpdatePatchWithBodyWithResponse(ctx context.Context, id string, params *ProjectsUpdatePatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProjectsUpdatePatchResponse, error) {
	rsp, err := c.ProjectsUpdatePatchWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectsUpdatePatchResponse(rsp)
}

func (c *ClientWithResponses) ProjectsUpdatePatchWithResponse(ctx context.Context, id string, params *ProjectsUpdatePatchParams, body ProjectsUpdatePatchJSONRequestBody, reqEditors ...RequestEditorFn) (*ProjectsUpdatePatchResponse, error) {
	rsp, err := c.ProjectsUpdatePatch(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectsUpdatePatchResponse(rsp)
}

// ProjectsUpdatePutWithBodyWithResponse request with arbitrary body returning *ProjectsUpdatePutResponse
func (c *ClientWithResponses) ProjectsUpdatePutWithBodyWithResponse(ctx context.Context, id string, params *ProjectsUpdatePutParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProjectsUpdatePutResponse, error) {
	rsp, err := c.ProjectsUpdatePutWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectsUpdatePutResponse(rsp)
}

func (c *ClientWithResponses) ProjectsUpdatePutWithResponse(ctx context.Context, id string, params *ProjectsUpdatePutParams, body ProjectsUpdatePutJSONRequestBody, reqEditors ...RequestEditorFn) (*ProjectsUpdatePutResponse, error) {
	rsp, err := c.ProjectsUpdatePut(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectsUpdatePutResponse(rsp)
}

// ProjectsArchivePostWithResponse request returning *ProjectsArchivePostResponse
func (c *ClientWithResponses) ProjectsArchivePostWithResponse(ctx context.Context, id string, params *ProjectsArchivePostParams, reqEditors ...RequestEditorFn) (*ProjectsArchivePostResponse, error) {
	rsp, err := c.ProjectsArchivePost(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectsArchivePostResponse(rsp)
}

// ProjectsArchivePutWithResponse request returning *ProjectsArchivePutResponse
func (c *ClientWithResponses) ProjectsArchivePutWithResponse(ctx context.Context, id string, params *ProjectsArchivePutParams, reqEditors ...RequestEditorFn) (*ProjectsArchivePutResponse, error) {
	rsp, err := c.ProjectsArchivePut(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectsArchivePutResponse(rsp)
}

// RepositoriesAddRelatedIssueWithBodyWithResponse request with arbitrary body returning *RepositoriesAddRelatedIssueResponse
func (c *ClientWithResponses) RepositoriesAddRelatedIssueWithBodyWithResponse(ctx context.Context, id string, repositoryId string, rev string, params *RepositoriesAddRelatedIssueParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RepositoriesAddRelatedIssueResponse, error) {
	rsp, err := c.RepositoriesAddRelatedIssueWithBody(ctx, id, repositoryId, rev, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRepositoriesAddRelatedIssueResponse(rsp)
}

func (c *ClientWithResponses) RepositoriesAddRelatedIssueWithResponse(ctx context.Context, id string, repositoryId string, rev string, params *RepositoriesAddRelatedIssueParams, body RepositoriesAddRelatedIssueJSONRequestBody, reqEditors ...RequestEditorFn) (*RepositoriesAddRelatedIssueResponse, error) {
	rsp, err := c.RepositoriesAddRelatedIssue(ctx, id, repositoryId, rev, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRepositoriesAddRelatedIssueResponse(rsp)
}

// RepositoriesRemoveRelatedIssueWithResponse request returning *RepositoriesRemoveRelatedIssueResponse
func (c *ClientWithResponses) RepositoriesRemoveRelatedIssueWithResponse(ctx context.Context, id string, repositoryId string, rev string, issueId int, params *RepositoriesRemoveRelatedIssueParams, reqEditors ...RequestEditorFn) (*RepositoriesRemoveRelatedIssueResponse, error) {
	rsp, err := c.RepositoriesRemoveRelatedIssue(ctx, id, repositoryId, rev, issueId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRepositoriesRemoveRelatedIssueResponse(rsp)
}

// ProjectsUnarchivePostWithResponse request returning *ProjectsUnarchivePostResponse
func (c *ClientWithResponses) ProjectsUnarchivePostWithResponse(ctx context.Context, id string, params *ProjectsUnarchivePostParams, reqEditors ...RequestEditorFn) (*ProjectsUnarchivePostResponse, error) {
	rsp, err := c.ProjectsUnarchivePost(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectsUnarchivePostResponse(rsp)
}

// ProjectsUnarchivePutWithResponse request returning *ProjectsUnarchivePutResponse
func (c *ClientWithResponses) ProjectsUnarchivePutWithResponse(ctx context.Context, id string, params *ProjectsUnarchivePutParams, reqEditors ...RequestEditorFn) (*ProjectsUnarchivePutResponse, error) {
	rsp, err := c.ProjectsUnarchivePut(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectsUnarchivePutResponse(rsp)
}

// FilesIndexWithResponse request returning *FilesIndexResponse
func (c *ClientWithResponses) FilesIndexWithResponse(ctx context.Context, projectId string, params *FilesIndexParams, reqEditors ...RequestEditorFn) (*FilesIndexResponse, error) {
	rsp, err := c.FilesIndex(ctx, projectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFilesIndexResponse(rsp)
}

// FilesCreateWithBodyWithResponse request with arbitrary body returning *FilesCreateResponse
func (c *ClientWithResponses) FilesCreateWithBodyWithResponse(ctx context.Context, projectId string, params *FilesCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FilesCreateResponse, error) {
	rsp, err := c.FilesCreateWithBody(ctx, projectId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFilesCreateResponse(rsp)
}

func (c *ClientWithResponses) FilesCreateWithResponse(ctx context.Context, projectId string, params *FilesCreateParams, body FilesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*FilesCreateResponse, error) {
	rsp, err := c.FilesCreate(ctx, projectId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFilesCreateResponse(rsp)
}

// IssueCategoriesIndexWithResponse request returning *IssueCategoriesIndexResponse
func (c *ClientWithResponses) IssueCategoriesIndexWithResponse(ctx context.Context, projectId string, params *IssueCategoriesIndexParams, reqEditors ...RequestEditorFn) (*IssueCategoriesIndexResponse, error) {
	rsp, err := c.IssueCategoriesIndex(ctx, projectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssueCategoriesIndexResponse(rsp)
}

// IssueCategoriesCreateWithBodyWithResponse request with arbitrary body returning *IssueCategoriesCreateResponse
func (c *ClientWithResponses) IssueCategoriesCreateWithBodyWithResponse(ctx context.Context, projectId string, params *IssueCategoriesCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IssueCategoriesCreateResponse, error) {
	rsp, err := c.IssueCategoriesCreateWithBody(ctx, projectId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssueCategoriesCreateResponse(rsp)
}

func (c *ClientWithResponses) IssueCategoriesCreateWithResponse(ctx context.Context, projectId string, params *IssueCategoriesCreateParams, body IssueCategoriesCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*IssueCategoriesCreateResponse, error) {
	rsp, err := c.IssueCategoriesCreate(ctx, projectId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssueCategoriesCreateResponse(rsp)
}

// IssuesIndexProjectCsvWithResponse request returning *IssuesIndexProjectCsvResponse
func (c *ClientWithResponses) IssuesIndexProjectCsvWithResponse(ctx context.Context, projectId string, params *IssuesIndexProjectCsvParams, reqEditors ...RequestEditorFn) (*IssuesIndexProjectCsvResponse, error) {
	rsp, err := c.IssuesIndexProjectCsv(ctx, projectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssuesIndexProjectCsvResponse(rsp)
}

// IssuesIndexProjectWithResponse request returning *IssuesIndexProjectResponse
func (c *ClientWithResponses) IssuesIndexProjectWithResponse(ctx context.Context, projectId string, params *IssuesIndexProjectParams, reqEditors ...RequestEditorFn) (*IssuesIndexProjectResponse, error) {
	rsp, err := c.IssuesIndexProject(ctx, projectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssuesIndexProjectResponse(rsp)
}

// IssuesCreateProjectWithBodyWithResponse request with arbitrary body returning *IssuesCreateProjectResponse
func (c *ClientWithResponses) IssuesCreateProjectWithBodyWithResponse(ctx context.Context, projectId string, params *IssuesCreateProjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IssuesCreateProjectResponse, error) {
	rsp, err := c.IssuesCreateProjectWithBody(ctx, projectId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssuesCreateProjectResponse(rsp)
}

func (c *ClientWithResponses) IssuesCreateProjectWithResponse(ctx context.Context, projectId string, params *IssuesCreateProjectParams, body IssuesCreateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*IssuesCreateProjectResponse, error) {
	rsp, err := c.IssuesCreateProject(ctx, projectId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssuesCreateProjectResponse(rsp)
}

// IssuesIndexProjectPdfWithResponse request returning *IssuesIndexProjectPdfResponse
func (c *ClientWithResponses) IssuesIndexProjectPdfWithResponse(ctx context.Context, projectId string, params *IssuesIndexProjectPdfParams, reqEditors ...RequestEditorFn) (*IssuesIndexProjectPdfResponse, error) {
	rsp, err := c.IssuesIndexProjectPdf(ctx, projectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssuesIndexProjectPdfResponse(rsp)
}

// GanttsShowProjectPdfWithResponse request returning *GanttsShowProjectPdfResponse
func (c *ClientWithResponses) GanttsShowProjectPdfWithResponse(ctx context.Context, projectId string, params *GanttsShowProjectPdfParams, reqEditors ...RequestEditorFn) (*GanttsShowProjectPdfResponse, error) {
	rsp, err := c.GanttsShowProjectPdf(ctx, projectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGanttsShowProjectPdfResponse(rsp)
}

// GanttsShowProjectPngWithResponse request returning *GanttsShowProjectPngResponse
func (c *ClientWithResponses) GanttsShowProjectPngWithResponse(ctx context.Context, projectId string, params *GanttsShowProjectPngParams, reqEditors ...RequestEditorFn) (*GanttsShowProjectPngResponse, error) {
	rsp, err := c.GanttsShowProjectPng(ctx, projectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGanttsShowProjectPngResponse(rsp)
}

// MembersIndexWithResponse request returning *MembersIndexResponse
func (c *ClientWithResponses) MembersIndexWithResponse(ctx context.Context, projectId string, params *MembersIndexParams, reqEditors ...RequestEditorFn) (*MembersIndexResponse, error) {
	rsp, err := c.MembersIndex(ctx, projectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMembersIndexResponse(rsp)
}

// MembersCreateWithBodyWithResponse request with arbitrary body returning *MembersCreateResponse
func (c *ClientWithResponses) MembersCreateWithBodyWithResponse(ctx context.Context, projectId string, params *MembersCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MembersCreateResponse, error) {
	rsp, err := c.MembersCreateWithBody(ctx, projectId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMembersCreateResponse(rsp)
}

func (c *ClientWithResponses) MembersCreateWithResponse(ctx context.Context, projectId string, params *MembersCreateParams, body MembersCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*MembersCreateResponse, error) {
	rsp, err := c.MembersCreate(ctx, projectId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMembersCreateResponse(rsp)
}

// NewsIndexProjectWithResponse request returning *NewsIndexProjectResponse
func (c *ClientWithResponses) NewsIndexProjectWithResponse(ctx context.Context, projectId string, params *NewsIndexProjectParams, reqEditors ...RequestEditorFn) (*NewsIndexProjectResponse, error) {
	rsp, err := c.NewsIndexProject(ctx, projectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNewsIndexProjectResponse(rsp)
}

// NewsCreateProjectWithBodyWithResponse request with arbitrary body returning *NewsCreateProjectResponse
func (c *ClientWithResponses) NewsCreateProjectWithBodyWithResponse(ctx context.Context, projectId string, params *NewsCreateProjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NewsCreateProjectResponse, error) {
	rsp, err := c.NewsCreateProjectWithBody(ctx, projectId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNewsCreateProjectResponse(rsp)
}

func (c *ClientWithResponses) NewsCreateProjectWithResponse(ctx context.Context, projectId string, params *NewsCreateProjectParams, body NewsCreateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*NewsCreateProjectResponse, error) {
	rsp, err := c.NewsCreateProject(ctx, projectId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNewsCreateProjectResponse(rsp)
}

// SearchIndexProjectWithResponse request returning *SearchIndexProjectResponse
func (c *ClientWithResponses) SearchIndexProjectWithResponse(ctx context.Context, projectId string, params *SearchIndexProjectParams, reqEditors ...RequestEditorFn) (*SearchIndexProjectResponse, error) {
	rsp, err := c.SearchIndexProject(ctx, projectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchIndexProjectResponse(rsp)
}

// TimelogIndexProjectCsvWithResponse request returning *TimelogIndexProjectCsvResponse
func (c *ClientWithResponses) TimelogIndexProjectCsvWithResponse(ctx context.Context, projectId string, params *TimelogIndexProjectCsvParams, reqEditors ...RequestEditorFn) (*TimelogIndexProjectCsvResponse, error) {
	rsp, err := c.TimelogIndexProjectCsv(ctx, projectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTimelogIndexProjectCsvResponse(rsp)
}

// TimelogIndexProjectWithResponse request returning *TimelogIndexProjectResponse
func (c *ClientWithResponses) TimelogIndexProjectWithResponse(ctx context.Context, projectId string, params *TimelogIndexProjectParams, reqEditors ...RequestEditorFn) (*TimelogIndexProjectResponse, error) {
	rsp, err := c.TimelogIndexProject(ctx, projectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTimelogIndexProjectResponse(rsp)
}

// TimelogCreateProjectWithBodyWithResponse request with arbitrary body returning *TimelogCreateProjectResponse
func (c *ClientWithResponses) TimelogCreateProjectWithBodyWithResponse(ctx context.Context, projectId string, params *TimelogCreateProjectParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TimelogCreateProjectResponse, error) {
	rsp, err := c.TimelogCreateProjectWithBody(ctx, projectId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTimelogCreateProjectResponse(rsp)
}

func (c *ClientWithResponses) TimelogCreateProjectWithResponse(ctx context.Context, projectId string, params *TimelogCreateProjectParams, body TimelogCreateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*TimelogCreateProjectResponse, error) {
	rsp, err := c.TimelogCreateProject(ctx, projectId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTimelogCreateProjectResponse(rsp)
}

// VersionsIndexWithResponse request returning *VersionsIndexResponse
func (c *ClientWithResponses) VersionsIndexWithResponse(ctx context.Context, projectId string, params *VersionsIndexParams, reqEditors ...RequestEditorFn) (*VersionsIndexResponse, error) {
	rsp, err := c.VersionsIndex(ctx, projectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVersionsIndexResponse(rsp)
}

// VersionsCreateWithBodyWithResponse request with arbitrary body returning *VersionsCreateResponse
func (c *ClientWithResponses) VersionsCreateWithBodyWithResponse(ctx context.Context, projectId string, params *VersionsCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VersionsCreateResponse, error) {
	rsp, err := c.VersionsCreateWithBody(ctx, projectId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVersionsCreateResponse(rsp)
}

func (c *ClientWithResponses) VersionsCreateWithResponse(ctx context.Context, projectId string, params *VersionsCreateParams, body VersionsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*VersionsCreateResponse, error) {
	rsp, err := c.VersionsCreate(ctx, projectId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVersionsCreateResponse(rsp)
}

// WikiShowRootWithResponse request returning *WikiShowRootResponse
func (c *ClientWithResponses) WikiShowRootWithResponse(ctx context.Context, projectId string, params *WikiShowRootParams, reqEditors ...RequestEditorFn) (*WikiShowRootResponse, error) {
	rsp, err := c.WikiShowRoot(ctx, projectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWikiShowRootResponse(rsp)
}

// WikiIndexWithResponse request returning *WikiIndexResponse
func (c *ClientWithResponses) WikiIndexWithResponse(ctx context.Context, projectId string, params *WikiIndexParams, reqEditors ...RequestEditorFn) (*WikiIndexResponse, error) {
	rsp, err := c.WikiIndex(ctx, projectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWikiIndexResponse(rsp)
}

// WikiDestroyWithResponse request returning *WikiDestroyResponse
func (c *ClientWithResponses) WikiDestroyWithResponse(ctx context.Context, projectId string, id string, params *WikiDestroyParams, reqEditors ...RequestEditorFn) (*WikiDestroyResponse, error) {
	rsp, err := c.WikiDestroy(ctx, projectId, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWikiDestroyResponse(rsp)
}

// WikiShowWithResponse request returning *WikiShowResponse
func (c *ClientWithResponses) WikiShowWithResponse(ctx context.Context, projectId string, id string, params *WikiShowParams, reqEditors ...RequestEditorFn) (*WikiShowResponse, error) {
	rsp, err := c.WikiShow(ctx, projectId, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWikiShowResponse(rsp)
}

// WikiUpdatePatchWithBodyWithResponse request with arbitrary body returning *WikiUpdatePatchResponse
func (c *ClientWithResponses) WikiUpdatePatchWithBodyWithResponse(ctx context.Context, projectId string, id string, params *WikiUpdatePatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WikiUpdatePatchResponse, error) {
	rsp, err := c.WikiUpdatePatchWithBody(ctx, projectId, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWikiUpdatePatchResponse(rsp)
}

func (c *ClientWithResponses) WikiUpdatePatchWithResponse(ctx context.Context, projectId string, id string, params *WikiUpdatePatchParams, body WikiUpdatePatchJSONRequestBody, reqEditors ...RequestEditorFn) (*WikiUpdatePatchResponse, error) {
	rsp, err := c.WikiUpdatePatch(ctx, projectId, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWikiUpdatePatchResponse(rsp)
}

// WikiUpdatePutWithBodyWithResponse request with arbitrary body returning *WikiUpdatePutResponse
func (c *ClientWithResponses) WikiUpdatePutWithBodyWithResponse(ctx context.Context, projectId string, id string, params *WikiUpdatePutParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WikiUpdatePutResponse, error) {
	rsp, err := c.WikiUpdatePutWithBody(ctx, projectId, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWikiUpdatePutResponse(rsp)
}

func (c *ClientWithResponses) WikiUpdatePutWithResponse(ctx context.Context, projectId string, id string, params *WikiUpdatePutParams, body WikiUpdatePutJSONRequestBody, reqEditors ...RequestEditorFn) (*WikiUpdatePutResponse, error) {
	rsp, err := c.WikiUpdatePut(ctx, projectId, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWikiUpdatePutResponse(rsp)
}

// WikiShowPdfWithResponse request returning *WikiShowPdfResponse
func (c *ClientWithResponses) WikiShowPdfWithResponse(ctx context.Context, projectId string, id string, params *WikiShowPdfParams, reqEditors ...RequestEditorFn) (*WikiShowPdfResponse, error) {
	rsp, err := c.WikiShowPdf(ctx, projectId, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWikiShowPdfResponse(rsp)
}

// WikiShowTxtWithResponse request returning *WikiShowTxtResponse
func (c *ClientWithResponses) WikiShowTxtWithResponse(ctx context.Context, projectId string, id string, params *WikiShowTxtParams, reqEditors ...RequestEditorFn) (*WikiShowTxtResponse, error) {
	rsp, err := c.WikiShowTxt(ctx, projectId, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWikiShowTxtResponse(rsp)
}

// WikiShowVersionWithResponse request returning *WikiShowVersionResponse
func (c *ClientWithResponses) WikiShowVersionWithResponse(ctx context.Context, projectId string, id string, version int, params *WikiShowVersionParams, reqEditors ...RequestEditorFn) (*WikiShowVersionResponse, error) {
	rsp, err := c.WikiShowVersion(ctx, projectId, id, version, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWikiShowVersionResponse(rsp)
}

// WikiShowVersionPdfWithResponse request returning *WikiShowVersionPdfResponse
func (c *ClientWithResponses) WikiShowVersionPdfWithResponse(ctx context.Context, projectId string, id string, version int, params *WikiShowVersionPdfParams, reqEditors ...RequestEditorFn) (*WikiShowVersionPdfResponse, error) {
	rsp, err := c.WikiShowVersionPdf(ctx, projectId, id, version, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWikiShowVersionPdfResponse(rsp)
}

// WikiShowVersionTxtWithResponse request returning *WikiShowVersionTxtResponse
func (c *ClientWithResponses) WikiShowVersionTxtWithResponse(ctx context.Context, projectId string, id string, version int, params *WikiShowVersionTxtParams, reqEditors ...RequestEditorFn) (*WikiShowVersionTxtResponse, error) {
	rsp, err := c.WikiShowVersionTxt(ctx, projectId, id, version, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWikiShowVersionTxtResponse(rsp)
}

// QueriesIndexWithResponse request returning *QueriesIndexResponse
func (c *ClientWithResponses) QueriesIndexWithResponse(ctx context.Context, params *QueriesIndexParams, reqEditors ...RequestEditorFn) (*QueriesIndexResponse, error) {
	rsp, err := c.QueriesIndex(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQueriesIndexResponse(rsp)
}

// IssueRelationsDestroyWithResponse request returning *IssueRelationsDestroyResponse
func (c *ClientWithResponses) IssueRelationsDestroyWithResponse(ctx context.Context, id int, params *IssueRelationsDestroyParams, reqEditors ...RequestEditorFn) (*IssueRelationsDestroyResponse, error) {
	rsp, err := c.IssueRelationsDestroy(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssueRelationsDestroyResponse(rsp)
}

// IssueRelationsShowWithResponse request returning *IssueRelationsShowResponse
func (c *ClientWithResponses) IssueRelationsShowWithResponse(ctx context.Context, id int, params *IssueRelationsShowParams, reqEditors ...RequestEditorFn) (*IssueRelationsShowResponse, error) {
	rsp, err := c.IssueRelationsShow(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssueRelationsShowResponse(rsp)
}

// RolesIndexWithResponse request returning *RolesIndexResponse
func (c *ClientWithResponses) RolesIndexWithResponse(ctx context.Context, params *RolesIndexParams, reqEditors ...RequestEditorFn) (*RolesIndexResponse, error) {
	rsp, err := c.RolesIndex(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRolesIndexResponse(rsp)
}

// RolesShowWithResponse request returning *RolesShowResponse
func (c *ClientWithResponses) RolesShowWithResponse(ctx context.Context, id int, params *RolesShowParams, reqEditors ...RequestEditorFn) (*RolesShowResponse, error) {
	rsp, err := c.RolesShow(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRolesShowResponse(rsp)
}

// SearchIndexWithResponse request returning *SearchIndexResponse
func (c *ClientWithResponses) SearchIndexWithResponse(ctx context.Context, params *SearchIndexParams, reqEditors ...RequestEditorFn) (*SearchIndexResponse, error) {
	rsp, err := c.SearchIndex(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchIndexResponse(rsp)
}

// TimelogIndexCsvWithResponse request returning *TimelogIndexCsvResponse
func (c *ClientWithResponses) TimelogIndexCsvWithResponse(ctx context.Context, params *TimelogIndexCsvParams, reqEditors ...RequestEditorFn) (*TimelogIndexCsvResponse, error) {
	rsp, err := c.TimelogIndexCsv(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTimelogIndexCsvResponse(rsp)
}

// TimelogIndexWithResponse request returning *TimelogIndexResponse
func (c *ClientWithResponses) TimelogIndexWithResponse(ctx context.Context, params *TimelogIndexParams, reqEditors ...RequestEditorFn) (*TimelogIndexResponse, error) {
	rsp, err := c.TimelogIndex(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTimelogIndexResponse(rsp)
}

// TimelogCreateWithBodyWithResponse request with arbitrary body returning *TimelogCreateResponse
func (c *ClientWithResponses) TimelogCreateWithBodyWithResponse(ctx context.Context, params *TimelogCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TimelogCreateResponse, error) {
	rsp, err := c.TimelogCreateWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTimelogCreateResponse(rsp)
}

func (c *ClientWithResponses) TimelogCreateWithResponse(ctx context.Context, params *TimelogCreateParams, body TimelogCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*TimelogCreateResponse, error) {
	rsp, err := c.TimelogCreate(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTimelogCreateResponse(rsp)
}

// TimelogDestroyWithResponse request returning *TimelogDestroyResponse
func (c *ClientWithResponses) TimelogDestroyWithResponse(ctx context.Context, id int, params *TimelogDestroyParams, reqEditors ...RequestEditorFn) (*TimelogDestroyResponse, error) {
	rsp, err := c.TimelogDestroy(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTimelogDestroyResponse(rsp)
}

// TimelogShowWithResponse request returning *TimelogShowResponse
func (c *ClientWithResponses) TimelogShowWithResponse(ctx context.Context, id int, params *TimelogShowParams, reqEditors ...RequestEditorFn) (*TimelogShowResponse, error) {
	rsp, err := c.TimelogShow(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTimelogShowResponse(rsp)
}

// TimelogUpdatePatchWithBodyWithResponse request with arbitrary body returning *TimelogUpdatePatchResponse
func (c *ClientWithResponses) TimelogUpdatePatchWithBodyWithResponse(ctx context.Context, id int, params *TimelogUpdatePatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TimelogUpdatePatchResponse, error) {
	rsp, err := c.TimelogUpdatePatchWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTimelogUpdatePatchResponse(rsp)
}

func (c *ClientWithResponses) TimelogUpdatePatchWithResponse(ctx context.Context, id int, params *TimelogUpdatePatchParams, body TimelogUpdatePatchJSONRequestBody, reqEditors ...RequestEditorFn) (*TimelogUpdatePatchResponse, error) {
	rsp, err := c.TimelogUpdatePatch(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTimelogUpdatePatchResponse(rsp)
}

// TimelogUpdatePutWithBodyWithResponse request with arbitrary body returning *TimelogUpdatePutResponse
func (c *ClientWithResponses) TimelogUpdatePutWithBodyWithResponse(ctx context.Context, id int, params *TimelogUpdatePutParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TimelogUpdatePutResponse, error) {
	rsp, err := c.TimelogUpdatePutWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTimelogUpdatePutResponse(rsp)
}

func (c *ClientWithResponses) TimelogUpdatePutWithResponse(ctx context.Context, id int, params *TimelogUpdatePutParams, body TimelogUpdatePutJSONRequestBody, reqEditors ...RequestEditorFn) (*TimelogUpdatePutResponse, error) {
	rsp, err := c.TimelogUpdatePut(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTimelogUpdatePutResponse(rsp)
}

// TrackersIndexWithResponse request returning *TrackersIndexResponse
func (c *ClientWithResponses) TrackersIndexWithResponse(ctx context.Context, params *TrackersIndexParams, reqEditors ...RequestEditorFn) (*TrackersIndexResponse, error) {
	rsp, err := c.TrackersIndex(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTrackersIndexResponse(rsp)
}

// AttachmentsUploadWithBodyWithResponse request with arbitrary body returning *AttachmentsUploadResponse
func (c *ClientWithResponses) AttachmentsUploadWithBodyWithResponse(ctx context.Context, params *AttachmentsUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachmentsUploadResponse, error) {
	rsp, err := c.AttachmentsUploadWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachmentsUploadResponse(rsp)
}

// UsersIndexCsvWithResponse request returning *UsersIndexCsvResponse
func (c *ClientWithResponses) UsersIndexCsvWithResponse(ctx context.Context, params *UsersIndexCsvParams, reqEditors ...RequestEditorFn) (*UsersIndexCsvResponse, error) {
	rsp, err := c.UsersIndexCsv(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersIndexCsvResponse(rsp)
}

// UsersIndexWithResponse request returning *UsersIndexResponse
func (c *ClientWithResponses) UsersIndexWithResponse(ctx context.Context, params *UsersIndexParams, reqEditors ...RequestEditorFn) (*UsersIndexResponse, error) {
	rsp, err := c.UsersIndex(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersIndexResponse(rsp)
}

// UsersCreateWithBodyWithResponse request with arbitrary body returning *UsersCreateResponse
func (c *ClientWithResponses) UsersCreateWithBodyWithResponse(ctx context.Context, params *UsersCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UsersCreateResponse, error) {
	rsp, err := c.UsersCreateWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersCreateResponse(rsp)
}

func (c *ClientWithResponses) UsersCreateWithResponse(ctx context.Context, params *UsersCreateParams, body UsersCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*UsersCreateResponse, error) {
	rsp, err := c.UsersCreate(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersCreateResponse(rsp)
}

// UsersDestroyWithResponse request returning *UsersDestroyResponse
func (c *ClientWithResponses) UsersDestroyWithResponse(ctx context.Context, id string, params *UsersDestroyParams, reqEditors ...RequestEditorFn) (*UsersDestroyResponse, error) {
	rsp, err := c.UsersDestroy(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersDestroyResponse(rsp)
}

// UsersShowWithResponse request returning *UsersShowResponse
func (c *ClientWithResponses) UsersShowWithResponse(ctx context.Context, id string, params *UsersShowParams, reqEditors ...RequestEditorFn) (*UsersShowResponse, error) {
	rsp, err := c.UsersShow(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersShowResponse(rsp)
}

// UsersUpdatePatchWithBodyWithResponse request with arbitrary body returning *UsersUpdatePatchResponse
func (c *ClientWithResponses) UsersUpdatePatchWithBodyWithResponse(ctx context.Context, id string, params *UsersUpdatePatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UsersUpdatePatchResponse, error) {
	rsp, err := c.UsersUpdatePatchWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersUpdatePatchResponse(rsp)
}

func (c *ClientWithResponses) UsersUpdatePatchWithResponse(ctx context.Context, id string, params *UsersUpdatePatchParams, body UsersUpdatePatchJSONRequestBody, reqEditors ...RequestEditorFn) (*UsersUpdatePatchResponse, error) {
	rsp, err := c.UsersUpdatePatch(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersUpdatePatchResponse(rsp)
}

// UsersUpdatePutWithBodyWithResponse request with arbitrary body returning *UsersUpdatePutResponse
func (c *ClientWithResponses) UsersUpdatePutWithBodyWithResponse(ctx context.Context, id string, params *UsersUpdatePutParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UsersUpdatePutResponse, error) {
	rsp, err := c.UsersUpdatePutWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersUpdatePutResponse(rsp)
}

func (c *ClientWithResponses) UsersUpdatePutWithResponse(ctx context.Context, id string, params *UsersUpdatePutParams, body UsersUpdatePutJSONRequestBody, reqEditors ...RequestEditorFn) (*UsersUpdatePutResponse, error) {
	rsp, err := c.UsersUpdatePut(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersUpdatePutResponse(rsp)
}

// VersionsDestroyWithResponse request returning *VersionsDestroyResponse
func (c *ClientWithResponses) VersionsDestroyWithResponse(ctx context.Context, id int, params *VersionsDestroyParams, reqEditors ...RequestEditorFn) (*VersionsDestroyResponse, error) {
	rsp, err := c.VersionsDestroy(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVersionsDestroyResponse(rsp)
}

// VersionsShowWithResponse request returning *VersionsShowResponse
func (c *ClientWithResponses) VersionsShowWithResponse(ctx context.Context, id int, params *VersionsShowParams, reqEditors ...RequestEditorFn) (*VersionsShowResponse, error) {
	rsp, err := c.VersionsShow(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVersionsShowResponse(rsp)
}

// VersionsUpdatePatchWithBodyWithResponse request with arbitrary body returning *VersionsUpdatePatchResponse
func (c *ClientWithResponses) VersionsUpdatePatchWithBodyWithResponse(ctx context.Context, id int, params *VersionsUpdatePatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VersionsUpdatePatchResponse, error) {
	rsp, err := c.VersionsUpdatePatchWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVersionsUpdatePatchResponse(rsp)
}

func (c *ClientWithResponses) VersionsUpdatePatchWithResponse(ctx context.Context, id int, params *VersionsUpdatePatchParams, body VersionsUpdatePatchJSONRequestBody, reqEditors ...RequestEditorFn) (*VersionsUpdatePatchResponse, error) {
	rsp, err := c.VersionsUpdatePatch(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVersionsUpdatePatchResponse(rsp)
}

// VersionsUpdatePutWithBodyWithResponse request with arbitrary body returning *VersionsUpdatePutResponse
func (c *ClientWithResponses) VersionsUpdatePutWithBodyWithResponse(ctx context.Context, id int, params *VersionsUpdatePutParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VersionsUpdatePutResponse, error) {
	rsp, err := c.VersionsUpdatePutWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVersionsUpdatePutResponse(rsp)
}

func (c *ClientWithResponses) VersionsUpdatePutWithResponse(ctx context.Context, id int, params *VersionsUpdatePutParams, body VersionsUpdatePutJSONRequestBody, reqEditors ...RequestEditorFn) (*VersionsUpdatePutResponse, error) {
	rsp, err := c.VersionsUpdatePut(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVersionsUpdatePutResponse(rsp)
}

// VersionsShowTxtWithResponse request returning *VersionsShowTxtResponse
func (c *ClientWithResponses) VersionsShowTxtWithResponse(ctx context.Context, id int, params *VersionsShowTxtParams, reqEditors ...RequestEditorFn) (*VersionsShowTxtResponse, error) {
	rsp, err := c.VersionsShowTxt(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVersionsShowTxtResponse(rsp)
}

// WatchersDestroyWithResponse request returning *WatchersDestroyResponse
func (c *ClientWithResponses) WatchersDestroyWithResponse(ctx context.Context, params *WatchersDestroyParams, reqEditors ...RequestEditorFn) (*WatchersDestroyResponse, error) {
	rsp, err := c.WatchersDestroy(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWatchersDestroyResponse(rsp)
}

// WatchersCreateWithBodyWithResponse request with arbitrary body returning *WatchersCreateResponse
func (c *ClientWithResponses) WatchersCreateWithBodyWithResponse(ctx context.Context, params *WatchersCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WatchersCreateResponse, error) {
	rsp, err := c.WatchersCreateWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWatchersCreateResponse(rsp)
}

func (c *ClientWithResponses) WatchersCreateWithResponse(ctx context.Context, params *WatchersCreateParams, body WatchersCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*WatchersCreateResponse, error) {
	rsp, err := c.WatchersCreate(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWatchersCreateResponse(rsp)
}

// ParseAttachmentsDownloadResponse parses an HTTP response from a AttachmentsDownloadWithResponse call
func ParseAttachmentsDownloadResponse(rsp *http.Response) (*AttachmentsDownloadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AttachmentsDownloadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAttachmentsThumbnailResponse parses an HTTP response from a AttachmentsThumbnailWithResponse call
func ParseAttachmentsThumbnailResponse(rsp *http.Response) (*AttachmentsThumbnailResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AttachmentsThumbnailResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAttachmentsThumbnailSizeResponse parses an HTTP response from a AttachmentsThumbnailSizeWithResponse call
func ParseAttachmentsThumbnailSizeResponse(rsp *http.Response) (*AttachmentsThumbnailSizeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AttachmentsThumbnailSizeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAttachmentsDestroyResponse parses an HTTP response from a AttachmentsDestroyWithResponse call
func ParseAttachmentsDestroyResponse(rsp *http.Response) (*AttachmentsDestroyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AttachmentsDestroyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAttachmentsShowResponse parses an HTTP response from a AttachmentsShowWithResponse call
func ParseAttachmentsShowResponse(rsp *http.Response) (*AttachmentsShowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AttachmentsShowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Attachment *AttachmentsShow_200_Attachment `json:"attachment,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAttachmentsUpdatePatchResponse parses an HTTP response from a AttachmentsUpdatePatchWithResponse call
func ParseAttachmentsUpdatePatchResponse(rsp *http.Response) (*AttachmentsUpdatePatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AttachmentsUpdatePatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest struct {
			Errors *[]string `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseAttachmentsUpdatePutResponse parses an HTTP response from a AttachmentsUpdatePutWithResponse call
func ParseAttachmentsUpdatePutResponse(rsp *http.Response) (*AttachmentsUpdatePutResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AttachmentsUpdatePutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest struct {
			Errors *[]string `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseAttachmentsDownloadAllResponse parses an HTTP response from a AttachmentsDownloadAllWithResponse call
func ParseAttachmentsDownloadAllResponse(rsp *http.Response) (*AttachmentsDownloadAllResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AttachmentsDownloadAllResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCustomFieldsIndexResponse parses an HTTP response from a CustomFieldsIndexWithResponse call
func ParseCustomFieldsIndexResponse(rsp *http.Response) (*CustomFieldsIndexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CustomFieldsIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			CustomFields *[]struct {
				// CustomizedType The type of object this custom field is associated with.
				CustomizedType *string `json:"customized_type,omitempty"`

				// DefaultValue The default value for the custom field.
				DefaultValue *string `json:"default_value,omitempty"`

				// Description A description of the custom field.
				Description *string `json:"description,omitempty"`

				// Editable The editable of the custom field.
				Editable *bool `json:"editable,omitempty"`

				// FieldFormat The format of the custom field.
				// Possible values are:
				// - `string`
				// - `text`
				// - `link`
				// - `int`
				// - `float`
				// - `date`
				// - `list`
				// - `bool`
				// - `enumeration`
				// - `user`
				// - `version`
				// - `attachement`
				FieldFormat *string `json:"field_format,omitempty"`

				// Id The unique identifier of the custom field.
				Id *int `json:"id,omitempty"`

				// IsFilter Whether the custom field can be used as a filter.
				IsFilter *bool `json:"is_filter,omitempty"`

				// IsRequired Whether the custom field is required.
				IsRequired *bool `json:"is_required,omitempty"`

				// MaxLength The maximum length allowed for the custom field value.
				MaxLength *int `json:"max_length,omitempty"`

				// MinLength The minimum length allowed for the custom field value.
				MinLength *int `json:"min_length,omitempty"`

				// Multiple Whether the custom field allows multiple values.
				Multiple *bool `json:"multiple,omitempty"`

				// Name The name of the custom field.
				Name *string `json:"name,omitempty"`

				// PossibleValues The possible values of the custom field.
				PossibleValues *[]struct {
					// Label The label of the possible value.
					Label *string `json:"label,omitempty"`

					// Value The value of the possible value.
					Value *string `json:"value,omitempty"`
				} `json:"possible_values,omitempty"`

				// Regexp The regular expression pattern for the custom field value.
				Regexp *string `json:"regexp,omitempty"`
				Roles  *[]struct {
					// Id The id of the role.
					Id *int `json:"id,omitempty"`

					// Name The name of the role.
					Name *string `json:"name,omitempty"`
				} `json:"roles,omitempty"`

				// Searchable Whether the custom field is searchable.
				Searchable *bool `json:"searchable,omitempty"`
				Trackers   *[]struct {
					// Id The id of the tracker.
					Id *int `json:"id,omitempty"`

					// Name The name of the tracker.
					Name *string `json:"name,omitempty"`
				} `json:"trackers,omitempty"`

				// Visible Whether the custom field is visible.
				Visible *bool `json:"visible,omitempty"`
			} `json:"custom_fields,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEnumerationsIndexDocumentCategoryResponse parses an HTTP response from a EnumerationsIndexDocumentCategoryWithResponse call
func ParseEnumerationsIndexDocumentCategoryResponse(rsp *http.Response) (*EnumerationsIndexDocumentCategoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnumerationsIndexDocumentCategoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			DocumentCategories *[]struct {
				// Active The active of the enumeration.
				Active       *bool `json:"active,omitempty"`
				CustomFields *[]struct {
					// Id The ID of the custom field.
					Id *int `json:"id,omitempty"`

					// Multiple Whether the custom field can have multiple values.
					Multiple *bool `json:"multiple,omitempty"`

					// Name The name of the custom field.
					Name  *string      `json:"name,omitempty"`
					Value *interface{} `json:"value,omitempty"`
				} `json:"custom_fields,omitempty"`

				// Id The unique identifier of the enumeration.
				Id *int `json:"id,omitempty"`

				// IsDefault The default of the enumeration.
				IsDefault *bool `json:"is_default,omitempty"`

				// Name The name of the enumeration.
				Name *string `json:"name,omitempty"`
			} `json:"document_categories,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEnumerationsIndexIssuePriorityResponse parses an HTTP response from a EnumerationsIndexIssuePriorityWithResponse call
func ParseEnumerationsIndexIssuePriorityResponse(rsp *http.Response) (*EnumerationsIndexIssuePriorityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnumerationsIndexIssuePriorityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IssuePriorities *[]struct {
				// Active The active of the enumeration.
				Active       *bool `json:"active,omitempty"`
				CustomFields *[]struct {
					// Id The ID of the custom field.
					Id *int `json:"id,omitempty"`

					// Multiple Whether the custom field can have multiple values.
					Multiple *bool `json:"multiple,omitempty"`

					// Name The name of the custom field.
					Name  *string      `json:"name,omitempty"`
					Value *interface{} `json:"value,omitempty"`
				} `json:"custom_fields,omitempty"`

				// Id The unique identifier of the enumeration.
				Id *int `json:"id,omitempty"`

				// IsDefault The default of the enumeration.
				IsDefault *bool `json:"is_default,omitempty"`

				// Name The name of the enumeration.
				Name *string `json:"name,omitempty"`
			} `json:"issue_priorities,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEnumerationsIndexTimeEntryActivityResponse parses an HTTP response from a EnumerationsIndexTimeEntryActivityWithResponse call
func ParseEnumerationsIndexTimeEntryActivityResponse(rsp *http.Response) (*EnumerationsIndexTimeEntryActivityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnumerationsIndexTimeEntryActivityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			TimeEntryActivities *[]struct {
				// Active The active of the enumeration.
				Active       *bool `json:"active,omitempty"`
				CustomFields *[]struct {
					// Id The ID of the custom field.
					Id *int `json:"id,omitempty"`

					// Multiple Whether the custom field can have multiple values.
					Multiple *bool `json:"multiple,omitempty"`

					// Name The name of the custom field.
					Name  *string      `json:"name,omitempty"`
					Value *interface{} `json:"value,omitempty"`
				} `json:"custom_fields,omitempty"`

				// Id The unique identifier of the enumeration.
				Id *int `json:"id,omitempty"`

				// IsDefault The default of the enumeration.
				IsDefault *bool `json:"is_default,omitempty"`

				// Name The name of the enumeration.
				Name *string `json:"name,omitempty"`
			} `json:"time_entry_activities,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGroupsIndexResponse parses an HTTP response from a GroupsIndexWithResponse call
func ParseGroupsIndexResponse(rsp *http.Response) (*GroupsIndexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GroupsIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Groups *[]struct {
				// Builtin The builtin type of the group.
				Builtin      *string `json:"builtin,omitempty"`
				CustomFields *[]struct {
					// Id The ID of the custom field.
					Id *int `json:"id,omitempty"`

					// Multiple Whether the custom field can have multiple values.
					Multiple *bool `json:"multiple,omitempty"`

					// Name The name of the custom field.
					Name  *string      `json:"name,omitempty"`
					Value *interface{} `json:"value,omitempty"`
				} `json:"custom_fields,omitempty"`

				// Id The ID of the group.
				Id *int `json:"id,omitempty"`

				// Name The name of the group.
				Name *string `json:"name,omitempty"`
			} `json:"groups,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGroupsCreateResponse parses an HTTP response from a GroupsCreateWithResponse call
func ParseGroupsCreateResponse(rsp *http.Response) (*GroupsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GroupsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Group A single group.
			Group *struct {
				// Builtin The builtin type of the group.
				Builtin      *string `json:"builtin,omitempty"`
				CustomFields *[]struct {
					// Id The ID of the custom field.
					Id *int `json:"id,omitempty"`

					// Multiple Whether the custom field can have multiple values.
					Multiple *bool `json:"multiple,omitempty"`

					// Name The name of the custom field.
					Name  *string      `json:"name,omitempty"`
					Value *interface{} `json:"value,omitempty"`
				} `json:"custom_fields,omitempty"`

				// Id The ID of the group.
				Id          *int `json:"id,omitempty"`
				Memberships *[]struct {
					// Id The ID of the mebership.
					Id      *int `json:"id,omitempty"`
					Project *struct {
						// Id The ID of the project.
						Id *int `json:"id,omitempty"`

						// Name The name of the project.
						Name *string `json:"name,omitempty"`
					} `json:"project,omitempty"`
					Roles *[]struct {
						// Id The ID of the role.
						Id *int `json:"id,omitempty"`

						// Inherited Whether the role is inherited from a parent project.
						Inherited *bool `json:"inherited,omitempty"`

						// Name The name of the role.
						Name *string `json:"name,omitempty"`
					} `json:"roles,omitempty"`
				} `json:"memberships,omitempty"`

				// Name The name of the group.
				Name  *string `json:"name,omitempty"`
				Users *[]struct {
					// Id The ID of the user.
					Id *int `json:"id,omitempty"`

					// Name The name of the user.
					Name *string `json:"name,omitempty"`
				} `json:"users,omitempty"`
			} `json:"group,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest struct {
			Errors *[]string `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGroupsDestroyResponse parses an HTTP response from a GroupsDestroyWithResponse call
func ParseGroupsDestroyResponse(rsp *http.Response) (*GroupsDestroyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GroupsDestroyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGroupsShowResponse parses an HTTP response from a GroupsShowWithResponse call
func ParseGroupsShowResponse(rsp *http.Response) (*GroupsShowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GroupsShowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Group A single group.
			Group *struct {
				// Builtin The builtin type of the group.
				Builtin      *string `json:"builtin,omitempty"`
				CustomFields *[]struct {
					// Id The ID of the custom field.
					Id *int `json:"id,omitempty"`

					// Multiple Whether the custom field can have multiple values.
					Multiple *bool `json:"multiple,omitempty"`

					// Name The name of the custom field.
					Name  *string      `json:"name,omitempty"`
					Value *interface{} `json:"value,omitempty"`
				} `json:"custom_fields,omitempty"`

				// Id The ID of the group.
				Id          *int `json:"id,omitempty"`
				Memberships *[]struct {
					// Id The ID of the mebership.
					Id      *int `json:"id,omitempty"`
					Project *struct {
						// Id The ID of the project.
						Id *int `json:"id,omitempty"`

						// Name The name of the project.
						Name *string `json:"name,omitempty"`
					} `json:"project,omitempty"`
					Roles *[]struct {
						// Id The ID of the role.
						Id *int `json:"id,omitempty"`

						// Inherited Whether the role is inherited from a parent project.
						Inherited *bool `json:"inherited,omitempty"`

						// Name The name of the role.
						Name *string `json:"name,omitempty"`
					} `json:"roles,omitempty"`
				} `json:"memberships,omitempty"`

				// Name The name of the group.
				Name  *string `json:"name,omitempty"`
				Users *[]struct {
					// Id The ID of the user.
					Id *int `json:"id,omitempty"`

					// Name The name of the user.
					Name *string `json:"name,omitempty"`
				} `json:"users,omitempty"`
			} `json:"group,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGroupsUpdatePatchResponse parses an HTTP response from a GroupsUpdatePatchWithResponse call
func ParseGroupsUpdatePatchResponse(rsp *http.Response) (*GroupsUpdatePatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GroupsUpdatePatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest struct {
			Errors *[]string `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGroupsUpdatePutResponse parses an HTTP response from a GroupsUpdatePutWithResponse call
func ParseGroupsUpdatePutResponse(rsp *http.Response) (*GroupsUpdatePutResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GroupsUpdatePutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest struct {
			Errors *[]string `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGroupsAddUsersResponse parses an HTTP response from a GroupsAddUsersWithResponse call
func ParseGroupsAddUsersResponse(rsp *http.Response) (*GroupsAddUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GroupsAddUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest struct {
			Errors *[]string `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGroupsRemoveUserResponse parses an HTTP response from a GroupsRemoveUserWithResponse call
func ParseGroupsRemoveUserResponse(rsp *http.Response) (*GroupsRemoveUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GroupsRemoveUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseIssueCategoriesDestroyResponse parses an HTTP response from a IssueCategoriesDestroyWithResponse call
func ParseIssueCategoriesDestroyResponse(rsp *http.Response) (*IssueCategoriesDestroyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssueCategoriesDestroyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseIssueCategoriesShowResponse parses an HTTP response from a IssueCategoriesShowWithResponse call
func ParseIssueCategoriesShowResponse(rsp *http.Response) (*IssueCategoriesShowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssueCategoriesShowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// IssueCategory A single issue category.
			IssueCategory *struct {
				AssignedTo *struct {
					// Id The ID of the assigned to.
					Id *int `json:"id,omitempty"`

					// Name The name of the assigned to.
					Name *string `json:"name,omitempty"`
				} `json:"assigned_to,omitempty"`

				// Id The ID of the issue category.
				Id *int `json:"id,omitempty"`

				// Name The name of the issue category.
				Name    *string `json:"name,omitempty"`
				Project *struct {
					// Id The ID of the project.
					Id *int `json:"id,omitempty"`

					// Name The name of the project.
					Name *string `json:"name,omitempty"`
				} `json:"project,omitempty"`
			} `json:"issue_category,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseIssueCategoriesUpdatePatchResponse parses an HTTP response from a IssueCategoriesUpdatePatchWithResponse call
func ParseIssueCategoriesUpdatePatchResponse(rsp *http.Response) (*IssueCategoriesUpdatePatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssueCategoriesUpdatePatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest struct {
			Errors *[]string `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseIssueCategoriesUpdatePutResponse parses an HTTP response from a IssueCategoriesUpdatePutWithResponse call
func ParseIssueCategoriesUpdatePutResponse(rsp *http.Response) (*IssueCategoriesUpdatePutResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssueCategoriesUpdatePutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest struct {
			Errors *[]string `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseIssueStatusesIndexResponse parses an HTTP response from a IssueStatusesIndexWithResponse call
func ParseIssueStatusesIndexResponse(rsp *http.Response) (*IssueStatusesIndexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssueStatusesIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IssueStatuses *[]struct {
				// Description A description of the issue status.
				Description *string `json:"description,omitempty"`

				// Id The unique identifier of the issue status.
				Id *int `json:"id,omitempty"`

				// IsClosed Whether the issue status is closed.
				IsClosed *bool `json:"is_closed,omitempty"`

				// Name The name of the issue status.
				Name *string `json:"name,omitempty"`
			} `json:"issue_statuses,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseIssuesIndexCsvResponse parses an HTTP response from a IssuesIndexCsvWithResponse call
func ParseIssuesIndexCsvResponse(rsp *http.Response) (*IssuesIndexCsvResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssuesIndexCsvResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest struct {
			Errors *[]string `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseIssuesIndexResponse parses an HTTP response from a IssuesIndexWithResponse call
func ParseIssuesIndexResponse(rsp *http.Response) (*IssuesIndexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssuesIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Issues *[]struct {
				AssignedTo *struct {
					// Id The ID of the assigned member.
					Id *int `json:"id,omitempty"`

					// Name The name of the assigned member.
					Name *string `json:"name,omitempty"`
				} `json:"assigned_to,omitempty"`
				Attachments *[]IssuesIndex_200_Issues_Attachments_Item `json:"attachments,omitempty"`
				Author      *struct {
					// Id The ID of the author.
					Id *int `json:"id,omitempty"`

					// Name The name of the author.
					Name *string `json:"name,omitempty"`
				} `json:"author,omitempty"`
				Category *struct {
					// Id The ID of the category.
					Id *int `json:"id,omitempty"`

					// Name The name of the category.
					Name *string `json:"name,omitempty"`
				} `json:"category,omitempty"`

				// ClosedOn The date and time when the issue was closed.
				ClosedOn *time.Time `json:"closed_on,omitempty"`

				// CreatedOn The date and time when the issue was created.
				CreatedOn    *time.Time `json:"created_on,omitempty"`
				CustomFields *[]struct {
					// Id The ID of the custom field.
					Id *int `json:"id,omitempty"`

					// Multiple Whether the custom field can have multiple values.
					Multiple *bool `json:"multiple,omitempty"`

					// Name The name of the custom field.
					Name  *string      `json:"name,omitempty"`
					Value *interface{} `json:"value,omitempty"`
				} `json:"custom_fields,omitempty"`

				// Description The description of the issue.
				Description *string `json:"description,omitempty"`

				// DoneRatio The done ratio of the issue.
				DoneRatio *int `json:"done_ratio,omitempty"`

				// DueDate The due date of the issue.
				DueDate *openapi_types.Date `json:"due_date,omitempty"`

				// EstimatedHours The estimated hours of the issue.
				EstimatedHours *float32 `json:"estimated_hours,omitempty"`
				FixedVersion   *struct {
					// Id The ID of the fixed version.
					Id *int `json:"id,omitempty"`

					// Name The name of the fixed version.
					Name *string `json:"name,omitempty"`
				} `json:"fixed_version,omitempty"`

				// Id The ID of the issue.
				Id *int `json:"id,omitempty"`

				// IsPrivate The private of the issue.
				IsPrivate *bool `json:"is_private,omitempty"`
				Parent    *struct {
					// Id The ID of the parent issue.
					Id *int `json:"id,omitempty"`
				} `json:"parent,omitempty"`
				Priority *struct {
					// Id The ID of the priority.
					Id *int `json:"id,omitempty"`

					// Name The name of the priority.
					Name *string `json:"name,omitempty"`
				} `json:"priority,omitempty"`
				Project *struct {
					// Id The ID of the project.
					Id *int `json:"id,omitempty"`

					// Name The name of the project.
					Name *string `json:"name,omitempty"`
				} `json:"project,omitempty"`
				Relations *[]struct {
					// Delay The delay of the relation.
					Delay *int `json:"delay,omitempty"`

					// Id The ID of the relation.
					Id *int `json:"id,omitempty"`

					// IssueId The ID of the issue.
					IssueId *int `json:"issue_id,omitempty"`

					// IssueToId The ID of the issue.
					IssueToId *int `json:"issue_to_id,omitempty"`

					// RelationType The type of the relation.
					RelationType *string `json:"relation_type,omitempty"`
				} `json:"relations,omitempty"`

				// SpentHours The spent hours of the issue.
				SpentHours *float32 `json:"spent_hours,omitempty"`

				// StartDate The start date of the issue.
				StartDate *openapi_types.Date `json:"start_date,omitempty"`
				Status    *struct {
					// Id The ID of the status.
					Id *int `json:"id,omitempty"`

					// IsClosed The closed of the status.
					IsClosed *bool `json:"is_closed,omitempty"`

					// Name The name of the status.
					Name *string `json:"name,omitempty"`
				} `json:"status,omitempty"`

				// Subject The subject of the issue.
				Subject *string `json:"subject,omitempty"`

				// TotalEstimatedHours The total estimated hours of the issue.
				TotalEstimatedHours *float32 `json:"total_estimated_hours,omitempty"`

				// TotalSpentHours The total spent hours of the issue.
				TotalSpentHours *float32 `json:"total_spent_hours,omitempty"`
				Tracker         *struct {
					// Id The ID of the tracker.
					Id *int `json:"id,omitempty"`

					// Name The name of the tracker.
					Name *string `json:"name,omitempty"`
				} `json:"tracker,omitempty"`

				// UpdatedOn The date and time when the issue was updated.
				UpdatedOn *time.Time `json:"updated_on,omitempty"`
			} `json:"issues,omitempty"`

			// Limit The maximum number of issues returned in the list.
			Limit *int `json:"limit,omitempty"`

			// Offset The offset of the first issue in the list.
			Offset *int `json:"offset,omitempty"`

			// TotalCount The total number of issues.
			TotalCount *int `json:"total_count,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest struct {
			Errors *[]string `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseIssuesCreateResponse parses an HTTP response from a IssuesCreateWithResponse call
func ParseIssuesCreateResponse(rsp *http.Response) (*IssuesCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssuesCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Issue A single issue.
			Issue *struct {
				AllowedStatuses *[]struct {
					// Id The ID of the allowed statuse.
					Id *int `json:"id,omitempty"`

					// IsClosed The closed of the allowed status.
					IsClosed *bool `json:"is_closed,omitempty"`

					// Name The name of the allowed statuse.
					Name *string `json:"name,omitempty"`
				} `json:"allowed_statuses,omitempty"`
				AssignedTo *struct {
					// Id The ID of the assigned member.
					Id *int `json:"id,omitempty"`

					// Name The name of the assigned member.
					Name *string `json:"name,omitempty"`
				} `json:"assigned_to,omitempty"`
				Attachments *[]IssuesCreate_201_Issue_Attachments_Item `json:"attachments,omitempty"`
				Author      *struct {
					// Id The ID of the author.
					Id *int `json:"id,omitempty"`

					// Name The name of the author.
					Name *string `json:"name,omitempty"`
				} `json:"author,omitempty"`
				Category *struct {
					// Id The ID of the category.
					Id *int `json:"id,omitempty"`

					// Name The name of the category.
					Name *string `json:"name,omitempty"`
				} `json:"category,omitempty"`
				Changesets *[]struct {
					// Comments The comments of the changeset.
					Comments *string `json:"comments,omitempty"`

					// CommittedOn The date and time when the changeset was committed.
					CommittedOn *time.Time `json:"committed_on,omitempty"`

					// Revision The revision of the changeset.
					Revision *string `json:"revision,omitempty"`
					User     *struct {
						// Id The ID of the user.
						Id *int `json:"id,omitempty"`

						// Name The name of the user.
						Name *string `json:"name,omitempty"`
					} `json:"user,omitempty"`
				} `json:"changesets,omitempty"`
				Children *[]struct {
					Children *[]interface{} `json:"children,omitempty"`

					// Id The ID of the issue.
					Id *int `json:"id,omitempty"`

					// Subject The subject of the issue.
					Subject *string `json:"subject,omitempty"`
					Tracker *struct {
						// Id The ID of the tracker.
						Id *int `json:"id,omitempty"`

						// Name The name of the tracker.
						Name *string `json:"name,omitempty"`
					} `json:"tracker,omitempty"`
				} `json:"children,omitempty"`

				// ClosedOn The date and time when the issue was closed.
				ClosedOn *time.Time `json:"closed_on,omitempty"`

				// CreatedOn The date and time when the issue was created.
				CreatedOn    *time.Time `json:"created_on,omitempty"`
				CustomFields *[]struct {
					// Id The ID of the custom field.
					Id *int `json:"id,omitempty"`

					// Multiple Whether the custom field can have multiple values.
					Multiple *bool `json:"multiple,omitempty"`

					// Name The name of the custom field.
					Name  *string      `json:"name,omitempty"`
					Value *interface{} `json:"value,omitempty"`
				} `json:"custom_fields,omitempty"`

				// Description The description of the issue.
				Description *string `json:"description,omitempty"`

				// DoneRatio The done ratio of the issue.
				DoneRatio *int `json:"done_ratio,omitempty"`

				// DueDate The due date of the issue.
				DueDate *openapi_types.Date `json:"due_date,omitempty"`

				// EstimatedHours The estimated hours of the issue.
				EstimatedHours *float32 `json:"estimated_hours,omitempty"`
				FixedVersion   *struct {
					// Id The ID of the fixed version.
					Id *int `json:"id,omitempty"`

					// Name The name of the fixed version.
					Name *string `json:"name,omitempty"`
				} `json:"fixed_version,omitempty"`

				// Id The ID of the issue.
				Id *int `json:"id,omitempty"`

				// IsPrivate The private of the issue.
				IsPrivate *bool `json:"is_private,omitempty"`
				Journals  *[]struct {
					// CreatedOn The date and time when the journal was created.
					CreatedOn *time.Time `json:"created_on,omitempty"`
					Details   *[]struct {
						// Name The name of the detail.
						Name *string `json:"name,omitempty"`

						// NewValue The new value of the detail.
						NewValue *string `json:"new_value,omitempty"`

						// OldValue The old value of the detail.
						OldValue *string `json:"old_value,omitempty"`

						// Property The property of the detail.
						Property *string `json:"property,omitempty"`
					} `json:"details,omitempty"`

					// Id The ID of the journal.
					Id *int `json:"id,omitempty"`

					// Notes The notes of the journal.
					Notes *string `json:"notes,omitempty"`

					// PrivateNotes The private of the journal.
					PrivateNotes *bool `json:"private_notes,omitempty"`
					UpdatedBy    *struct {
						// Id The ID of the updated.
						Id *int `json:"id,omitempty"`

						// Name The name of the updated.
						Name *string `json:"name,omitempty"`
					} `json:"updated_by,omitempty"`

					// UpdatedOn The date and time when the journal was updated.
					UpdatedOn *time.Time `json:"updated_on,omitempty"`
					User      *struct {
						// Id The ID of the user.
						Id *int `json:"id,omitempty"`

						// Name The name of the user.
						Name *string `json:"name,omitempty"`
					} `json:"user,omitempty"`
				} `json:"journals,omitempty"`
				Parent *struct {
					// Id The ID of the parent issue.
					Id *int `json:"id,omitempty"`
				} `json:"parent,omitempty"`
				Priority *struct {
					// Id The ID of the priority.
					Id *int `json:"id,omitempty"`

					// Name The name of the priority.
					Name *string `json:"name,omitempty"`
				} `json:"priority,omitempty"`
				Project *struct {
					// Id The ID of the project.
					Id *int `json:"id,omitempty"`

					// Name The name of the project.
					Name *string `json:"name,omitempty"`
				} `json:"project,omitempty"`
				Relations *[]struct {
					// Delay The delay of the relation.
					Delay *int `json:"delay,omitempty"`

					// Id The ID of the relation.
					Id *int `json:"id,omitempty"`

					// IssueId The ID of the issue.
					IssueId *int `json:"issue_id,omitempty"`

					// IssueToId The ID of the issue.
					IssueToId *int `json:"issue_to_id,omitempty"`

					// RelationType The type of the relation.
					RelationType *string `json:"relation_type,omitempty"`
				} `json:"relations,omitempty"`

				// SpentHours The spent hours of the issue.
				SpentHours *float32 `json:"spent_hours,omitempty"`

				// StartDate The start date of the issue.
				StartDate *openapi_types.Date `json:"start_date,omitempty"`
				Status    *struct {
					// Id The ID of the status.
					Id *int `json:"id,omitempty"`

					// IsClosed The closed of the status.
					IsClosed *bool `json:"is_closed,omitempty"`

					// Name The name of the status.
					Name *string `json:"name,omitempty"`
				} `json:"status,omitempty"`

				// Subject The subject of the issue.
				Subject *string `json:"subject,omitempty"`

				// TotalEstimatedHours The total estimated hours of the issue.
				TotalEstimatedHours *float32 `json:"total_estimated_hours,omitempty"`

				// TotalSpentHours The total spent hours of the issue.
				TotalSpentHours *float32 `json:"total_spent_hours,omitempty"`
				Tracker         *struct {
					// Id The ID of the tracker.
					Id *int `json:"id,omitempty"`

					// Name The name of the tracker.
					Name *string `json:"name,omitempty"`
				} `json:"tracker,omitempty"`

				// UpdatedOn The date and time when the issue was updated.
				UpdatedOn *time.Time `json:"updated_on,omitempty"`
				Watchers  *[]struct {
					// Id The ID of the watcher.
					Id *int `json:"id,omitempty"`

					// Name The name of the watcher.
					Name *string `json:"name,omitempty"`
				} `json:"watchers,omitempty"`
			} `json:"issue,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest struct {
			Errors *[]string `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseIssuesIndexPdfResponse parses an HTTP response from a IssuesIndexPdfWithResponse call
func ParseIssuesIndexPdfResponse(rsp *http.Response) (*IssuesIndexPdfResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssuesIndexPdfResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest struct {
			Errors *[]string `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGanttsShowPdfResponse parses an HTTP response from a GanttsShowPdfWithResponse call
func ParseGanttsShowPdfResponse(rsp *http.Response) (*GanttsShowPdfResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GanttsShowPdfResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGanttsShowPngResponse parses an HTTP response from a GanttsShowPngWithResponse call
func ParseGanttsShowPngResponse(rsp *http.Response) (*GanttsShowPngResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GanttsShowPngResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseIssuesDestroyResponse parses an HTTP response from a IssuesDestroyWithResponse call
func ParseIssuesDestroyResponse(rsp *http.Response) (*IssuesDestroyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssuesDestroyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest struct {
			Errors *[]string `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseIssuesShowResponse parses an HTTP response from a IssuesShowWithResponse call
func ParseIssuesShowResponse(rsp *http.Response) (*IssuesShowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssuesShowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Issue A single issue.
			Issue *struct {
				AllowedStatuses *[]struct {
					// Id The ID of the allowed statuse.
					Id *int `json:"id,omitempty"`

					// IsClosed The closed of the allowed status.
					IsClosed *bool `json:"is_closed,omitempty"`

					// Name The name of the allowed statuse.
					Name *string `json:"name,omitempty"`
				} `json:"allowed_statuses,omitempty"`
				AssignedTo *struct {
					// Id The ID of the assigned member.
					Id *int `json:"id,omitempty"`

					// Name The name of the assigned member.
					Name *string `json:"name,omitempty"`
				} `json:"assigned_to,omitempty"`
				Attachments *[]IssuesShow_200_Issue_Attachments_Item `json:"attachments,omitempty"`
				Author      *struct {
					// Id The ID of the author.
					Id *int `json:"id,omitempty"`

					// Name The name of the author.
					Name *string `json:"name,omitempty"`
				} `json:"author,omitempty"`
				Category *struct {
					// Id The ID of the category.
					Id *int `json:"id,omitempty"`

					// Name The name of the category.
					Name *string `json:"name,omitempty"`
				} `json:"category,omitempty"`
				Changesets *[]struct {
					// Comments The comments of the changeset.
					Comments *string `json:"comments,omitempty"`

					// CommittedOn The date and time when the changeset was committed.
					CommittedOn *time.Time `json:"committed_on,omitempty"`

					// Revision The revision of the changeset.
					Revision *string `json:"revision,omitempty"`
					User     *struct {
						// Id The ID of the user.
						Id *int `json:"id,omitempty"`

						// Name The name of the user.
						Name *string `json:"name,omitempty"`
					} `json:"user,omitempty"`
				} `json:"changesets,omitempty"`
				Children *[]struct {
					Children *[]interface{} `json:"children,omitempty"`

					// Id The ID of the issue.
					Id *int `json:"id,omitempty"`

					// Subject The subject of the issue.
					Subject *string `json:"subject,omitempty"`
					Tracker *struct {
						// Id The ID of the tracker.
						Id *int `json:"id,omitempty"`

						// Name The name of the tracker.
						Name *string `json:"name,omitempty"`
					} `json:"tracker,omitempty"`
				} `json:"children,omitempty"`

				// ClosedOn The date and time when the issue was closed.
				ClosedOn *time.Time `json:"closed_on,omitempty"`

				// CreatedOn The date and time when the issue was created.
				CreatedOn    *time.Time `json:"created_on,omitempty"`
				CustomFields *[]struct {
					// Id The ID of the custom field.
					Id *int `json:"id,omitempty"`

					// Multiple Whether the custom field can have multiple values.
					Multiple *bool `json:"multiple,omitempty"`

					// Name The name of the custom field.
					Name  *string      `json:"name,omitempty"`
					Value *interface{} `json:"value,omitempty"`
				} `json:"custom_fields,omitempty"`

				// Description The description of the issue.
				Description *string `json:"description,omitempty"`

				// DoneRatio The done ratio of the issue.
				DoneRatio *int `json:"done_ratio,omitempty"`

				// DueDate The due date of the issue.
				DueDate *openapi_types.Date `json:"due_date,omitempty"`

				// EstimatedHours The estimated hours of the issue.
				EstimatedHours *float32 `json:"estimated_hours,omitempty"`
				FixedVersion   *struct {
					// Id The ID of the fixed version.
					Id *int `json:"id,omitempty"`

					// Name The name of the fixed version.
					Name *string `json:"name,omitempty"`
				} `json:"fixed_version,omitempty"`

				// Id The ID of the issue.
				Id *int `json:"id,omitempty"`

				// IsPrivate The private of the issue.
				IsPrivate *bool `json:"is_private,omitempty"`
				Journals  *[]struct {
					// CreatedOn The date and time when the journal was created.
					CreatedOn *time.Time `json:"created_on,omitempty"`
					Details   *[]struct {
						// Name The name of the detail.
						Name *string `json:"name,omitempty"`

						// NewValue The new value of the detail.
						NewValue *string `json:"new_value,omitempty"`

						// OldValue The old value of the detail.
						OldValue *string `json:"old_value,omitempty"`

						// Property The property of the detail.
						Property *string `json:"property,omitempty"`
					} `json:"details,omitempty"`

					// Id The ID of the journal.
					Id *int `json:"id,omitempty"`

					// Notes The notes of the journal.
					Notes *string `json:"notes,omitempty"`

					// PrivateNotes The private of the journal.
					PrivateNotes *bool `json:"private_notes,omitempty"`
					UpdatedBy    *struct {
						// Id The ID of the updated.
						Id *int `json:"id,omitempty"`

						// Name The name of the updated.
						Name *string `json:"name,omitempty"`
					} `json:"updated_by,omitempty"`

					// UpdatedOn The date and time when the journal was updated.
					UpdatedOn *time.Time `json:"updated_on,omitempty"`
					User      *struct {
						// Id The ID of the user.
						Id *int `json:"id,omitempty"`

						// Name The name of the user.
						Name *string `json:"name,omitempty"`
					} `json:"user,omitempty"`
				} `json:"journals,omitempty"`
				Parent *struct {
					// Id The ID of the parent issue.
					Id *int `json:"id,omitempty"`
				} `json:"parent,omitempty"`
				Priority *struct {
					// Id The ID of the priority.
					Id *int `json:"id,omitempty"`

					// Name The name of the priority.
					Name *string `json:"name,omitempty"`
				} `json:"priority,omitempty"`
				Project *struct {
					// Id The ID of the project.
					Id *int `json:"id,omitempty"`

					// Name The name of the project.
					Name *string `json:"name,omitempty"`
				} `json:"project,omitempty"`
				Relations *[]struct {
					// Delay The delay of the relation.
					Delay *int `json:"delay,omitempty"`

					// Id The ID of the relation.
					Id *int `json:"id,omitempty"`

					// IssueId The ID of the issue.
					IssueId *int `json:"issue_id,omitempty"`

					// IssueToId The ID of the issue.
					IssueToId *int `json:"issue_to_id,omitempty"`

					// RelationType The type of the relation.
					RelationType *string `json:"relation_type,omitempty"`
				} `json:"relations,omitempty"`

				// SpentHours The spent hours of the issue.
				SpentHours *float32 `json:"spent_hours,omitempty"`

				// StartDate The start date of the issue.
				StartDate *openapi_types.Date `json:"start_date,omitempty"`
				Status    *struct {
					// Id The ID of the status.
					Id *int `json:"id,omitempty"`

					// IsClosed The closed of the status.
					IsClosed *bool `json:"is_closed,omitempty"`

					// Name The name of the status.
					Name *string `json:"name,omitempty"`
				} `json:"status,omitempty"`

				// Subject The subject of the issue.
				Subject *string `json:"subject,omitempty"`

				// TotalEstimatedHours The total estimated hours of the issue.
				TotalEstimatedHours *float32 `json:"total_estimated_hours,omitempty"`

				// TotalSpentHours The total spent hours of the issue.
				TotalSpentHours *float32 `json:"total_spent_hours,omitempty"`
				Tracker         *struct {
					// Id The ID of the tracker.
					Id *int `json:"id,omitempty"`

					// Name The name of the tracker.
					Name *string `json:"name,omitempty"`
				} `json:"tracker,omitempty"`

				// UpdatedOn The date and time when the issue was updated.
				UpdatedOn *time.Time `json:"updated_on,omitempty"`
				Watchers  *[]struct {
					// Id The ID of the watcher.
					Id *int `json:"id,omitempty"`

					// Name The name of the watcher.
					Name *string `json:"name,omitempty"`
				} `json:"watchers,omitempty"`
			} `json:"issue,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseIssuesUpdatePatchResponse parses an HTTP response from a IssuesUpdatePatchWithResponse call
func ParseIssuesUpdatePatchResponse(rsp *http.Response) (*IssuesUpdatePatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssuesUpdatePatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest struct {
			Errors *[]string `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseIssuesUpdatePutResponse parses an HTTP response from a IssuesUpdatePutWithResponse call
func ParseIssuesUpdatePutResponse(rsp *http.Response) (*IssuesUpdatePutResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssuesUpdatePutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest struct {
			Errors *[]string `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseIssuesShowPdfResponse parses an HTTP response from a IssuesShowPdfWithResponse call
func ParseIssuesShowPdfResponse(rsp *http.Response) (*IssuesShowPdfResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssuesShowPdfResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseIssueRelationsIndexResponse parses an HTTP response from a IssueRelationsIndexWithResponse call
func ParseIssueRelationsIndexResponse(rsp *http.Response) (*IssueRelationsIndexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssueRelationsIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Relations *[]struct {
				// Delay The delay of the relation.
				Delay *int `json:"delay,omitempty"`

				// Id The ID of the relation.
				Id *int `json:"id,omitempty"`

				// IssueId The ID of the issue.
				IssueId *int `json:"issue_id,omitempty"`

				// IssueToId The ID of the issue to.
				IssueToId *int `json:"issue_to_id,omitempty"`

				// RelationType The relation type of the relation.
				RelationType *string `json:"relation_type,omitempty"`
			} `json:"relations,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseIssueRelationsCreateResponse parses an HTTP response from a IssueRelationsCreateWithResponse call
func ParseIssueRelationsCreateResponse(rsp *http.Response) (*IssueRelationsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssueRelationsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Relation Represents a single issue relation.
			Relation *struct {
				// Delay The delay of the relation.
				Delay *int `json:"delay,omitempty"`

				// Id The ID of the relation.
				Id *int `json:"id,omitempty"`

				// IssueId The ID of the issue.
				IssueId *int `json:"issue_id,omitempty"`

				// IssueToId The ID of the issue to.
				IssueToId *int `json:"issue_to_id,omitempty"`

				// RelationType The relation type of the relation.
				RelationType *string `json:"relation_type,omitempty"`
			} `json:"relation,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest struct {
			Errors *[]string `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseTimelogCreateIssueResponse parses an HTTP response from a TimelogCreateIssueWithResponse call
func ParseTimelogCreateIssueResponse(rsp *http.Response) (*TimelogCreateIssueResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TimelogCreateIssueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// TimeEntry A single time entry.
			TimeEntry *struct {
				Activity *struct {
					// Id The ID of the activity.
					Id *int `json:"id,omitempty"`

					// Name The name of the activity.
					Name *string `json:"name,omitempty"`
				} `json:"activity,omitempty"`

				// Comments The comments of the time entry.
				Comments *string `json:"comments,omitempty"`

				// CreatedOn The date and time when the time entry was created.
				CreatedOn    *time.Time `json:"created_on,omitempty"`
				CustomFields *[]struct {
					// Id The ID of the custom field.
					Id *int `json:"id,omitempty"`

					// Multiple Whether the custom field can have multiple values.
					Multiple *bool `json:"multiple,omitempty"`

					// Name The name of the custom field.
					Name  *string      `json:"name,omitempty"`
					Value *interface{} `json:"value,omitempty"`
				} `json:"custom_fields,omitempty"`

				// Hours The hours of the time entry.
				Hours *float32 `json:"hours,omitempty"`

				// Id The ID of the time entry.
				Id    *int `json:"id,omitempty"`
				Issue *struct {
					// Id The ID of the issue.
					Id *int `json:"id,omitempty"`
				} `json:"issue,omitempty"`
				Project *struct {
					// Id The ID of the project.
					Id *int `json:"id,omitempty"`

					// Name The name of the project.
					Name *string `json:"name,omitempty"`
				} `json:"project,omitempty"`

				// SpentOn The date when the time entry was spent.
				SpentOn *openapi_types.Date `json:"spent_on,omitempty"`

				// UpdatedOn The date and time when the time entry was last updated.
				UpdatedOn *time.Time `json:"updated_on,omitempty"`
				User      *struct {
					// Id The ID of the user.
					Id *int `json:"id,omitempty"`

					// Name The name of the user.
					Name *string `json:"name,omitempty"`
				} `json:"user,omitempty"`
			} `json:"time_entry,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest struct {
			Errors *[]string `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseWatchersCreateIssueResponse parses an HTTP response from a WatchersCreateIssueWithResponse call
func ParseWatchersCreateIssueResponse(rsp *http.Response) (*WatchersCreateIssueResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WatchersCreateIssueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseWatchersDestroyIssueResponse parses an HTTP response from a WatchersDestroyIssueWithResponse call
func ParseWatchersDestroyIssueResponse(rsp *http.Response) (*WatchersDestroyIssueResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WatchersDestroyIssueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseJournalsUpdatePatchResponse parses an HTTP response from a JournalsUpdatePatchWithResponse call
func ParseJournalsUpdatePatchResponse(rsp *http.Response) (*JournalsUpdatePatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &JournalsUpdatePatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest struct {
			Errors *[]string `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseJournalsUpdatePutResponse parses an HTTP response from a JournalsUpdatePutWithResponse call
func ParseJournalsUpdatePutResponse(rsp *http.Response) (*JournalsUpdatePutResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &JournalsUpdatePutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest struct {
			Errors *[]string `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseMembersDestroyResponse parses an HTTP response from a MembersDestroyWithResponse call
func ParseMembersDestroyResponse(rsp *http.Response) (*MembersDestroyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MembersDestroyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest struct {
			Errors *[]string `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseMembersShowResponse parses an HTTP response from a MembersShowWithResponse call
func ParseMembersShowResponse(rsp *http.Response) (*MembersShowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MembersShowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Membership A single membership.
			Membership *struct {
				Group *struct {
					// Id The ID of the group.
					Id *int `json:"id,omitempty"`

					// Name The name of the group.
					Name *string `json:"name,omitempty"`
				} `json:"group,omitempty"`

				// Id The ID of the membership.
				Id      *int `json:"id,omitempty"`
				Project *struct {
					// Id The ID of the project.
					Id *int `json:"id,omitempty"`

					// Name The name of the project.
					Name *string `json:"name,omitempty"`
				} `json:"project,omitempty"`
				Roles *[]struct {
					// Id The ID of the role.
					Id *int `json:"id,omitempty"`

					// Inherited Whether the role is inherited from a parent project.
					Inherited *bool `json:"inherited,omitempty"`

					// Name The name of the role.
					Name *string `json:"name,omitempty"`
				} `json:"roles,omitempty"`
				User *struct {
					// Id The ID of the user.
					Id *int `json:"id,omitempty"`

					// Name The name of the user.
					Name *string `json:"name,omitempty"`
				} `json:"user,omitempty"`
			} `json:"membership,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMembersUpdatePatchResponse parses an HTTP response from a MembersUpdatePatchWithResponse call
func ParseMembersUpdatePatchResponse(rsp *http.Response) (*MembersUpdatePatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MembersUpdatePatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest struct {
			Errors *[]string `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseMembersUpdatePutResponse parses an HTTP response from a MembersUpdatePutWithResponse call
func ParseMembersUpdatePutResponse(rsp *http.Response) (*MembersUpdatePutResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MembersUpdatePutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest struct {
			Errors *[]string `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseMyAccountResponse parses an HTTP response from a MyAccountWithResponse call
func ParseMyAccountResponse(rsp *http.Response) (*MyAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MyAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// User Represents a single user.
			User *struct {
				// Admin Whether the user has administrative privileges.
				Admin *bool `json:"admin,omitempty"`

				// ApiKey The API key for the user.
				ApiKey *string `json:"api_key,omitempty"`

				// CreatedOn The date and time when the user account was created.
				CreatedOn    *time.Time `json:"created_on,omitempty"`
				CustomFields *[]struct {
					// Id The ID of the custom field.
					Id *int `json:"id,omitempty"`

					// Multiple Whether the custom field can have multiple values.
					Multiple *bool `json:"multiple,omitempty"`

					// Name The name of the custom field.
					Name  *string      `json:"name,omitempty"`
					Value *interface{} `json:"value,omitempty"`
				} `json:"custom_fields,omitempty"`

				// Firstname The first name of the user.
				Firstname *string `json:"firstname,omitempty"`

				// Id The unique identifier of the user.
				Id *int `json:"id,omitempty"`

				// LastLoginOn The date and time when the user last logged in.
				LastLoginOn *time.Time `json:"last_login_on,omitempty"`

				// Lastname The last name of the user.
				Lastname *string `json:"lastname,omitempty"`

				// Login The login name of the user.
				Login *string `json:"login,omitempty"`

				// Mail The email address of the user.
				Mail *string `json:"mail,omitempty"`
			} `json:"user,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMyAccountPutResponse parses an HTTP response from a MyAccountPutWithResponse call
func ParseMyAccountPutResponse(rsp *http.Response) (*MyAccountPutResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MyAccountPutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest struct {
			Errors *[]string `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseNewsIndexResponse parses an HTTP response from a NewsIndexWithResponse call
func ParseNewsIndexResponse(rsp *http.Response) (*NewsIndexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NewsIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Limit The maximum number of news returned in the list.
			Limit *int `json:"limit,omitempty"`
			News  *[]struct {
				Author *struct {
					// Id The ID of the author.
					Id *int `json:"id,omitempty"`

					// Name The name of the author.
					Name *string `json:"name,omitempty"`
				} `json:"author,omitempty"`

				// CreatedOn The date and time when the news was created.
				CreatedOn *time.Time `json:"created_on,omitempty"`

				// Description The description of the news.
				Description *string `json:"description,omitempty"`

				// Id The ID of the news.
				Id      *int `json:"id,omitempty"`
				Project *struct {
					// Id The ID of the project.
					Id *int `json:"id,omitempty"`

					// Name The name of the project.
					Name *string `json:"name,omitempty"`
				} `json:"project,omitempty"`

				// Summary The summary of the news.
				Summary *string `json:"summary,omitempty"`

				// Title The title of the news.
				Title *string `json:"title,omitempty"`
			} `json:"news,omitempty"`

			// Offset The offset of the first news in the list.
			Offset *int `json:"offset,omitempty"`

			// TotalCount The total number of news.
			TotalCount *int `json:"total_count,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNewsCreateResponse parses an HTTP response from a NewsCreateWithResponse call
func ParseNewsCreateResponse(rsp *http.Response) (*NewsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NewsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest struct {
			Errors *[]string `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseNewsDestroyResponse parses an HTTP response from a NewsDestroyWithResponse call
func ParseNewsDestroyResponse(rsp *http.Response) (*NewsDestroyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NewsDestroyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNewsShowResponse parses an HTTP response from a NewsShowWithResponse call
func ParseNewsShowResponse(rsp *http.Response) (*NewsShowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NewsShowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// News A single news.
			News *struct {
				Attachments *[]NewsShow_200_News_Attachments_Item `json:"attachments,omitempty"`
				Author      *struct {
					// Id The ID of the author.
					Id *int `json:"id,omitempty"`

					// Name The name of the author.
					Name *string `json:"name,omitempty"`
				} `json:"author,omitempty"`
				Comments *[]struct {
					Author *struct {
						// Id The ID of the author.
						Id *int `json:"id,omitempty"`

						// Name The name of the author.
						Name *string `json:"name,omitempty"`
					} `json:"author,omitempty"`
					Content *string `json:"content,omitempty"`

					// Id The ID of the comment.
					Id *int `json:"id,omitempty"`
				} `json:"comments,omitempty"`

				// CreatedOn The date and time when the news was created.
				CreatedOn *time.Time `json:"created_on,omitempty"`

				// Description The description of the news.
				Description *string `json:"description,omitempty"`

				// Id The ID of the news.
				Id      *int `json:"id,omitempty"`
				Project *struct {
					// Id The ID of the project.
					Id *int `json:"id,omitempty"`

					// Name The name of the project.
					Name *string `json:"name,omitempty"`
				} `json:"project,omitempty"`

				// Summary The summary of the news.
				Summary *string `json:"summary,omitempty"`

				// Title The title of the news.
				Title *string `json:"title,omitempty"`
			} `json:"news,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNewsUpdatePatchResponse parses an HTTP response from a NewsUpdatePatchWithResponse call
func ParseNewsUpdatePatchResponse(rsp *http.Response) (*NewsUpdatePatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NewsUpdatePatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest struct {
			Errors *[]string `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseNewsUpdatePutResponse parses an HTTP response from a NewsUpdatePutWithResponse call
func ParseNewsUpdatePutResponse(rsp *http.Response) (*NewsUpdatePutResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NewsUpdatePutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest struct {
			Errors *[]string `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseProjectsIndexCsvResponse parses an HTTP response from a ProjectsIndexCsvWithResponse call
func ParseProjectsIndexCsvResponse(rsp *http.Response) (*ProjectsIndexCsvResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectsIndexCsvResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseProjectsIndexResponse parses an HTTP response from a ProjectsIndexWithResponse call
func ParseProjectsIndexResponse(rsp *http.Response) (*ProjectsIndexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectsIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Limit The maximum number of projects returned in the list.
			Limit *int `json:"limit,omitempty"`

			// Offset The offset of the first project in the list.
			Offset   *int `json:"offset,omitempty"`
			Projects *[]struct {
				// CreatedOn The date and time when the project was created.
				CreatedOn    *time.Time `json:"created_on,omitempty"`
				CustomFields *[]struct {
					// Id The ID of the custom field.
					Id *int `json:"id,omitempty"`

					// Multiple Whether the custom field can have multiple values.
					Multiple *bool `json:"multiple,omitempty"`

					// Name The name of the custom field.
					Name  *string      `json:"name,omitempty"`
					Value *interface{} `json:"value,omitempty"`
				} `json:"custom_fields,omitempty"`

				// Description The description of the project.
				Description    *string `json:"description,omitempty"`
				EnabledModules *[]struct {
					// Id The ID of the enabled module.
					Id *int `json:"id,omitempty"`

					// Name The name of the enabled module.
					Name *string `json:"name,omitempty"`
				} `json:"enabled_modules,omitempty"`

				// Homepage The homepage URL of the project.
				Homepage *string `json:"homepage,omitempty"`

				// Id The ID of the project.
				Id *int `json:"id,omitempty"`

				// Identifier The identifier of the project.
				Identifier *string `json:"identifier,omitempty"`

				// InheritMembers Whether the project inherits members from its parent project. `true` if it does, `false` if it does not.
				InheritMembers *bool `json:"inherit_members,omitempty"`

				// IsPublic The visibility of the project. `true` if the project is public, `false` if it is private.
				IsPublic        *bool `json:"is_public,omitempty"`
				IssueCategories *[]struct {
					// Id The ID of the issue category.
					Id *int `json:"id,omitempty"`

					// Name The name of the issue category.
					Name *string `json:"name,omitempty"`
				} `json:"issue_categories,omitempty"`
				IssueCustomFields *[]struct {
					// Id The ID of the issue custom field.
					Id *int `json:"id,omitempty"`

					// Name The name of the issue custom field.
					Name *string `json:"name,omitempty"`
				} `json:"issue_custom_fields,omitempty"`

				// Name The name of the project.
				Name *string `json:"name,omitempty"`

				// Parent The parent project of the project. If the project has no parent, this will be `null`.
				Parent *struct {
					// Id The ID of the parent project.
					Id *int `json:"id,omitempty"`

					// Name The name of the parent project.
					Name *string `json:"name,omitempty"`
				} `json:"parent,omitempty"`

				// Status The status of the project. Possible values are:
				// - `1`: active
				// - `5`: closed
				// - `9`: archived
				// - `10`: scheduled for deletion
				Status              *int `json:"status,omitempty"`
				TimeEntryActivities *[]struct {
					// Id The ID of the time entry activity.
					Id *int `json:"id,omitempty"`

					// Name The name of the time entry activity.
					Name *string `json:"name,omitempty"`
				} `json:"time_entry_activities,omitempty"`
				Trackers *[]struct {
					// Id The ID of the tracker.
					Id *int `json:"id,omitempty"`

					// Name The name of the tracker.
					Name *string `json:"name,omitempty"`
				} `json:"trackers,omitempty"`

				// UpdatedOn The date and time when the project was last updated.
				UpdatedOn *time.Time `json:"updated_on,omitempty"`
			} `json:"projects,omitempty"`

			// TotalCount The total number of projects.
			TotalCount *int `json:"total_count,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseProjectsCreateResponse parses an HTTP response from a ProjectsCreateWithResponse call
func ParseProjectsCreateResponse(rsp *http.Response) (*ProjectsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Project A single project.
			Project *struct {
				// CreatedOn The date and time when the project was created.
				CreatedOn    *time.Time `json:"created_on,omitempty"`
				CustomFields *[]struct {
					// Id The ID of the custom field.
					Id *int `json:"id,omitempty"`

					// Multiple Whether the custom field can have multiple values.
					Multiple *bool `json:"multiple,omitempty"`

					// Name The name of the custom field.
					Name  *string      `json:"name,omitempty"`
					Value *interface{} `json:"value,omitempty"`
				} `json:"custom_fields,omitempty"`

				// DefaultAssignee The default assignee of the project. If the project has no default assignee, this will be `null`.
				DefaultAssignee *struct {
					// Id The ID of the default assignee.
					Id *int `json:"id,omitempty"`

					// Name The name of the default assignee.
					Name *string `json:"name,omitempty"`
				} `json:"default_assignee,omitempty"`

				// DefaultVersion The default version of the project. If the project has no default version, this will be `null`.
				DefaultVersion *struct {
					// Id The ID of the default version.
					Id *int `json:"id,omitempty"`

					// Name The name of the default version.
					Name *string `json:"name,omitempty"`
				} `json:"default_version,omitempty"`

				// Description The description of the project.
				Description    *string `json:"description,omitempty"`
				EnabledModules *[]struct {
					// Id The ID of the enabled module.
					Id *int `json:"id,omitempty"`

					// Name The name of the enabled module.
					Name *string `json:"name,omitempty"`
				} `json:"enabled_modules,omitempty"`

				// Homepage The homepage URL of the project.
				Homepage *string `json:"homepage,omitempty"`

				// Id The ID of the project.
				Id *int `json:"id,omitempty"`

				// Identifier The identifier of the project.
				Identifier *string `json:"identifier,omitempty"`

				// InheritMembers Whether the project inherits members from its parent project. `true` if it does, `false` if it does not.
				InheritMembers *bool `json:"inherit_members,omitempty"`

				// IsPublic The visibility of the project. `true` if the project is public, `false` if it is private.
				IsPublic        *bool `json:"is_public,omitempty"`
				IssueCategories *[]struct {
					// Id The ID of the issue category.
					Id *int `json:"id,omitempty"`

					// Name The name of the issue category.
					Name *string `json:"name,omitempty"`
				} `json:"issue_categories,omitempty"`
				IssueCustomFields *[]struct {
					// Id The ID of the issue custom field.
					Id *int `json:"id,omitempty"`

					// Name The name of the issue custom field.
					Name *string `json:"name,omitempty"`
				} `json:"issue_custom_fields,omitempty"`

				// Name The name of the project.
				Name *string `json:"name,omitempty"`

				// Parent The parent project of the project. If the project has no parent, this will be `null`.
				Parent *struct {
					// Id The ID of the parent project.
					Id *int `json:"id,omitempty"`

					// Name The name of the parent project.
					Name *string `json:"name,omitempty"`
				} `json:"parent,omitempty"`

				// Status The status of the project. Possible values are:
				// - `1`: active
				// - `5`: closed
				// - `9`: archived
				// - `10`: scheduled for deletion
				Status              *int `json:"status,omitempty"`
				TimeEntryActivities *[]struct {
					// Id The ID of the time entry activity.
					Id *int `json:"id,omitempty"`

					// Name The name of the time entry activity.
					Name *string `json:"name,omitempty"`
				} `json:"time_entry_activities,omitempty"`
				Trackers *[]struct {
					// Id The ID of the tracker.
					Id *int `json:"id,omitempty"`

					// Name The name of the tracker.
					Name *string `json:"name,omitempty"`
				} `json:"trackers,omitempty"`

				// UpdatedOn The date and time when the project was last updated.
				UpdatedOn *time.Time `json:"updated_on,omitempty"`
			} `json:"project,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest struct {
			Errors *[]string `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseProjectsDestroyResponse parses an HTTP response from a ProjectsDestroyWithResponse call
func ParseProjectsDestroyResponse(rsp *http.Response) (*ProjectsDestroyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectsDestroyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseProjectsShowResponse parses an HTTP response from a ProjectsShowWithResponse call
func ParseProjectsShowResponse(rsp *http.Response) (*ProjectsShowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectsShowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Project A single project.
			Project *struct {
				// CreatedOn The date and time when the project was created.
				CreatedOn    *time.Time `json:"created_on,omitempty"`
				CustomFields *[]struct {
					// Id The ID of the custom field.
					Id *int `json:"id,omitempty"`

					// Multiple Whether the custom field can have multiple values.
					Multiple *bool `json:"multiple,omitempty"`

					// Name The name of the custom field.
					Name  *string      `json:"name,omitempty"`
					Value *interface{} `json:"value,omitempty"`
				} `json:"custom_fields,omitempty"`

				// DefaultAssignee The default assignee of the project. If the project has no default assignee, this will be `null`.
				DefaultAssignee *struct {
					// Id The ID of the default assignee.
					Id *int `json:"id,omitempty"`

					// Name The name of the default assignee.
					Name *string `json:"name,omitempty"`
				} `json:"default_assignee,omitempty"`

				// DefaultVersion The default version of the project. If the project has no default version, this will be `null`.
				DefaultVersion *struct {
					// Id The ID of the default version.
					Id *int `json:"id,omitempty"`

					// Name The name of the default version.
					Name *string `json:"name,omitempty"`
				} `json:"default_version,omitempty"`

				// Description The description of the project.
				Description    *string `json:"description,omitempty"`
				EnabledModules *[]struct {
					// Id The ID of the enabled module.
					Id *int `json:"id,omitempty"`

					// Name The name of the enabled module.
					Name *string `json:"name,omitempty"`
				} `json:"enabled_modules,omitempty"`

				// Homepage The homepage URL of the project.
				Homepage *string `json:"homepage,omitempty"`

				// Id The ID of the project.
				Id *int `json:"id,omitempty"`

				// Identifier The identifier of the project.
				Identifier *string `json:"identifier,omitempty"`

				// InheritMembers Whether the project inherits members from its parent project. `true` if it does, `false` if it does not.
				InheritMembers *bool `json:"inherit_members,omitempty"`

				// IsPublic The visibility of the project. `true` if the project is public, `false` if it is private.
				IsPublic        *bool `json:"is_public,omitempty"`
				IssueCategories *[]struct {
					// Id The ID of the issue category.
					Id *int `json:"id,omitempty"`

					// Name The name of the issue category.
					Name *string `json:"name,omitempty"`
				} `json:"issue_categories,omitempty"`
				IssueCustomFields *[]struct {
					// Id The ID of the issue custom field.
					Id *int `json:"id,omitempty"`

					// Name The name of the issue custom field.
					Name *string `json:"name,omitempty"`
				} `json:"issue_custom_fields,omitempty"`

				// Name The name of the project.
				Name *string `json:"name,omitempty"`

				// Parent The parent project of the project. If the project has no parent, this will be `null`.
				Parent *struct {
					// Id The ID of the parent project.
					Id *int `json:"id,omitempty"`

					// Name The name of the parent project.
					Name *string `json:"name,omitempty"`
				} `json:"parent,omitempty"`

				// Status The status of the project. Possible values are:
				// - `1`: active
				// - `5`: closed
				// - `9`: archived
				// - `10`: scheduled for deletion
				Status              *int `json:"status,omitempty"`
				TimeEntryActivities *[]struct {
					// Id The ID of the time entry activity.
					Id *int `json:"id,omitempty"`

					// Name The name of the time entry activity.
					Name *string `json:"name,omitempty"`
				} `json:"time_entry_activities,omitempty"`
				Trackers *[]struct {
					// Id The ID of the tracker.
					Id *int `json:"id,omitempty"`

					// Name The name of the tracker.
					Name *string `json:"name,omitempty"`
				} `json:"trackers,omitempty"`

				// UpdatedOn The date and time when the project was last updated.
				UpdatedOn *time.Time `json:"updated_on,omitempty"`
			} `json:"project,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseProjectsUpdatePatchResponse parses an HTTP response from a ProjectsUpdatePatchWithResponse call
func ParseProjectsUpdatePatchResponse(rsp *http.Response) (*ProjectsUpdatePatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectsUpdatePatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest struct {
			Errors *[]string `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseProjectsUpdatePutResponse parses an HTTP response from a ProjectsUpdatePutWithResponse call
func ParseProjectsUpdatePutResponse(rsp *http.Response) (*ProjectsUpdatePutResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectsUpdatePutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest struct {
			Errors *[]string `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseProjectsArchivePostResponse parses an HTTP response from a ProjectsArchivePostWithResponse call
func ParseProjectsArchivePostResponse(rsp *http.Response) (*ProjectsArchivePostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectsArchivePostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest struct {
			Errors *[]string `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseProjectsArchivePutResponse parses an HTTP response from a ProjectsArchivePutWithResponse call
func ParseProjectsArchivePutResponse(rsp *http.Response) (*ProjectsArchivePutResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectsArchivePutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest struct {
			Errors *[]string `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseRepositoriesAddRelatedIssueResponse parses an HTTP response from a RepositoriesAddRelatedIssueWithResponse call
func ParseRepositoriesAddRelatedIssueResponse(rsp *http.Response) (*RepositoriesAddRelatedIssueResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RepositoriesAddRelatedIssueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest struct {
			Errors *[]string `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseRepositoriesRemoveRelatedIssueResponse parses an HTTP response from a RepositoriesRemoveRelatedIssueWithResponse call
func ParseRepositoriesRemoveRelatedIssueResponse(rsp *http.Response) (*RepositoriesRemoveRelatedIssueResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RepositoriesRemoveRelatedIssueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseProjectsUnarchivePostResponse parses an HTTP response from a ProjectsUnarchivePostWithResponse call
func ParseProjectsUnarchivePostResponse(rsp *http.Response) (*ProjectsUnarchivePostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectsUnarchivePostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseProjectsUnarchivePutResponse parses an HTTP response from a ProjectsUnarchivePutWithResponse call
func ParseProjectsUnarchivePutResponse(rsp *http.Response) (*ProjectsUnarchivePutResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectsUnarchivePutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseFilesIndexResponse parses an HTTP response from a FilesIndexWithResponse call
func ParseFilesIndexResponse(rsp *http.Response) (*FilesIndexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FilesIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Files *[]FilesIndex_200_Files_Item `json:"files,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFilesCreateResponse parses an HTTP response from a FilesCreateWithResponse call
func ParseFilesCreateResponse(rsp *http.Response) (*FilesCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FilesCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseIssueCategoriesIndexResponse parses an HTTP response from a IssueCategoriesIndexWithResponse call
func ParseIssueCategoriesIndexResponse(rsp *http.Response) (*IssueCategoriesIndexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssueCategoriesIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IssueCategories *[]struct {
				AssignedTo *struct {
					// Id The ID of the assigned to.
					Id *int `json:"id,omitempty"`

					// Name The name of the assigned to.
					Name *string `json:"name,omitempty"`
				} `json:"assigned_to,omitempty"`

				// Id The ID of the issue category.
				Id *int `json:"id,omitempty"`

				// Name The name of the issue category.
				Name    *string `json:"name,omitempty"`
				Project *struct {
					// Id The ID of the project.
					Id *int `json:"id,omitempty"`

					// Name The name of the project.
					Name *string `json:"name,omitempty"`
				} `json:"project,omitempty"`
			} `json:"issue_categories,omitempty"`

			// TotalCount The total number of issue categories.
			TotalCount *int `json:"total_count,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseIssueCategoriesCreateResponse parses an HTTP response from a IssueCategoriesCreateWithResponse call
func ParseIssueCategoriesCreateResponse(rsp *http.Response) (*IssueCategoriesCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssueCategoriesCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// IssueCategory A single issue category.
			IssueCategory *struct {
				AssignedTo *struct {
					// Id The ID of the assigned to.
					Id *int `json:"id,omitempty"`

					// Name The name of the assigned to.
					Name *string `json:"name,omitempty"`
				} `json:"assigned_to,omitempty"`

				// Id The ID of the issue category.
				Id *int `json:"id,omitempty"`

				// Name The name of the issue category.
				Name    *string `json:"name,omitempty"`
				Project *struct {
					// Id The ID of the project.
					Id *int `json:"id,omitempty"`

					// Name The name of the project.
					Name *string `json:"name,omitempty"`
				} `json:"project,omitempty"`
			} `json:"issue_category,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest struct {
			Errors *[]string `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseIssuesIndexProjectCsvResponse parses an HTTP response from a IssuesIndexProjectCsvWithResponse call
func ParseIssuesIndexProjectCsvResponse(rsp *http.Response) (*IssuesIndexProjectCsvResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssuesIndexProjectCsvResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest struct {
			Errors *[]string `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseIssuesIndexProjectResponse parses an HTTP response from a IssuesIndexProjectWithResponse call
func ParseIssuesIndexProjectResponse(rsp *http.Response) (*IssuesIndexProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssuesIndexProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Issues *[]struct {
				AssignedTo *struct {
					// Id The ID of the assigned member.
					Id *int `json:"id,omitempty"`

					// Name The name of the assigned member.
					Name *string `json:"name,omitempty"`
				} `json:"assigned_to,omitempty"`
				Attachments *[]IssuesIndexProject_200_Issues_Attachments_Item `json:"attachments,omitempty"`
				Author      *struct {
					// Id The ID of the author.
					Id *int `json:"id,omitempty"`

					// Name The name of the author.
					Name *string `json:"name,omitempty"`
				} `json:"author,omitempty"`
				Category *struct {
					// Id The ID of the category.
					Id *int `json:"id,omitempty"`

					// Name The name of the category.
					Name *string `json:"name,omitempty"`
				} `json:"category,omitempty"`

				// ClosedOn The date and time when the issue was closed.
				ClosedOn *time.Time `json:"closed_on,omitempty"`

				// CreatedOn The date and time when the issue was created.
				CreatedOn    *time.Time `json:"created_on,omitempty"`
				CustomFields *[]struct {
					// Id The ID of the custom field.
					Id *int `json:"id,omitempty"`

					// Multiple Whether the custom field can have multiple values.
					Multiple *bool `json:"multiple,omitempty"`

					// Name The name of the custom field.
					Name  *string      `json:"name,omitempty"`
					Value *interface{} `json:"value,omitempty"`
				} `json:"custom_fields,omitempty"`

				// Description The description of the issue.
				Description *string `json:"description,omitempty"`

				// DoneRatio The done ratio of the issue.
				DoneRatio *int `json:"done_ratio,omitempty"`

				// DueDate The due date of the issue.
				DueDate *openapi_types.Date `json:"due_date,omitempty"`

				// EstimatedHours The estimated hours of the issue.
				EstimatedHours *float32 `json:"estimated_hours,omitempty"`
				FixedVersion   *struct {
					// Id The ID of the fixed version.
					Id *int `json:"id,omitempty"`

					// Name The name of the fixed version.
					Name *string `json:"name,omitempty"`
				} `json:"fixed_version,omitempty"`

				// Id The ID of the issue.
				Id *int `json:"id,omitempty"`

				// IsPrivate The private of the issue.
				IsPrivate *bool `json:"is_private,omitempty"`
				Parent    *struct {
					// Id The ID of the parent issue.
					Id *int `json:"id,omitempty"`
				} `json:"parent,omitempty"`
				Priority *struct {
					// Id The ID of the priority.
					Id *int `json:"id,omitempty"`

					// Name The name of the priority.
					Name *string `json:"name,omitempty"`
				} `json:"priority,omitempty"`
				Project *struct {
					// Id The ID of the project.
					Id *int `json:"id,omitempty"`

					// Name The name of the project.
					Name *string `json:"name,omitempty"`
				} `json:"project,omitempty"`
				Relations *[]struct {
					// Delay The delay of the relation.
					Delay *int `json:"delay,omitempty"`

					// Id The ID of the relation.
					Id *int `json:"id,omitempty"`

					// IssueId The ID of the issue.
					IssueId *int `json:"issue_id,omitempty"`

					// IssueToId The ID of the issue.
					IssueToId *int `json:"issue_to_id,omitempty"`

					// RelationType The type of the relation.
					RelationType *string `json:"relation_type,omitempty"`
				} `json:"relations,omitempty"`

				// SpentHours The spent hours of the issue.
				SpentHours *float32 `json:"spent_hours,omitempty"`

				// StartDate The start date of the issue.
				StartDate *openapi_types.Date `json:"start_date,omitempty"`
				Status    *struct {
					// Id The ID of the status.
					Id *int `json:"id,omitempty"`

					// IsClosed The closed of the status.
					IsClosed *bool `json:"is_closed,omitempty"`

					// Name The name of the status.
					Name *string `json:"name,omitempty"`
				} `json:"status,omitempty"`

				// Subject The subject of the issue.
				Subject *string `json:"subject,omitempty"`

				// TotalEstimatedHours The total estimated hours of the issue.
				TotalEstimatedHours *float32 `json:"total_estimated_hours,omitempty"`

				// TotalSpentHours The total spent hours of the issue.
				TotalSpentHours *float32 `json:"total_spent_hours,omitempty"`
				Tracker         *struct {
					// Id The ID of the tracker.
					Id *int `json:"id,omitempty"`

					// Name The name of the tracker.
					Name *string `json:"name,omitempty"`
				} `json:"tracker,omitempty"`

				// UpdatedOn The date and time when the issue was updated.
				UpdatedOn *time.Time `json:"updated_on,omitempty"`
			} `json:"issues,omitempty"`

			// Limit The maximum number of issues returned in the list.
			Limit *int `json:"limit,omitempty"`

			// Offset The offset of the first issue in the list.
			Offset *int `json:"offset,omitempty"`

			// TotalCount The total number of issues.
			TotalCount *int `json:"total_count,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest struct {
			Errors *[]string `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseIssuesCreateProjectResponse parses an HTTP response from a IssuesCreateProjectWithResponse call
func ParseIssuesCreateProjectResponse(rsp *http.Response) (*IssuesCreateProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssuesCreateProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Issue A single issue.
			Issue *struct {
				AllowedStatuses *[]struct {
					// Id The ID of the allowed statuse.
					Id *int `json:"id,omitempty"`

					// IsClosed The closed of the allowed status.
					IsClosed *bool `json:"is_closed,omitempty"`

					// Name The name of the allowed statuse.
					Name *string `json:"name,omitempty"`
				} `json:"allowed_statuses,omitempty"`
				AssignedTo *struct {
					// Id The ID of the assigned member.
					Id *int `json:"id,omitempty"`

					// Name The name of the assigned member.
					Name *string `json:"name,omitempty"`
				} `json:"assigned_to,omitempty"`
				Attachments *[]IssuesCreateProject_201_Issue_Attachments_Item `json:"attachments,omitempty"`
				Author      *struct {
					// Id The ID of the author.
					Id *int `json:"id,omitempty"`

					// Name The name of the author.
					Name *string `json:"name,omitempty"`
				} `json:"author,omitempty"`
				Category *struct {
					// Id The ID of the category.
					Id *int `json:"id,omitempty"`

					// Name The name of the category.
					Name *string `json:"name,omitempty"`
				} `json:"category,omitempty"`
				Changesets *[]struct {
					// Comments The comments of the changeset.
					Comments *string `json:"comments,omitempty"`

					// CommittedOn The date and time when the changeset was committed.
					CommittedOn *time.Time `json:"committed_on,omitempty"`

					// Revision The revision of the changeset.
					Revision *string `json:"revision,omitempty"`
					User     *struct {
						// Id The ID of the user.
						Id *int `json:"id,omitempty"`

						// Name The name of the user.
						Name *string `json:"name,omitempty"`
					} `json:"user,omitempty"`
				} `json:"changesets,omitempty"`
				Children *[]struct {
					Children *[]interface{} `json:"children,omitempty"`

					// Id The ID of the issue.
					Id *int `json:"id,omitempty"`

					// Subject The subject of the issue.
					Subject *string `json:"subject,omitempty"`
					Tracker *struct {
						// Id The ID of the tracker.
						Id *int `json:"id,omitempty"`

						// Name The name of the tracker.
						Name *string `json:"name,omitempty"`
					} `json:"tracker,omitempty"`
				} `json:"children,omitempty"`

				// ClosedOn The date and time when the issue was closed.
				ClosedOn *time.Time `json:"closed_on,omitempty"`

				// CreatedOn The date and time when the issue was created.
				CreatedOn    *time.Time `json:"created_on,omitempty"`
				CustomFields *[]struct {
					// Id The ID of the custom field.
					Id *int `json:"id,omitempty"`

					// Multiple Whether the custom field can have multiple values.
					Multiple *bool `json:"multiple,omitempty"`

					// Name The name of the custom field.
					Name  *string      `json:"name,omitempty"`
					Value *interface{} `json:"value,omitempty"`
				} `json:"custom_fields,omitempty"`

				// Description The description of the issue.
				Description *string `json:"description,omitempty"`

				// DoneRatio The done ratio of the issue.
				DoneRatio *int `json:"done_ratio,omitempty"`

				// DueDate The due date of the issue.
				DueDate *openapi_types.Date `json:"due_date,omitempty"`

				// EstimatedHours The estimated hours of the issue.
				EstimatedHours *float32 `json:"estimated_hours,omitempty"`
				FixedVersion   *struct {
					// Id The ID of the fixed version.
					Id *int `json:"id,omitempty"`

					// Name The name of the fixed version.
					Name *string `json:"name,omitempty"`
				} `json:"fixed_version,omitempty"`

				// Id The ID of the issue.
				Id *int `json:"id,omitempty"`

				// IsPrivate The private of the issue.
				IsPrivate *bool `json:"is_private,omitempty"`
				Journals  *[]struct {
					// CreatedOn The date and time when the journal was created.
					CreatedOn *time.Time `json:"created_on,omitempty"`
					Details   *[]struct {
						// Name The name of the detail.
						Name *string `json:"name,omitempty"`

						// NewValue The new value of the detail.
						NewValue *string `json:"new_value,omitempty"`

						// OldValue The old value of the detail.
						OldValue *string `json:"old_value,omitempty"`

						// Property The property of the detail.
						Property *string `json:"property,omitempty"`
					} `json:"details,omitempty"`

					// Id The ID of the journal.
					Id *int `json:"id,omitempty"`

					// Notes The notes of the journal.
					Notes *string `json:"notes,omitempty"`

					// PrivateNotes The private of the journal.
					PrivateNotes *bool `json:"private_notes,omitempty"`
					UpdatedBy    *struct {
						// Id The ID of the updated.
						Id *int `json:"id,omitempty"`

						// Name The name of the updated.
						Name *string `json:"name,omitempty"`
					} `json:"updated_by,omitempty"`

					// UpdatedOn The date and time when the journal was updated.
					UpdatedOn *time.Time `json:"updated_on,omitempty"`
					User      *struct {
						// Id The ID of the user.
						Id *int `json:"id,omitempty"`

						// Name The name of the user.
						Name *string `json:"name,omitempty"`
					} `json:"user,omitempty"`
				} `json:"journals,omitempty"`
				Parent *struct {
					// Id The ID of the parent issue.
					Id *int `json:"id,omitempty"`
				} `json:"parent,omitempty"`
				Priority *struct {
					// Id The ID of the priority.
					Id *int `json:"id,omitempty"`

					// Name The name of the priority.
					Name *string `json:"name,omitempty"`
				} `json:"priority,omitempty"`
				Project *struct {
					// Id The ID of the project.
					Id *int `json:"id,omitempty"`

					// Name The name of the project.
					Name *string `json:"name,omitempty"`
				} `json:"project,omitempty"`
				Relations *[]struct {
					// Delay The delay of the relation.
					Delay *int `json:"delay,omitempty"`

					// Id The ID of the relation.
					Id *int `json:"id,omitempty"`

					// IssueId The ID of the issue.
					IssueId *int `json:"issue_id,omitempty"`

					// IssueToId The ID of the issue.
					IssueToId *int `json:"issue_to_id,omitempty"`

					// RelationType The type of the relation.
					RelationType *string `json:"relation_type,omitempty"`
				} `json:"relations,omitempty"`

				// SpentHours The spent hours of the issue.
				SpentHours *float32 `json:"spent_hours,omitempty"`

				// StartDate The start date of the issue.
				StartDate *openapi_types.Date `json:"start_date,omitempty"`
				Status    *struct {
					// Id The ID of the status.
					Id *int `json:"id,omitempty"`

					// IsClosed The closed of the status.
					IsClosed *bool `json:"is_closed,omitempty"`

					// Name The name of the status.
					Name *string `json:"name,omitempty"`
				} `json:"status,omitempty"`

				// Subject The subject of the issue.
				Subject *string `json:"subject,omitempty"`

				// TotalEstimatedHours The total estimated hours of the issue.
				TotalEstimatedHours *float32 `json:"total_estimated_hours,omitempty"`

				// TotalSpentHours The total spent hours of the issue.
				TotalSpentHours *float32 `json:"total_spent_hours,omitempty"`
				Tracker         *struct {
					// Id The ID of the tracker.
					Id *int `json:"id,omitempty"`

					// Name The name of the tracker.
					Name *string `json:"name,omitempty"`
				} `json:"tracker,omitempty"`

				// UpdatedOn The date and time when the issue was updated.
				UpdatedOn *time.Time `json:"updated_on,omitempty"`
				Watchers  *[]struct {
					// Id The ID of the watcher.
					Id *int `json:"id,omitempty"`

					// Name The name of the watcher.
					Name *string `json:"name,omitempty"`
				} `json:"watchers,omitempty"`
			} `json:"issue,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest struct {
			Errors *[]string `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseIssuesIndexProjectPdfResponse parses an HTTP response from a IssuesIndexProjectPdfWithResponse call
func ParseIssuesIndexProjectPdfResponse(rsp *http.Response) (*IssuesIndexProjectPdfResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssuesIndexProjectPdfResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest struct {
			Errors *[]string `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGanttsShowProjectPdfResponse parses an HTTP response from a GanttsShowProjectPdfWithResponse call
func ParseGanttsShowProjectPdfResponse(rsp *http.Response) (*GanttsShowProjectPdfResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GanttsShowProjectPdfResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGanttsShowProjectPngResponse parses an HTTP response from a GanttsShowProjectPngWithResponse call
func ParseGanttsShowProjectPngResponse(rsp *http.Response) (*GanttsShowProjectPngResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GanttsShowProjectPngResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseMembersIndexResponse parses an HTTP response from a MembersIndexWithResponse call
func ParseMembersIndexResponse(rsp *http.Response) (*MembersIndexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MembersIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Limit The maximum number of memberships returned in the list.
			Limit       *int `json:"limit,omitempty"`
			Memberships *[]struct {
				Group *struct {
					// Id The ID of the group.
					Id *int `json:"id,omitempty"`

					// Name The name of the group.
					Name *string `json:"name,omitempty"`
				} `json:"group,omitempty"`

				// Id The ID of the membership.
				Id      *int `json:"id,omitempty"`
				Project *struct {
					// Id The ID of the project.
					Id *int `json:"id,omitempty"`

					// Name The name of the project.
					Name *string `json:"name,omitempty"`
				} `json:"project,omitempty"`
				Roles *[]struct {
					// Id The ID of the role.
					Id *int `json:"id,omitempty"`

					// Inherited Whether the role is inherited from a parent project.
					Inherited *bool `json:"inherited,omitempty"`

					// Name The name of the role.
					Name *string `json:"name,omitempty"`
				} `json:"roles,omitempty"`
				User *struct {
					// Id The ID of the user.
					Id *int `json:"id,omitempty"`

					// Name The name of the user.
					Name *string `json:"name,omitempty"`
				} `json:"user,omitempty"`
			} `json:"memberships,omitempty"`

			// Offset The offset of the first membership in the list.
			Offset *int `json:"offset,omitempty"`

			// TotalCount The total number of memberships.
			TotalCount *int `json:"total_count,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMembersCreateResponse parses an HTTP response from a MembersCreateWithResponse call
func ParseMembersCreateResponse(rsp *http.Response) (*MembersCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MembersCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Membership A single membership.
			Membership *struct {
				Group *struct {
					// Id The ID of the group.
					Id *int `json:"id,omitempty"`

					// Name The name of the group.
					Name *string `json:"name,omitempty"`
				} `json:"group,omitempty"`

				// Id The ID of the membership.
				Id      *int `json:"id,omitempty"`
				Project *struct {
					// Id The ID of the project.
					Id *int `json:"id,omitempty"`

					// Name The name of the project.
					Name *string `json:"name,omitempty"`
				} `json:"project,omitempty"`
				Roles *[]struct {
					// Id The ID of the role.
					Id *int `json:"id,omitempty"`

					// Inherited Whether the role is inherited from a parent project.
					Inherited *bool `json:"inherited,omitempty"`

					// Name The name of the role.
					Name *string `json:"name,omitempty"`
				} `json:"roles,omitempty"`
				User *struct {
					// Id The ID of the user.
					Id *int `json:"id,omitempty"`

					// Name The name of the user.
					Name *string `json:"name,omitempty"`
				} `json:"user,omitempty"`
			} `json:"membership,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest struct {
			Errors *[]string `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseNewsIndexProjectResponse parses an HTTP response from a NewsIndexProjectWithResponse call
func ParseNewsIndexProjectResponse(rsp *http.Response) (*NewsIndexProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NewsIndexProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Limit The maximum number of news returned in the list.
			Limit *int `json:"limit,omitempty"`
			News  *[]struct {
				Author *struct {
					// Id The ID of the author.
					Id *int `json:"id,omitempty"`

					// Name The name of the author.
					Name *string `json:"name,omitempty"`
				} `json:"author,omitempty"`

				// CreatedOn The date and time when the news was created.
				CreatedOn *time.Time `json:"created_on,omitempty"`

				// Description The description of the news.
				Description *string `json:"description,omitempty"`

				// Id The ID of the news.
				Id      *int `json:"id,omitempty"`
				Project *struct {
					// Id The ID of the project.
					Id *int `json:"id,omitempty"`

					// Name The name of the project.
					Name *string `json:"name,omitempty"`
				} `json:"project,omitempty"`

				// Summary The summary of the news.
				Summary *string `json:"summary,omitempty"`

				// Title The title of the news.
				Title *string `json:"title,omitempty"`
			} `json:"news,omitempty"`

			// Offset The offset of the first news in the list.
			Offset *int `json:"offset,omitempty"`

			// TotalCount The total number of news.
			TotalCount *int `json:"total_count,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNewsCreateProjectResponse parses an HTTP response from a NewsCreateProjectWithResponse call
func ParseNewsCreateProjectResponse(rsp *http.Response) (*NewsCreateProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NewsCreateProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest struct {
			Errors *[]string `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseSearchIndexProjectResponse parses an HTTP response from a SearchIndexProjectWithResponse call
func ParseSearchIndexProjectResponse(rsp *http.Response) (*SearchIndexProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchIndexProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Limit The maximum number of search results returned in the list.
			Limit *int `json:"limit,omitempty"`

			// Offset The offset of the first search result in the list.
			Offset  *int `json:"offset,omitempty"`
			Results *[]struct {
				// Datetime The date and time when the search result was created.
				Datetime *time.Time `json:"datetime,omitempty"`

				// Description The description of the search result.
				Description *string `json:"description,omitempty"`

				// Id The ID of the search result.
				Id *int `json:"id,omitempty"`

				// Title The title of the search result.
				Title *string `json:"title,omitempty"`

				// Type The type of the search result.
				Type *string `json:"type,omitempty"`

				// Url The url of the search result.
				Url *string `json:"url,omitempty"`
			} `json:"results,omitempty"`

			// TotalCount The total number of search results.
			TotalCount *int `json:"total_count,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTimelogIndexProjectCsvResponse parses an HTTP response from a TimelogIndexProjectCsvWithResponse call
func ParseTimelogIndexProjectCsvResponse(rsp *http.Response) (*TimelogIndexProjectCsvResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TimelogIndexProjectCsvResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTimelogIndexProjectResponse parses an HTTP response from a TimelogIndexProjectWithResponse call
func ParseTimelogIndexProjectResponse(rsp *http.Response) (*TimelogIndexProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TimelogIndexProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Limit The maximum number of time entries returned in the list.
			Limit *int `json:"limit,omitempty"`

			// Offset The offset of the first time entry in the list.
			Offset      *int `json:"offset,omitempty"`
			TimeEntries *[]struct {
				Activity *struct {
					// Id The ID of the activity.
					Id *int `json:"id,omitempty"`

					// Name The name of the activity.
					Name *string `json:"name,omitempty"`
				} `json:"activity,omitempty"`

				// Comments The comments of the time entry.
				Comments *string `json:"comments,omitempty"`

				// CreatedOn The date and time when the time entry was created.
				CreatedOn    *time.Time `json:"created_on,omitempty"`
				CustomFields *[]struct {
					// Id The ID of the custom field.
					Id *int `json:"id,omitempty"`

					// Multiple Whether the custom field can have multiple values.
					Multiple *bool `json:"multiple,omitempty"`

					// Name The name of the custom field.
					Name  *string      `json:"name,omitempty"`
					Value *interface{} `json:"value,omitempty"`
				} `json:"custom_fields,omitempty"`

				// Hours The hours of the time entry.
				Hours *float32 `json:"hours,omitempty"`

				// Id The ID of the time entry.
				Id    *int `json:"id,omitempty"`
				Issue *struct {
					// Id The ID of the issue.
					Id *int `json:"id,omitempty"`
				} `json:"issue,omitempty"`
				Project *struct {
					// Id The ID of the project.
					Id *int `json:"id,omitempty"`

					// Name The name of the project.
					Name *string `json:"name,omitempty"`
				} `json:"project,omitempty"`

				// SpentOn The date when the time entry was spent.
				SpentOn *openapi_types.Date `json:"spent_on,omitempty"`

				// UpdatedOn The date and time when the time entry was last updated.
				UpdatedOn *time.Time `json:"updated_on,omitempty"`
				User      *struct {
					// Id The ID of the user.
					Id *int `json:"id,omitempty"`

					// Name The name of the user.
					Name *string `json:"name,omitempty"`
				} `json:"user,omitempty"`
			} `json:"time_entries,omitempty"`

			// TotalCount The total number of time entries.
			TotalCount *int `json:"total_count,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTimelogCreateProjectResponse parses an HTTP response from a TimelogCreateProjectWithResponse call
func ParseTimelogCreateProjectResponse(rsp *http.Response) (*TimelogCreateProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TimelogCreateProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// TimeEntry A single time entry.
			TimeEntry *struct {
				Activity *struct {
					// Id The ID of the activity.
					Id *int `json:"id,omitempty"`

					// Name The name of the activity.
					Name *string `json:"name,omitempty"`
				} `json:"activity,omitempty"`

				// Comments The comments of the time entry.
				Comments *string `json:"comments,omitempty"`

				// CreatedOn The date and time when the time entry was created.
				CreatedOn    *time.Time `json:"created_on,omitempty"`
				CustomFields *[]struct {
					// Id The ID of the custom field.
					Id *int `json:"id,omitempty"`

					// Multiple Whether the custom field can have multiple values.
					Multiple *bool `json:"multiple,omitempty"`

					// Name The name of the custom field.
					Name  *string      `json:"name,omitempty"`
					Value *interface{} `json:"value,omitempty"`
				} `json:"custom_fields,omitempty"`

				// Hours The hours of the time entry.
				Hours *float32 `json:"hours,omitempty"`

				// Id The ID of the time entry.
				Id    *int `json:"id,omitempty"`
				Issue *struct {
					// Id The ID of the issue.
					Id *int `json:"id,omitempty"`
				} `json:"issue,omitempty"`
				Project *struct {
					// Id The ID of the project.
					Id *int `json:"id,omitempty"`

					// Name The name of the project.
					Name *string `json:"name,omitempty"`
				} `json:"project,omitempty"`

				// SpentOn The date when the time entry was spent.
				SpentOn *openapi_types.Date `json:"spent_on,omitempty"`

				// UpdatedOn The date and time when the time entry was last updated.
				UpdatedOn *time.Time `json:"updated_on,omitempty"`
				User      *struct {
					// Id The ID of the user.
					Id *int `json:"id,omitempty"`

					// Name The name of the user.
					Name *string `json:"name,omitempty"`
				} `json:"user,omitempty"`
			} `json:"time_entry,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest struct {
			Errors *[]string `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseVersionsIndexResponse parses an HTTP response from a VersionsIndexWithResponse call
func ParseVersionsIndexResponse(rsp *http.Response) (*VersionsIndexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VersionsIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// TotalCount The total number of versions.
			TotalCount *int `json:"total_count,omitempty"`
			Versions   *[]struct {
				// CreatedOn The date and time when the version was created.
				CreatedOn    *time.Time `json:"created_on,omitempty"`
				CustomFields *[]struct {
					// Id The ID of the custom field.
					Id *int `json:"id,omitempty"`

					// Multiple Whether the custom field can have multiple values.
					Multiple *bool `json:"multiple,omitempty"`

					// Name The name of the custom field.
					Name  *string      `json:"name,omitempty"`
					Value *interface{} `json:"value,omitempty"`
				} `json:"custom_fields,omitempty"`

				// Description The description of the version.
				Description *string `json:"description,omitempty"`

				// DueDate The date when the version was expired.
				DueDate *openapi_types.Date `json:"due_date,omitempty"`

				// Id The ID of the version.
				Id *int `json:"id,omitempty"`

				// Name The name of the version.
				Name    *string `json:"name,omitempty"`
				Project *struct {
					// Id The ID of the project.
					Id *int `json:"id,omitempty"`

					// Name The name of the project.
					Name *string `json:"name,omitempty"`
				} `json:"project,omitempty"`

				// Sharing The sharing of the version.
				Sharing *string `json:"sharing,omitempty"`

				// Status The status of the version.
				Status *string `json:"status,omitempty"`

				// UpdatedOn The date and time when the version was last updated.
				UpdatedOn *time.Time `json:"updated_on,omitempty"`

				// WikiPageTitle The wiki page title of the version.
				WikiPageTitle *string `json:"wiki_page_title,omitempty"`
			} `json:"versions,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseVersionsCreateResponse parses an HTTP response from a VersionsCreateWithResponse call
func ParseVersionsCreateResponse(rsp *http.Response) (*VersionsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VersionsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Version A single version.
			Version *struct {
				// CreatedOn The date and time when the version was created.
				CreatedOn    *time.Time `json:"created_on,omitempty"`
				CustomFields *[]struct {
					// Id The ID of the custom field.
					Id *int `json:"id,omitempty"`

					// Multiple Whether the custom field can have multiple values.
					Multiple *bool `json:"multiple,omitempty"`

					// Name The name of the custom field.
					Name  *string      `json:"name,omitempty"`
					Value *interface{} `json:"value,omitempty"`
				} `json:"custom_fields,omitempty"`

				// Description The description of the version.
				Description *string `json:"description,omitempty"`

				// DueDate The date when the version was expired.
				DueDate *openapi_types.Date `json:"due_date,omitempty"`

				// EstimatedHours The estimated hours of the version.
				EstimatedHours *float32 `json:"estimated_hours,omitempty"`

				// Id The ID of the version.
				Id *int `json:"id,omitempty"`

				// Name The name of the version.
				Name    *string `json:"name,omitempty"`
				Project *struct {
					// Id The ID of the project.
					Id *int `json:"id,omitempty"`

					// Name The name of the project.
					Name *string `json:"name,omitempty"`
				} `json:"project,omitempty"`

				// Sharing The sharing of the version.
				Sharing *string `json:"sharing,omitempty"`

				// SpentHours The spent hours of the version.
				SpentHours *float32 `json:"spent_hours,omitempty"`

				// Status The status of the version.
				Status *string `json:"status,omitempty"`

				// UpdatedOn The date and time when the version was last updated.
				UpdatedOn *time.Time `json:"updated_on,omitempty"`

				// WikiPageTitle The wiki page title of the version.
				WikiPageTitle *string `json:"wiki_page_title,omitempty"`
			} `json:"version,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest struct {
			Errors *[]string `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseWikiShowRootResponse parses an HTTP response from a WikiShowRootWithResponse call
func ParseWikiShowRootResponse(rsp *http.Response) (*WikiShowRootResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WikiShowRootResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// WikiPage A single wiki.
			WikiPage *struct {
				Attachments *[]WikiShowRoot_200_WikiPage_Attachments_Item `json:"attachments,omitempty"`
				Author      *struct {
					// Id The ID of the author.
					Id *int `json:"id,omitempty"`

					// Name The name of the author.
					Name *string `json:"name,omitempty"`
				} `json:"author,omitempty"`

				// Comments The comments of the wiki.
				Comments *string `json:"comments,omitempty"`

				// CreatedOn The date and time when the wiki was created.
				CreatedOn *time.Time `json:"created_on,omitempty"`
				Parent    *struct {
					// Title The parent title of the wiki.
					Title *string `json:"title,omitempty"`
				} `json:"parent,omitempty"`

				// Text The text of the wiki.
				Text *string `json:"text,omitempty"`

				// Title The title of the wiki.
				Title *string `json:"title,omitempty"`

				// UpdatedOn The date and time when the wiki was last updated.
				UpdatedOn *time.Time `json:"updated_on,omitempty"`

				// Version The version of the wiki.
				Version *int `json:"version,omitempty"`
			} `json:"wiki_page,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseWikiIndexResponse parses an HTTP response from a WikiIndexWithResponse call
func ParseWikiIndexResponse(rsp *http.Response) (*WikiIndexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WikiIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			WikiPages *[]struct {
				// CreatedOn The date and time when the wiki was created.
				CreatedOn *time.Time `json:"created_on,omitempty"`
				Parent    *struct {
					// Title The parent title of the wiki.
					Title *string `json:"title,omitempty"`
				} `json:"parent,omitempty"`

				// Title The title of the wiki.
				Title *string `json:"title,omitempty"`

				// UpdatedOn The date and time when the wiki was last updated.
				UpdatedOn *time.Time `json:"updated_on,omitempty"`

				// Version The version of the wiki.
				Version *int `json:"version,omitempty"`
			} `json:"wiki_pages,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseWikiDestroyResponse parses an HTTP response from a WikiDestroyWithResponse call
func ParseWikiDestroyResponse(rsp *http.Response) (*WikiDestroyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WikiDestroyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseWikiShowResponse parses an HTTP response from a WikiShowWithResponse call
func ParseWikiShowResponse(rsp *http.Response) (*WikiShowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WikiShowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// WikiPage A single wiki.
			WikiPage *struct {
				Attachments *[]WikiShow_200_WikiPage_Attachments_Item `json:"attachments,omitempty"`
				Author      *struct {
					// Id The ID of the author.
					Id *int `json:"id,omitempty"`

					// Name The name of the author.
					Name *string `json:"name,omitempty"`
				} `json:"author,omitempty"`

				// Comments The comments of the wiki.
				Comments *string `json:"comments,omitempty"`

				// CreatedOn The date and time when the wiki was created.
				CreatedOn *time.Time `json:"created_on,omitempty"`
				Parent    *struct {
					// Title The parent title of the wiki.
					Title *string `json:"title,omitempty"`
				} `json:"parent,omitempty"`

				// Text The text of the wiki.
				Text *string `json:"text,omitempty"`

				// Title The title of the wiki.
				Title *string `json:"title,omitempty"`

				// UpdatedOn The date and time when the wiki was last updated.
				UpdatedOn *time.Time `json:"updated_on,omitempty"`

				// Version The version of the wiki.
				Version *int `json:"version,omitempty"`
			} `json:"wiki_page,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseWikiUpdatePatchResponse parses an HTTP response from a WikiUpdatePatchWithResponse call
func ParseWikiUpdatePatchResponse(rsp *http.Response) (*WikiUpdatePatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WikiUpdatePatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// WikiPage A single wiki.
			WikiPage *struct {
				Attachments *[]WikiUpdatePatch_201_WikiPage_Attachments_Item `json:"attachments,omitempty"`
				Author      *struct {
					// Id The ID of the author.
					Id *int `json:"id,omitempty"`

					// Name The name of the author.
					Name *string `json:"name,omitempty"`
				} `json:"author,omitempty"`

				// Comments The comments of the wiki.
				Comments *string `json:"comments,omitempty"`

				// CreatedOn The date and time when the wiki was created.
				CreatedOn *time.Time `json:"created_on,omitempty"`
				Parent    *struct {
					// Title The parent title of the wiki.
					Title *string `json:"title,omitempty"`
				} `json:"parent,omitempty"`

				// Text The text of the wiki.
				Text *string `json:"text,omitempty"`

				// Title The title of the wiki.
				Title *string `json:"title,omitempty"`

				// UpdatedOn The date and time when the wiki was last updated.
				UpdatedOn *time.Time `json:"updated_on,omitempty"`

				// Version The version of the wiki.
				Version *int `json:"version,omitempty"`
			} `json:"wiki_page,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest struct {
			Errors *[]string `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseWikiUpdatePutResponse parses an HTTP response from a WikiUpdatePutWithResponse call
func ParseWikiUpdatePutResponse(rsp *http.Response) (*WikiUpdatePutResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WikiUpdatePutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// WikiPage A single wiki.
			WikiPage *struct {
				Attachments *[]WikiUpdatePut_201_WikiPage_Attachments_Item `json:"attachments,omitempty"`
				Author      *struct {
					// Id The ID of the author.
					Id *int `json:"id,omitempty"`

					// Name The name of the author.
					Name *string `json:"name,omitempty"`
				} `json:"author,omitempty"`

				// Comments The comments of the wiki.
				Comments *string `json:"comments,omitempty"`

				// CreatedOn The date and time when the wiki was created.
				CreatedOn *time.Time `json:"created_on,omitempty"`
				Parent    *struct {
					// Title The parent title of the wiki.
					Title *string `json:"title,omitempty"`
				} `json:"parent,omitempty"`

				// Text The text of the wiki.
				Text *string `json:"text,omitempty"`

				// Title The title of the wiki.
				Title *string `json:"title,omitempty"`

				// UpdatedOn The date and time when the wiki was last updated.
				UpdatedOn *time.Time `json:"updated_on,omitempty"`

				// Version The version of the wiki.
				Version *int `json:"version,omitempty"`
			} `json:"wiki_page,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest struct {
			Errors *[]string `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseWikiShowPdfResponse parses an HTTP response from a WikiShowPdfWithResponse call
func ParseWikiShowPdfResponse(rsp *http.Response) (*WikiShowPdfResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WikiShowPdfResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseWikiShowTxtResponse parses an HTTP response from a WikiShowTxtWithResponse call
func ParseWikiShowTxtResponse(rsp *http.Response) (*WikiShowTxtResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WikiShowTxtResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseWikiShowVersionResponse parses an HTTP response from a WikiShowVersionWithResponse call
func ParseWikiShowVersionResponse(rsp *http.Response) (*WikiShowVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WikiShowVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// WikiPage A single wiki.
			WikiPage *struct {
				Attachments *[]WikiShowVersion_200_WikiPage_Attachments_Item `json:"attachments,omitempty"`
				Author      *struct {
					// Id The ID of the author.
					Id *int `json:"id,omitempty"`

					// Name The name of the author.
					Name *string `json:"name,omitempty"`
				} `json:"author,omitempty"`

				// Comments The comments of the wiki.
				Comments *string `json:"comments,omitempty"`

				// CreatedOn The date and time when the wiki was created.
				CreatedOn *time.Time `json:"created_on,omitempty"`
				Parent    *struct {
					// Title The parent title of the wiki.
					Title *string `json:"title,omitempty"`
				} `json:"parent,omitempty"`

				// Text The text of the wiki.
				Text *string `json:"text,omitempty"`

				// Title The title of the wiki.
				Title *string `json:"title,omitempty"`

				// UpdatedOn The date and time when the wiki was last updated.
				UpdatedOn *time.Time `json:"updated_on,omitempty"`

				// Version The version of the wiki.
				Version *int `json:"version,omitempty"`
			} `json:"wiki_page,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseWikiShowVersionPdfResponse parses an HTTP response from a WikiShowVersionPdfWithResponse call
func ParseWikiShowVersionPdfResponse(rsp *http.Response) (*WikiShowVersionPdfResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WikiShowVersionPdfResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseWikiShowVersionTxtResponse parses an HTTP response from a WikiShowVersionTxtWithResponse call
func ParseWikiShowVersionTxtResponse(rsp *http.Response) (*WikiShowVersionTxtResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WikiShowVersionTxtResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseQueriesIndexResponse parses an HTTP response from a QueriesIndexWithResponse call
func ParseQueriesIndexResponse(rsp *http.Response) (*QueriesIndexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &QueriesIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Limit The maximum number of queries returned in the result set.
			Limit *int `json:"limit,omitempty"`

			// Offset The offset of the first query in the result set.
			Offset  *int `json:"offset,omitempty"`
			Queries *[]struct {
				// Id The unique identifier of the query.
				Id *int `json:"id,omitempty"`

				// IsPublic Whether the query is public.
				IsPublic *bool `json:"is_public,omitempty"`

				// Name The name of the query.
				Name *string `json:"name,omitempty"`

				// ProjectId The unique identifier of the project.
				ProjectId *int `json:"project_id,omitempty"`
			} `json:"queries,omitempty"`

			// TotalCount The total number of queries returned.
			TotalCount *int `json:"total_count,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseIssueRelationsDestroyResponse parses an HTTP response from a IssueRelationsDestroyWithResponse call
func ParseIssueRelationsDestroyResponse(rsp *http.Response) (*IssueRelationsDestroyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssueRelationsDestroyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseIssueRelationsShowResponse parses an HTTP response from a IssueRelationsShowWithResponse call
func ParseIssueRelationsShowResponse(rsp *http.Response) (*IssueRelationsShowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssueRelationsShowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Relation Represents a single issue relation.
			Relation *struct {
				// Delay The delay of the relation.
				Delay *int `json:"delay,omitempty"`

				// Id The ID of the relation.
				Id *int `json:"id,omitempty"`

				// IssueId The ID of the issue.
				IssueId *int `json:"issue_id,omitempty"`

				// IssueToId The ID of the issue to.
				IssueToId *int `json:"issue_to_id,omitempty"`

				// RelationType The relation type of the relation.
				RelationType *string `json:"relation_type,omitempty"`
			} `json:"relation,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRolesIndexResponse parses an HTTP response from a RolesIndexWithResponse call
func ParseRolesIndexResponse(rsp *http.Response) (*RolesIndexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RolesIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Roles *[]struct {
				// Id The unique identifier of the role.
				Id *int `json:"id,omitempty"`

				// Name The name of the role.
				Name *string `json:"name,omitempty"`
			} `json:"roles,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRolesShowResponse parses an HTTP response from a RolesShowWithResponse call
func ParseRolesShowResponse(rsp *http.Response) (*RolesShowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RolesShowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Role Represents a single role with additional details.
			Role *struct {
				// Assignable Whether the role is assignable.
				Assignable *bool `json:"assignable,omitempty"`

				// Id The unique identifier of the role.
				Id *int `json:"id,omitempty"`

				// IssuesVisibility The visibility of issues for this role.
				IssuesVisibility *string `json:"issues_visibility,omitempty"`

				// Name The name of the role.
				Name        *string   `json:"name,omitempty"`
				Permissions *[]string `json:"permissions,omitempty"`

				// TimeEntriesVisibility The time entries visibility of the role.
				TimeEntriesVisibility *string `json:"time_entries_visibility,omitempty"`

				// UsersVisibility The users visibility of the role.
				UsersVisibility *string `json:"users_visibility,omitempty"`
			} `json:"role,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSearchIndexResponse parses an HTTP response from a SearchIndexWithResponse call
func ParseSearchIndexResponse(rsp *http.Response) (*SearchIndexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Limit The maximum number of search results returned in the list.
			Limit *int `json:"limit,omitempty"`

			// Offset The offset of the first search result in the list.
			Offset  *int `json:"offset,omitempty"`
			Results *[]struct {
				// Datetime The date and time when the search result was created.
				Datetime *time.Time `json:"datetime,omitempty"`

				// Description The description of the search result.
				Description *string `json:"description,omitempty"`

				// Id The ID of the search result.
				Id *int `json:"id,omitempty"`

				// Title The title of the search result.
				Title *string `json:"title,omitempty"`

				// Type The type of the search result.
				Type *string `json:"type,omitempty"`

				// Url The url of the search result.
				Url *string `json:"url,omitempty"`
			} `json:"results,omitempty"`

			// TotalCount The total number of search results.
			TotalCount *int `json:"total_count,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTimelogIndexCsvResponse parses an HTTP response from a TimelogIndexCsvWithResponse call
func ParseTimelogIndexCsvResponse(rsp *http.Response) (*TimelogIndexCsvResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TimelogIndexCsvResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTimelogIndexResponse parses an HTTP response from a TimelogIndexWithResponse call
func ParseTimelogIndexResponse(rsp *http.Response) (*TimelogIndexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TimelogIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Limit The maximum number of time entries returned in the list.
			Limit *int `json:"limit,omitempty"`

			// Offset The offset of the first time entry in the list.
			Offset      *int `json:"offset,omitempty"`
			TimeEntries *[]struct {
				Activity *struct {
					// Id The ID of the activity.
					Id *int `json:"id,omitempty"`

					// Name The name of the activity.
					Name *string `json:"name,omitempty"`
				} `json:"activity,omitempty"`

				// Comments The comments of the time entry.
				Comments *string `json:"comments,omitempty"`

				// CreatedOn The date and time when the time entry was created.
				CreatedOn    *time.Time `json:"created_on,omitempty"`
				CustomFields *[]struct {
					// Id The ID of the custom field.
					Id *int `json:"id,omitempty"`

					// Multiple Whether the custom field can have multiple values.
					Multiple *bool `json:"multiple,omitempty"`

					// Name The name of the custom field.
					Name  *string      `json:"name,omitempty"`
					Value *interface{} `json:"value,omitempty"`
				} `json:"custom_fields,omitempty"`

				// Hours The hours of the time entry.
				Hours *float32 `json:"hours,omitempty"`

				// Id The ID of the time entry.
				Id    *int `json:"id,omitempty"`
				Issue *struct {
					// Id The ID of the issue.
					Id *int `json:"id,omitempty"`
				} `json:"issue,omitempty"`
				Project *struct {
					// Id The ID of the project.
					Id *int `json:"id,omitempty"`

					// Name The name of the project.
					Name *string `json:"name,omitempty"`
				} `json:"project,omitempty"`

				// SpentOn The date when the time entry was spent.
				SpentOn *openapi_types.Date `json:"spent_on,omitempty"`

				// UpdatedOn The date and time when the time entry was last updated.
				UpdatedOn *time.Time `json:"updated_on,omitempty"`
				User      *struct {
					// Id The ID of the user.
					Id *int `json:"id,omitempty"`

					// Name The name of the user.
					Name *string `json:"name,omitempty"`
				} `json:"user,omitempty"`
			} `json:"time_entries,omitempty"`

			// TotalCount The total number of time entries.
			TotalCount *int `json:"total_count,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTimelogCreateResponse parses an HTTP response from a TimelogCreateWithResponse call
func ParseTimelogCreateResponse(rsp *http.Response) (*TimelogCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TimelogCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// TimeEntry A single time entry.
			TimeEntry *struct {
				Activity *struct {
					// Id The ID of the activity.
					Id *int `json:"id,omitempty"`

					// Name The name of the activity.
					Name *string `json:"name,omitempty"`
				} `json:"activity,omitempty"`

				// Comments The comments of the time entry.
				Comments *string `json:"comments,omitempty"`

				// CreatedOn The date and time when the time entry was created.
				CreatedOn    *time.Time `json:"created_on,omitempty"`
				CustomFields *[]struct {
					// Id The ID of the custom field.
					Id *int `json:"id,omitempty"`

					// Multiple Whether the custom field can have multiple values.
					Multiple *bool `json:"multiple,omitempty"`

					// Name The name of the custom field.
					Name  *string      `json:"name,omitempty"`
					Value *interface{} `json:"value,omitempty"`
				} `json:"custom_fields,omitempty"`

				// Hours The hours of the time entry.
				Hours *float32 `json:"hours,omitempty"`

				// Id The ID of the time entry.
				Id    *int `json:"id,omitempty"`
				Issue *struct {
					// Id The ID of the issue.
					Id *int `json:"id,omitempty"`
				} `json:"issue,omitempty"`
				Project *struct {
					// Id The ID of the project.
					Id *int `json:"id,omitempty"`

					// Name The name of the project.
					Name *string `json:"name,omitempty"`
				} `json:"project,omitempty"`

				// SpentOn The date when the time entry was spent.
				SpentOn *openapi_types.Date `json:"spent_on,omitempty"`

				// UpdatedOn The date and time when the time entry was last updated.
				UpdatedOn *time.Time `json:"updated_on,omitempty"`
				User      *struct {
					// Id The ID of the user.
					Id *int `json:"id,omitempty"`

					// Name The name of the user.
					Name *string `json:"name,omitempty"`
				} `json:"user,omitempty"`
			} `json:"time_entry,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest struct {
			Errors *[]string `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseTimelogDestroyResponse parses an HTTP response from a TimelogDestroyWithResponse call
func ParseTimelogDestroyResponse(rsp *http.Response) (*TimelogDestroyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TimelogDestroyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest struct {
			Errors *[]string `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseTimelogShowResponse parses an HTTP response from a TimelogShowWithResponse call
func ParseTimelogShowResponse(rsp *http.Response) (*TimelogShowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TimelogShowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// TimeEntry A single time entry.
			TimeEntry *struct {
				Activity *struct {
					// Id The ID of the activity.
					Id *int `json:"id,omitempty"`

					// Name The name of the activity.
					Name *string `json:"name,omitempty"`
				} `json:"activity,omitempty"`

				// Comments The comments of the time entry.
				Comments *string `json:"comments,omitempty"`

				// CreatedOn The date and time when the time entry was created.
				CreatedOn    *time.Time `json:"created_on,omitempty"`
				CustomFields *[]struct {
					// Id The ID of the custom field.
					Id *int `json:"id,omitempty"`

					// Multiple Whether the custom field can have multiple values.
					Multiple *bool `json:"multiple,omitempty"`

					// Name The name of the custom field.
					Name  *string      `json:"name,omitempty"`
					Value *interface{} `json:"value,omitempty"`
				} `json:"custom_fields,omitempty"`

				// Hours The hours of the time entry.
				Hours *float32 `json:"hours,omitempty"`

				// Id The ID of the time entry.
				Id    *int `json:"id,omitempty"`
				Issue *struct {
					// Id The ID of the issue.
					Id *int `json:"id,omitempty"`
				} `json:"issue,omitempty"`
				Project *struct {
					// Id The ID of the project.
					Id *int `json:"id,omitempty"`

					// Name The name of the project.
					Name *string `json:"name,omitempty"`
				} `json:"project,omitempty"`

				// SpentOn The date when the time entry was spent.
				SpentOn *openapi_types.Date `json:"spent_on,omitempty"`

				// UpdatedOn The date and time when the time entry was last updated.
				UpdatedOn *time.Time `json:"updated_on,omitempty"`
				User      *struct {
					// Id The ID of the user.
					Id *int `json:"id,omitempty"`

					// Name The name of the user.
					Name *string `json:"name,omitempty"`
				} `json:"user,omitempty"`
			} `json:"time_entry,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTimelogUpdatePatchResponse parses an HTTP response from a TimelogUpdatePatchWithResponse call
func ParseTimelogUpdatePatchResponse(rsp *http.Response) (*TimelogUpdatePatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TimelogUpdatePatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest struct {
			Errors *[]string `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseTimelogUpdatePutResponse parses an HTTP response from a TimelogUpdatePutWithResponse call
func ParseTimelogUpdatePutResponse(rsp *http.Response) (*TimelogUpdatePutResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TimelogUpdatePutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest struct {
			Errors *[]string `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseTrackersIndexResponse parses an HTTP response from a TrackersIndexWithResponse call
func ParseTrackersIndexResponse(rsp *http.Response) (*TrackersIndexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TrackersIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Trackers *[]struct {
				DefaultStatus *struct {
					// Id The unique identifier of the default status.
					Id *int `json:"id,omitempty"`

					// Name The name of the default status.
					Name *string `json:"name,omitempty"`
				} `json:"default_status,omitempty"`

				// Description A description of the tracker.
				Description           *string   `json:"description,omitempty"`
				EnabledStandardFields *[]string `json:"enabled_standard_fields,omitempty"`

				// Id The unique identifier of the tracker.
				Id *int `json:"id,omitempty"`

				// Name The name of the tracker.
				Name *string `json:"name,omitempty"`
			} `json:"trackers,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAttachmentsUploadResponse parses an HTTP response from a AttachmentsUploadWithResponse call
func ParseAttachmentsUploadResponse(rsp *http.Response) (*AttachmentsUploadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AttachmentsUploadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Upload *struct {
				// Id The ID of the attachment.
				Id *int `json:"id,omitempty"`

				// Token The token of the attachment.
				Token *string `json:"token,omitempty"`
			} `json:"upload,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest struct {
			Errors *[]string `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseUsersIndexCsvResponse parses an HTTP response from a UsersIndexCsvWithResponse call
func ParseUsersIndexCsvResponse(rsp *http.Response) (*UsersIndexCsvResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UsersIndexCsvResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUsersIndexResponse parses an HTTP response from a UsersIndexWithResponse call
func ParseUsersIndexResponse(rsp *http.Response) (*UsersIndexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UsersIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Limit The maximum number of users returned in the list.
			Limit *int `json:"limit,omitempty"`

			// Offset The offset of the first user in the list.
			Offset *int `json:"offset,omitempty"`

			// TotalCount The total number of users.
			TotalCount *int `json:"total_count,omitempty"`
			Users      *[]struct {
				// Admin The administrative of the user.
				Admin      *bool `json:"admin,omitempty"`
				AuthSource *struct {
					// Id The ID of the auth source.
					Id *int `json:"id,omitempty"`

					// Name The name of the auth source.
					Name *string `json:"name,omitempty"`
				} `json:"auth_source,omitempty"`

				// AvatarUrl The avatar URL of the user.
				AvatarUrl *string `json:"avatar_url,omitempty"`

				// CreatedOn The date and time when the user was created.
				CreatedOn    *time.Time `json:"created_on,omitempty"`
				CustomFields *[]struct {
					// Id The ID of the custom field.
					Id *int `json:"id,omitempty"`

					// Multiple Whether the custom field can have multiple values.
					Multiple *bool `json:"multiple,omitempty"`

					// Name The name of the custom field.
					Name  *string      `json:"name,omitempty"`
					Value *interface{} `json:"value,omitempty"`
				} `json:"custom_fields,omitempty"`

				// Firstname The firstname of the user.
				Firstname *string `json:"firstname,omitempty"`

				// Id The ID of the user.
				Id *int `json:"id,omitempty"`

				// LastLoginOn The date and time when the user was last logon.
				LastLoginOn *time.Time `json:"last_login_on,omitempty"`

				// Lastname The lastname of the user.
				Lastname *string `json:"lastname,omitempty"`

				// Login The login of the user.
				Login *string `json:"login,omitempty"`

				// Mail The mail of the user.
				Mail *string `json:"mail,omitempty"`

				// PasswdChangedOn The date and time when the user was change password.
				PasswdChangedOn *time.Time `json:"passwd_changed_on,omitempty"`

				// Status The status of the user. Possible values are:
				// - `0`: anonymous
				// - `1`: active
				// - `2`: registered
				// - `3`: locked
				Status *int `json:"status,omitempty"`

				// TwofaScheme The 2FA scheme of the user.
				TwofaScheme *string `json:"twofa_scheme,omitempty"`

				// UpdatedOn The date and time when the user was last updated.
				UpdatedOn *time.Time `json:"updated_on,omitempty"`
			} `json:"users,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUsersCreateResponse parses an HTTP response from a UsersCreateWithResponse call
func ParseUsersCreateResponse(rsp *http.Response) (*UsersCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UsersCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// User A single user.
			User *struct {
				// Admin The administrative of the user.
				Admin *bool `json:"admin,omitempty"`

				// ApiKey The API key of the user.
				ApiKey     *string `json:"api_key,omitempty"`
				AuthSource *struct {
					// Id The ID of the auth source.
					Id *int `json:"id,omitempty"`

					// Name The name of the auth source.
					Name *string `json:"name,omitempty"`
				} `json:"auth_source,omitempty"`

				// AvatarUrl The avatar URL of the user.
				AvatarUrl *string `json:"avatar_url,omitempty"`

				// CreatedOn The date and time when the user was created.
				CreatedOn    *time.Time `json:"created_on,omitempty"`
				CustomFields *[]struct {
					// Id The ID of the custom field.
					Id *int `json:"id,omitempty"`

					// Multiple Whether the custom field can have multiple values.
					Multiple *bool `json:"multiple,omitempty"`

					// Name The name of the custom field.
					Name  *string      `json:"name,omitempty"`
					Value *interface{} `json:"value,omitempty"`
				} `json:"custom_fields,omitempty"`

				// Firstname The firstname of the user.
				Firstname *string `json:"firstname,omitempty"`
				Groups    *[]struct {
					// Id The ID of the group.
					Id *int `json:"id,omitempty"`

					// Name The name of the group.
					Name *string `json:"name,omitempty"`
				} `json:"groups,omitempty"`

				// Id The ID of the user.
				Id *int `json:"id,omitempty"`

				// LastLoginOn The date and time when the user was last logon.
				LastLoginOn *time.Time `json:"last_login_on,omitempty"`

				// Lastname The lastname of the user.
				Lastname *string `json:"lastname,omitempty"`

				// Login The login of the user.
				Login *string `json:"login,omitempty"`

				// Mail The mail of the user.
				Mail        *string `json:"mail,omitempty"`
				Memberships *[]struct {
					// Id The ID of the mebership.
					Id      *int `json:"id,omitempty"`
					Project *struct {
						// Id The ID of the project.
						Id *int `json:"id,omitempty"`

						// Name The name of the project.
						Name *string `json:"name,omitempty"`
					} `json:"project,omitempty"`
					Roles *[]struct {
						// Id The ID of the role.
						Id *int `json:"id,omitempty"`

						// Inherited Whether the role is inherited from a parent project.
						Inherited *bool `json:"inherited,omitempty"`

						// Name The name of the role.
						Name *string `json:"name,omitempty"`
					} `json:"roles,omitempty"`
				} `json:"memberships,omitempty"`

				// PasswdChangedOn The date and time when the user was change password.
				PasswdChangedOn *time.Time `json:"passwd_changed_on,omitempty"`

				// Status The status of the user. Possible values are:
				// - `0`: anonymous
				// - `1`: active
				// - `2`: registered
				// - `3`: locked
				Status *int `json:"status,omitempty"`

				// TwofaScheme The 2FA scheme of the user.
				TwofaScheme *string `json:"twofa_scheme,omitempty"`

				// UpdatedOn The date and time when the user was last updated.
				UpdatedOn *time.Time `json:"updated_on,omitempty"`
			} `json:"user,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest struct {
			Errors *[]string `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseUsersDestroyResponse parses an HTTP response from a UsersDestroyWithResponse call
func ParseUsersDestroyResponse(rsp *http.Response) (*UsersDestroyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UsersDestroyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest struct {
			Errors *[]string `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseUsersShowResponse parses an HTTP response from a UsersShowWithResponse call
func ParseUsersShowResponse(rsp *http.Response) (*UsersShowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UsersShowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// User A single user.
			User *struct {
				// Admin The administrative of the user.
				Admin *bool `json:"admin,omitempty"`

				// ApiKey The API key of the user.
				ApiKey     *string `json:"api_key,omitempty"`
				AuthSource *struct {
					// Id The ID of the auth source.
					Id *int `json:"id,omitempty"`

					// Name The name of the auth source.
					Name *string `json:"name,omitempty"`
				} `json:"auth_source,omitempty"`

				// AvatarUrl The avatar URL of the user.
				AvatarUrl *string `json:"avatar_url,omitempty"`

				// CreatedOn The date and time when the user was created.
				CreatedOn    *time.Time `json:"created_on,omitempty"`
				CustomFields *[]struct {
					// Id The ID of the custom field.
					Id *int `json:"id,omitempty"`

					// Multiple Whether the custom field can have multiple values.
					Multiple *bool `json:"multiple,omitempty"`

					// Name The name of the custom field.
					Name  *string      `json:"name,omitempty"`
					Value *interface{} `json:"value,omitempty"`
				} `json:"custom_fields,omitempty"`

				// Firstname The firstname of the user.
				Firstname *string `json:"firstname,omitempty"`
				Groups    *[]struct {
					// Id The ID of the group.
					Id *int `json:"id,omitempty"`

					// Name The name of the group.
					Name *string `json:"name,omitempty"`
				} `json:"groups,omitempty"`

				// Id The ID of the user.
				Id *int `json:"id,omitempty"`

				// LastLoginOn The date and time when the user was last logon.
				LastLoginOn *time.Time `json:"last_login_on,omitempty"`

				// Lastname The lastname of the user.
				Lastname *string `json:"lastname,omitempty"`

				// Login The login of the user.
				Login *string `json:"login,omitempty"`

				// Mail The mail of the user.
				Mail        *string `json:"mail,omitempty"`
				Memberships *[]struct {
					// Id The ID of the mebership.
					Id      *int `json:"id,omitempty"`
					Project *struct {
						// Id The ID of the project.
						Id *int `json:"id,omitempty"`

						// Name The name of the project.
						Name *string `json:"name,omitempty"`
					} `json:"project,omitempty"`
					Roles *[]struct {
						// Id The ID of the role.
						Id *int `json:"id,omitempty"`

						// Inherited Whether the role is inherited from a parent project.
						Inherited *bool `json:"inherited,omitempty"`

						// Name The name of the role.
						Name *string `json:"name,omitempty"`
					} `json:"roles,omitempty"`
				} `json:"memberships,omitempty"`

				// PasswdChangedOn The date and time when the user was change password.
				PasswdChangedOn *time.Time `json:"passwd_changed_on,omitempty"`

				// Status The status of the user. Possible values are:
				// - `0`: anonymous
				// - `1`: active
				// - `2`: registered
				// - `3`: locked
				Status *int `json:"status,omitempty"`

				// TwofaScheme The 2FA scheme of the user.
				TwofaScheme *string `json:"twofa_scheme,omitempty"`

				// UpdatedOn The date and time when the user was last updated.
				UpdatedOn *time.Time `json:"updated_on,omitempty"`
			} `json:"user,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUsersUpdatePatchResponse parses an HTTP response from a UsersUpdatePatchWithResponse call
func ParseUsersUpdatePatchResponse(rsp *http.Response) (*UsersUpdatePatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UsersUpdatePatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest struct {
			Errors *[]string `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseUsersUpdatePutResponse parses an HTTP response from a UsersUpdatePutWithResponse call
func ParseUsersUpdatePutResponse(rsp *http.Response) (*UsersUpdatePutResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UsersUpdatePutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest struct {
			Errors *[]string `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseVersionsDestroyResponse parses an HTTP response from a VersionsDestroyWithResponse call
func ParseVersionsDestroyResponse(rsp *http.Response) (*VersionsDestroyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VersionsDestroyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseVersionsShowResponse parses an HTTP response from a VersionsShowWithResponse call
func ParseVersionsShowResponse(rsp *http.Response) (*VersionsShowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VersionsShowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Version A single version.
			Version *struct {
				// CreatedOn The date and time when the version was created.
				CreatedOn    *time.Time `json:"created_on,omitempty"`
				CustomFields *[]struct {
					// Id The ID of the custom field.
					Id *int `json:"id,omitempty"`

					// Multiple Whether the custom field can have multiple values.
					Multiple *bool `json:"multiple,omitempty"`

					// Name The name of the custom field.
					Name  *string      `json:"name,omitempty"`
					Value *interface{} `json:"value,omitempty"`
				} `json:"custom_fields,omitempty"`

				// Description The description of the version.
				Description *string `json:"description,omitempty"`

				// DueDate The date when the version was expired.
				DueDate *openapi_types.Date `json:"due_date,omitempty"`

				// EstimatedHours The estimated hours of the version.
				EstimatedHours *float32 `json:"estimated_hours,omitempty"`

				// Id The ID of the version.
				Id *int `json:"id,omitempty"`

				// Name The name of the version.
				Name    *string `json:"name,omitempty"`
				Project *struct {
					// Id The ID of the project.
					Id *int `json:"id,omitempty"`

					// Name The name of the project.
					Name *string `json:"name,omitempty"`
				} `json:"project,omitempty"`

				// Sharing The sharing of the version.
				Sharing *string `json:"sharing,omitempty"`

				// SpentHours The spent hours of the version.
				SpentHours *float32 `json:"spent_hours,omitempty"`

				// Status The status of the version.
				Status *string `json:"status,omitempty"`

				// UpdatedOn The date and time when the version was last updated.
				UpdatedOn *time.Time `json:"updated_on,omitempty"`

				// WikiPageTitle The wiki page title of the version.
				WikiPageTitle *string `json:"wiki_page_title,omitempty"`
			} `json:"version,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseVersionsUpdatePatchResponse parses an HTTP response from a VersionsUpdatePatchWithResponse call
func ParseVersionsUpdatePatchResponse(rsp *http.Response) (*VersionsUpdatePatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VersionsUpdatePatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest struct {
			Errors *[]string `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseVersionsUpdatePutResponse parses an HTTP response from a VersionsUpdatePutWithResponse call
func ParseVersionsUpdatePutResponse(rsp *http.Response) (*VersionsUpdatePutResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VersionsUpdatePutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest struct {
			Errors *[]string `json:"errors,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseVersionsShowTxtResponse parses an HTTP response from a VersionsShowTxtWithResponse call
func ParseVersionsShowTxtResponse(rsp *http.Response) (*VersionsShowTxtResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VersionsShowTxtResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseWatchersDestroyResponse parses an HTTP response from a WatchersDestroyWithResponse call
func ParseWatchersDestroyResponse(rsp *http.Response) (*WatchersDestroyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WatchersDestroyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseWatchersCreateResponse parses an HTTP response from a WatchersCreateWithResponse call
func ParseWatchersCreateResponse(rsp *http.Response) (*WatchersCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WatchersCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}
